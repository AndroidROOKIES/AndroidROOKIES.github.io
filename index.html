<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="每天一小步，人生一大步">
<meta property="og:type" content="website">
<meta property="og:title" content="Feng's Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Feng's Notes">
<meta property="og:description" content="每天一小步，人生一大步">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feng's Notes">
<meta name="twitter:description" content="每天一小步，人生一大步">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Feng's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Feng's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/10/JNI系列-二-JNI数据类型与属性方法的访问/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/10/JNI系列-二-JNI数据类型与属性方法的访问/" itemprop="url">
                  JNI系列(二)JIN数据类型与属性方法的访问
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-10T16:08:15+08:00">
                2017-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JNI基本数据类型"><a href="#JNI基本数据类型" class="headerlink" title="JNI基本数据类型"></a>JNI基本数据类型</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/04/JNI系列-一-JNI开发流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/04/JNI系列-一-JNI开发流程/" itemprop="url">
                  JNI系列(一)JNI开发流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T15:41:24+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1><h2 id="1-什么是JNI"><a href="#1-什么是JNI" class="headerlink" title="1.什么是JNI"></a>1.什么是JNI</h2><p>JNI（全称:Java Native Interface）</p>
<p>Java调用C/C++，或者C/C++调用Java的一套API。</p>
<p>NDK开发需要用到JNI。</p>
<p>为什么使用Java调用c/c++？</p>
<ol>
<li>提升效率</li>
<li>防止反编译</li>
</ol>
<h1 id="JNI开发流程"><a href="#JNI开发流程" class="headerlink" title="JNI开发流程"></a>JNI开发流程</h1><ol>
<li>编写native方法</li>
<li>javah命令，生成.h头文件</li>
<li>复制.h头文件到CPP工程中，目的是实现头文件中声明的函数</li>
<li>复制jni.h和jni_md.h文件到CPP工程中</li>
<li>实现.h头文件中声明的函数</li>
<li>生成dll文件</li>
<li>配置dll文件所在目录到环境变量</li>
<li>重启Eclipse</li>
</ol>
<h1 id="JNI详细开发步骤流程"><a href="#JNI详细开发步骤流程" class="headerlink" title="JNI详细开发步骤流程"></a>JNI详细开发步骤流程</h1><p>下面以一个Java工程项目调c为例：</p>
<p>创建Java工程，编写native方法，这里创建了getStringFromC方法：</p>
<pre><code>package com.test;

public class JniTest {

    public static native String getStringFromC();
}
</code></pre><p>打开dos命令，通过cd命令切换到当前Java工程的src目录下面，执行javah命令，参数是完整类名：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/01.png" alt=""></p>
<p>然后在src目录就会生成.h头文件：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/02.png" alt=""></p>
<p>然后将这个头文件拷贝到C/C++工程目录下，然后在VS2013中“头文件-&gt;添加-&gt;现有项”，加到工程中：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/03.png" alt=""></p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/04.png" alt=""></p>
<p>同时，到JDK目录下把jni.h、jni_md.h也通过这种方法加进来</p>
<p>注意：include&lt;&gt;是引入系统的头文件，include””是引入自己的头文件，因此这里需要改一下，否则会报错。</p>
<p>在Test.c文件中实现native方法：</p>
<pre><code>#include &quot;com_test_JniTest.h&quot;

JNIEXPORT jstring JNICALL Java_com_test_JniTest_getStringFromC
(JNIEnv * env, jclass jcls){

    //返回Java的字符串，这里先不作讲解
    return (*env)-&gt;NewStringUTF(env, &quot;String From C&quot;);

}
</code></pre><p>配置解决方案平台，新建平台，选择X64平台：</p>
<p>选择“配置管理器”</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/05.png" alt=""></p>
<p>“活动解决方案平台-&gt;新建</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/06.png" alt=""></p>
<p>选择x64,点击确定按钮</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/07.png" alt=""></p>
<p>配置解决方案的类型，选择输出动态库文件：</p>
<p>选中c项目,右键-&gt;属性</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/08.jpg" alt=""></p>
<p>点击“配置类型”-&gt;动态库(.dll)-&gt;应用-&gt;确定</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/09.png" alt=""></p>
<p>注意：Windows下面动态库以dll结尾，Linux下面以so结尾</p>
<p>在工程生成dll文件，然后把这个目录添加到环境变量中，这样做的目的是为了Java在执行的时候能够找到我们的动态库文件</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/10.png" alt=""></p>
<p>最后回到Java工程，通过System.loadLibrary导入动态库</p>
<pre><code>package com.test;

public class JniTest {

    static{
        System.loadLibrary(&quot;ConsoleApplication5&quot;);
    }
    public static native String getStringFromC();

    public static void main(String[] args) {
        String str =getStringFromC();
        System.out.println(str);
    }
}
</code></pre><p>重新启动eclipse进行测试</p>
<h2 id="JNI的调用过程"><a href="#JNI的调用过程" class="headerlink" title="JNI的调用过程"></a>JNI的调用过程</h2><p><img src="http://oph0qv0je.bkt.clouddn.com/11.png" alt=""></p>
<h2 id="动态库与静态库"><a href="#动态库与静态库" class="headerlink" title="动态库与静态库"></a>动态库与静态库</h2><p>Linux平台下：动态库是.so，静态库是.a</p>
<p>Windows平台下：动态库是.dll，静态库是.lib</p>
<p>动态库可以多个应用共享代码，静态库是全部都会包含在最终生成的exe文件里</p>
<p>JNIEnv：JNIEnv里面有很多方法，与Java进行交互，代表Java的运行环境。</p>
<p>在C中：</p>
<p>JNIEnv 结构体指针别名</p>
<p>env二级指针</p>
<p>在C++中：</p>
<p>JNIEnv 是一个结构体的别名</p>
<p>env 一级指针</p>
<p>C/C++中为什么有区别？</p>
<ol>
<li>为什么需要传入JNIEnv，函数执行过程中需要JNIEnv</li>
<li>C++为什么没有传入？this</li>
<li>C++只是对C的那一套进行的封装，给一个变量赋值为指针，这个变量是二级指针</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/04/C语言学习系列-五-预编译-宏定义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/04/C语言学习系列-五-预编译-宏定义/" itemprop="url">
                  C语言学习系列(五)预编译-宏定义
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T10:58:06+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><p>C语言执行的流程</p>
<ol>
<li>编译：形成目标代码(.obj)</li>
<li>连接：将目标代码与C函数库连接合并，形成最终的可执行文件</li>
<li>执行</li>
</ol>
<p>预编译（预处理），为编译做准备工作，完成代码文本的替换工作。</p>
<p>头文件告诉编译器有这样一个函数，连接器负责找到这个函数的实现，通过include引入。(类似android中include标签)。</p>
<p>举例：</p>
<p>创建头文件my.txt文件</p>
<pre><code>printf(&quot;hello&quot;);
</code></pre><p>主函数中使用：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

void main(){

    #include &quot;my.txt&quot;//其实就是替换my.txt中的内容（include包含我们自己定义的头文件时用“”，系统中的用&lt;&gt;）

    system(&quot;pause&quot;);
}
</code></pre><h1 id="宏定义、宏替换、预编译指令"><a href="#宏定义、宏替换、预编译指令" class="headerlink" title="宏定义、宏替换、预编译指令"></a>宏定义、宏替换、预编译指令</h1><p>define指令</p>
<ol>
<li>定义标示</li>
<li>定义常数（便于修改与阅读）</li>
<li>定义“宏函数”</li>
</ol>
<h2 id="1-定义标示"><a href="#1-定义标示" class="headerlink" title="1. 定义标示"></a>1. 定义标示</h2><p>举例1：</p>
<pre><code>//表示支持C++语法
#ifdef __cplusplus

#endif //相当于if(){}后面的括号

//表示支持Android、Windows、苹果平台等等
#ifdef ANDROID

#endif
</code></pre><p>举例2：</p>
<p>防止文件重复引入</p>
<p>有三个文件A.h、B.h、Test.cpp，分别如下：</p>
<p>A.h：</p>
<pre><code>#include &quot;B.h&quot;
void printfA();
</code></pre><p>B.h：</p>
<pre><code>#include &quot;A.h&quot;
void printfB();
</code></pre><p>Test.cpp里面引用了A.h</p>
<pre><code>#include &quot;A.h&quot;
</code></pre><p>当Test包含a的时候，a又会去包含b，b又会包含a，这样就会造成循环包含。类似于Hibernate里面的SQL循环引用。最终会报如下错误：</p>
<pre><code>fatal error C1014: 包含文件太多 : 深度 = 1024
</code></pre><p>通过宏定义判断来解决这个问题（修改A.h）：</p>
<pre><code>//如果没有定义AH，定义AH
#ifndef AH
#define AH
#include &quot;B.h&quot;

void printfA();

#endif
</code></pre><p>修改B.h:</p>
<pre><code>#ifndef BH
#define BH
#include &quot;A.h&quot;

void printfB();

#endif
</code></pre><p>以上为老版本的解决方法，在新版本中可以用：</p>
<p>修改A.h：</p>
<pre><code>//该头文件只被包含一次，让编译器自定处理好循环包含问题
#pragma once
#include &quot;B.h&quot;

void printfA();
</code></pre><p>修改B.h:</p>
<pre><code>#pragma once
#include &quot;A.h&quot;

void printfB();
</code></pre><h2 id="2-定义常数（便于修改与阅读）"><a href="#2-定义常数（便于修改与阅读）" class="headerlink" title="2. 定义常数（便于修改与阅读）"></a>2. 定义常数（便于修改与阅读）</h2><p>举例：</p>
<pre><code>#define MAX 100

void main(){

    int i = 90;
    if (i &lt; MAX){
    printf(&quot;比MAX小..&quot;);
    }

    system(&quot;pause&quot;);
}
</code></pre><h2 id="3-定义“宏函数”"><a href="#3-定义“宏函数”" class="headerlink" title="3. 定义“宏函数”"></a>3. 定义“宏函数”</h2><p>就是一个替换的过程</p>
<pre><code>//普通函数(无参数)
void dn_com_jni_read(){
    printf(&quot;read\n&quot;);
}

void dn_com_jni_write(){
    printf(&quot;write\n&quot;);
}

//宏函数
//NAME是参数（比如代表普通函数的read/write）
#define jni(NAME)  dn_com_jni_##NAME();

void main(){
     //调用
    jni(write);//替换：dn_com_jni_write();
    getchar();
}
</code></pre><p>日志输出：</p>
<pre><code>//__VA_ARGS__ 代表可变参数
#define LOG(FORMAT,...) printf(##FORMAT,__VA_ARGS__); 

void main(){

        LOG(&quot;%s%d&quot;,&quot;大小：&quot;,89);//相当于替换成：printf(&quot;%s%d&quot;,&quot;大小：&quot;,89);
        getchar();
    }
</code></pre><p>LOG会有级别，于是进一步升级：</p>
<pre><code>#define LOG_I(FORMAT,...)  printf(&quot;INFO:&quot;); printf(##FORMAT,__VA_ARGS__); 

#define LOG_E(FORMAT,...)  printf(&quot;ERRO:&quot;); printf(##FORMAT,__VA_ARGS__); 

void main(){

            LOG_I(&quot;%s%d&quot;,&quot;大小：&quot;,89);
            //替换成：printf(&quot;INFO:&quot;); printf(&quot;%s%d&quot;,&quot;大小：&quot;,89);
        }
</code></pre><p>进一步简化重复代码，重复LEVEL日志级别：</p>
<pre><code>#define LOG(LEVEL,FORMAT,...) printf(##LEVEL); printf(##FORMAT,__VA_ARGS__);
#define LOG_I(FORMAT,...) LOG(&quot;INFO:&quot;,##FORMAT,__VA_ARGS__);
#define LOG_E(FORMAT,...) LOG(&quot;ERROR:&quot;,##FORMAT,__VA_ARGS__);
#define LOG_W(FORMAT,...) LOG(&quot;WARN:&quot;,##FORMAT,__VA_ARGS__);
</code></pre><p>举例：</p>
<p>在Android JNI开发的时候，我们打印一句日志是通过__android_log_print函数来实现的，因此我们可以通过宏定义简化代码：</p>
<pre><code>//Android
#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,&quot;isen&quot;,FORMAT,##__VA_ARGS__);

LOGI(&quot;%s&quot;,&quot;ok&quot;);
//替换__android_log_print(ANDROID_LOG_INFO, &quot;isen&quot;, &quot;%s&quot;, &quot;ok&quot;);
</code></pre><p>C语言系列到此结束，接下来进入JNI系列。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/27/C语言学习系列-四-联合体-枚举-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/27/C语言学习系列-四-联合体-枚举-IO/" itemprop="url">
                  C语言学习系列(四)联合体-枚举-IO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T09:44:44+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="联合体-共用体"><a href="#联合体-共用体" class="headerlink" title="联合体(共用体)"></a>联合体(共用体)</h1><p>不同类型的变量共同占用一段内存（相互覆盖），联合变量任何时刻只有一个成员存在，节省内存。<br>联合体变量的大小=最大的成员所占的字节数</p>
<pre><code>union  MyValue{
    int x;
    int y;
    double z;
};

void main(){
    union MyValue d1;
    d1.x = 90;
    d1.y = 100; //最后一次赋值有效
    //d1.z = 23.8;

    printf(&quot;%d,%d,%lf\n&quot;,d1.x,d1.y,d1.z);
    system(&quot;pause&quot;);
}
</code></pre><p>JNI头文件中的联合体：</p>
<pre><code>typedef union jvalue {
    jboolean    z;
    jbyte       b;
    jchar       c;
    jshort      s;
    jint        i;
    jlong       j;
    jfloat      f;
    jdouble     d;
    jobject     l;
} jvalue;
</code></pre><h1 id="枚举（列举所有的情况）"><a href="#枚举（列举所有的情况）" class="headerlink" title="枚举（列举所有的情况）"></a>枚举（列举所有的情况）</h1><p>限定值，保证取值的安全性</p>
<pre><code>enum Day
{
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
};


void main(){
    //枚举的值，必须是括号中的值
    enum Day d = Monday;
    printf(&quot;%#x,%d\n&quot;,&amp;d,d);

    getchar();
}
</code></pre><h1 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h1><p>读写文本文件</p>
<p>主要用到了fgets和fputs两个函数（函数名中的s是指String，字符串的意思）：</p>
<pre><code>void main(){
    char *path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends.txt&quot;;
    //打开(r表示读)
    FILE *fp = fopen(path,&quot;r&quot;);
    if (fp == NULL){
        printf(&quot;文件打开失败...&quot;);
        return;
    }
    //读取
    char buff[50]; //缓冲
    while (fgets(buff,50,fp)){
        printf(&quot;%s&quot;,buff);
    }
    //关闭
    fclose(fp);
    system(&quot;pause&quot;);

    getchar();
}

//写入
void main(){
    char *path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends_new.txt&quot;;
    //打开
    FILE *fp = fopen(path, &quot;w&quot;);
    char *text = &quot;hchmily@sina.com,程华才,学清路 8\n号科技财富中心 A&quot;;
    fputs(text,fp);

    //关闭流
    fclose(fp);
    getchar();
}
</code></pre><h1 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h1><p>计算机的文件存储在物理上都是二进制，文本文件和二进制之分，其实是一个逻辑之分</p>
<p>C读写文本文件与二进制文件的差别仅仅体现在回车换行符：</p>
<ol>
<li>写文本时，每遇到一个’\n’，会将其转换成’\r\n’(回车换行)。</li>
<li>读文本时，每遇到一个’\r\n’，会将其转换成’\n’。</li>
<li>但是读写二进制文件的时候并不会做以上转换。</li>
</ol>
<p>文件复制</p>
<pre><code>void main(){
    char *read_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan.png&quot;;
    char *write_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan_new.png&quot;;
    //读的文件 b字符表示操作二进制文件binary
    FILE *read_fp = fopen(read_path, &quot;rb&quot;);
    //写的文件
    FILE *write_fp = fopen(write_path, &quot;wb&quot;);

    //复制
    int buff[50]; //缓冲区域（读写二进制文件，类型用int）
    int len = 0; //每次读到的数据长度
    while ((len = fread(buff, sizeof(int), 50, read_fp)) != 0){
        //将读到的内容写入新的文件
        fwrite(buff,sizeof(int),len,write_fp);
    }
    //关闭流
    fclose(read_fp);
    fclose(write_fp);
    getchar();
}
</code></pre><h1 id="获取文件的大小"><a href="#获取文件的大小" class="headerlink" title="获取文件的大小"></a>获取文件的大小</h1><pre><code>void main(){
    char *read_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan.png&quot;;
    FILE *fp = fopen(read_path, &quot;r&quot;);
    //重新定位文件指针
    //SEEK_END文件末尾，0偏移量
    fseek(fp,0,SEEK_END);
    //返回当前的文件指针，相对于文件开头的位移量
    long filesize = ftell(fp);
    printf(&quot;%d\n&quot;,filesize);

    getchar();
}
</code></pre><h1 id="文本文件加解密"><a href="#文本文件加解密" class="headerlink" title="文本文件加解密"></a>文本文件加解密</h1><p>用简单的异或运算进行加密，解密的话就是一个逆过程。</p>
<p>规则：1^1=0, 0^0=0, 1^0=1, 0^1=1 同为0，不同为1</p>
<pre><code>//加密
void crpypt(char normal_path[],char crypt_path[]){
    //打开文件
    FILE *normal_fp = fopen(normal_path, &quot;r&quot;);
    FILE *crypt_fp = fopen(crypt_path, &quot;w&quot;);
    //一次读取一个字符
    int ch;
    while ((ch = fgetc(normal_fp)) != EOF){ //End of File
        //写入（异或运算）
        fputc(ch ^ 9,crypt_fp);
    }
    //关闭
    fclose(crypt_fp);
    fclose(normal_fp);
}

//解密
void decrpypt(char crypt_path[], char decrypt_path[]){
    //打开文件
    FILE *normal_fp = fopen(crypt_path, &quot;r&quot;);
    FILE *crypt_fp = fopen(decrypt_path, &quot;w&quot;);
    //一次读取一个字符
    int ch;
    while ((ch = fgetc(normal_fp)) != EOF){ //End of File
        //写入（异或运算）
        fputc(ch ^ 9, crypt_fp);
    }
    //关闭
    fclose(crypt_fp);
    fclose(normal_fp);

}

void main(){
    char *normal_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends.txt&quot;;
    char *crypt_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends_crypt.txt&quot;;
    char *decrypt_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends_decrypt.txt&quot;;

    //crpypt(normal_path, crypt_path);
    //解密
    decrpypt(crypt_path, decrypt_path);

    getchar();
}
</code></pre><h1 id="二进制文件加解密"><a href="#二进制文件加解密" class="headerlink" title="二进制文件加解密"></a>二进制文件加解密</h1><pre><code>//二进制文件加解密
//读取二进制文件中的数据时，一个一个字符读取
//密码：ilovely
/*
void crpypt(char normal_path[], char crypt_path[],char password[]){
    //打开文件
    FILE *normal_fp = fopen(normal_path, &quot;rb&quot;);
    FILE *crypt_fp = fopen(crypt_path, &quot;wb&quot;);
    //一次读取一个字符
    int ch;
    int i = 0; //循环使用密码中的字母进行异或运算
    int pwd_len = strlen(password); //密码的长度
    while ((ch = fgetc(normal_fp)) != EOF){ //End of File
        //写入（异或运算）
        fputc(ch ^ password[i % pwd_len], crypt_fp);
        i++;
    }
    //关闭
    fclose(crypt_fp);
    fclose(normal_fp);
}

//解密
void decrpypt(char crypt_path[], char decrypt_path[],char password[]){
    //打开文件
    FILE *normal_fp = fopen(crypt_path, &quot;rb&quot;);
    FILE *crypt_fp = fopen(decrypt_path, &quot;wb&quot;);
    //一次读取一个字符
    int ch;
    int i = 0; //循环使用密码中的字母进行异或运算
    int pwd_len = strlen(password); //密码的长度
    while ((ch = fgetc(normal_fp)) != EOF){ //End of File
        //写入（异或运算）
        fputc(ch ^ password[i % pwd_len], crypt_fp);
        i++;
    }
    //关闭
    fclose(crypt_fp);
    fclose(normal_fp);

}

void main(){
    char *normal_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan.png&quot;;
    char *crypt_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan_crypt.png&quot;;
    char *decrypt_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan_decrypt.png&quot;;

    //crpypt(normal_path, crypt_path,&quot;iloveqq&quot;);
    //解密
    decrpypt(crypt_path, decrypt_path,&quot;iloveqq&quot;);

    getchar();
}
*/
</code></pre><p>对于微信之类的应用，他们的数据库都是加密的，用的是C语言(动态库so)加密,不用Java去做，安全性不够，容易被反编译。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/C语言学习系列-三-结构体/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/25/C语言学习系列-三-结构体/" itemprop="url">
                  C语言学习系列(三)结构体
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-25T10:59:26+08:00">
                2017-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>结构体是一种构造数据类型(类似Java中的类)，把不同的数据类型整合起来成为一个自定义的数据类型。</p>
<p> 举例</p>
<pre><code>/*
struct Man{
    char name[20];
    int age;
};


void main(){
    //初始化结构体变量
    //结构体初始化方法一
    //struct Man m1 = {&quot;jack&quot;,19};

    //结构体初始化方法二
    struct Man m1;
    m1.age = 30;
    strcpy(m1.name,&quot;rose&quot;);

    printf(&quot;%d\n&quot;,m1.age);
    printf(&quot;%s\n&quot;,m1.name);
    system(&quot;pause&quot;);
};
*/
</code></pre><p>结构体的几种写法</p>
<pre><code>struct Man{
    char name[20];
    int age;
}m1, m2 = { &quot;jack&quot;, 20 };//m1结构体变量名

void main(){
    m1.age = 35;
    strcpy(m1.name,&quot;isen&quot;);
    printf(&quot;%d\n&quot;, m1.age);
    printf(&quot;%s\n&quot;, m1.name);
    system(&quot;pause&quot;);
};
</code></pre><p>匿名结构体：控制结构体变量的个数（限量版），相当于单例。</p>
<pre><code>struct{
    char name[20];
    int age;
}m1;
</code></pre><p>结构体嵌套</p>
<pre><code>/*
struct Teacher{
    char name[20];
};

struct Student{
    char name[20];
    int age;
    struct Teacher t;
};

void main(){
    //字面量的方式
    //struct Student s1 = { &quot;jack&quot;, 21, {&quot;Jason&quot;} };
    struct Student s1;
    s1.age = 10;
    strcpy(s1.t.name, &quot;Jason&quot;);
    system(&quot;pause&quot;);
}
*/
</code></pre><p>结构体嵌套2</p>
<pre><code>/*
struct Student{
    char name[20];
    int age;
    struct Teacher{
        char name[20];
    } t;
};

void main(){
    struct Student s1;
    strcpy(s1.t.name, &quot;Jason&quot;);
    //struct Teacher t;


    system(&quot;pause&quot;);
}
*/
</code></pre><p>结构体与指针</p>
<pre><code>struct Man{
    char name[20];
    int age;
};

void main(){
    struct Man m1 = {&quot;isen&quot;,20};
    //结构体指针
    struct Man *p = &amp;m1;
    printf(&quot;%s,%d\n&quot;, m1.name, m1.age);
    printf(&quot;%s,%d\n&quot;, (*p).name, (*p).age);

    //“-&gt;”（箭头）是“(*p).”简写形式
    printf(&quot;%s,%d\n&quot;,p-&gt;name,p-&gt;age);

    system(&quot;pause&quot;);
}
</code></pre><p>指针与结构体数组</p>
<pre><code>struct Man{
    char name[20];
    int age;
};

void main(){
    struct Man mans[] = { { &quot;isen&quot;, 26 }, { &quot;yahui&quot;, 25 } };
    //求出结构体数组的大小
    int size = sizeof(mans) / sizeof(struct Man);

    //遍历结构体数组方法一，通过指针遍历,mams可以表示数组的首地址，也可以是数组变量名
    struct Man *p = mans;
    for (; p &lt; mans + 2;p++){
        printf(&quot;%s,%d\n&quot;,p-&gt;name,p-&gt;age);
    }

    //遍历方式二，一般的数组方式去遍历
    int i = 0;
    for (; i &lt; size;i++){
        printf(&quot;%s,%d\n&quot;, mans[i].name, mans[i].age);
    }

    system(&quot;pause&quot;);
}
</code></pre><p>结构体的大小（字节对齐）</p>
<p>结构体变量的大小，必须是最宽基本数据类型的整数倍，通过空间换取时间来提升读取效率，其意义：提升读取的效率。</p>
<pre><code>struct Man{
    int age;//4字节
    double weight;//8字节    
};

void main(){
    //结构体变量的大小，必须是最宽基本数据类型的整数倍
    //提升读取的效率
    struct Man m1 = {20,89.0};
    printf(&quot;%#x,%d\n&quot;, &amp;m1,sizeof(m1));//大小应该是16字节
    getchar();
}
</code></pre><p>结构体与动态内存分配</p>
<pre><code>struct Man{
    char *name;
    int age;
};

void main(){
    //动态分配10个Man结构体的内存空间
    struct Man *m_p=(struct Man*)malloc(sizeof(struct Man)*10);
    struct Man *p = m_p;
    //赋值
    p-&gt;name = &quot;isen&quot;;
    p-&gt;age = 27;
    p++;
    p-&gt;name = &quot;rose&quot;;
    p-&gt;age = 30;

    struct Man *loop_p = m_p;
    for (; loop_p &lt; m_p + 2; loop_p++){
        printf(&quot;%s,%d\n&quot;, loop_p-&gt;name, loop_p-&gt;age);
    }

    free(m_p);
    system(&quot;pause&quot;);
}
</code></pre><p>typedef 表示类型取别名</p>
<pre><code>//typedef 类型取别名
//1.不同名称代表在干不同的事情typedef int jint;  
//2.不同情况下，使用不同的别名
//#if defined(__cplusplus)
//typedef _JNIEnv JNIEnv;
//typedef _JavaVM JavaVM;
//3.书写简洁

struct Man{
    char name[20];
    int age;
};

//Age int类型的别名
typedef int Age;
//Age int类型指针的别名
typedef int* Ap;

typedef struct Man JavaMan;
typedef struct Man* JM;

//结构体取别名
//typedef struct Woman W;
//typedef struct Woman* WP;

//简写
typedef struct Woman{
    char name[20];
    int age;
} W, *WP;  //W 是woman结构体的别名, WP 是woman结构体指针的别名

void main(){
    int i = 5;
    Ap p = &amp;i;

    //结构体变量
    W w1 = {&quot;Rose&quot;,20};
    //结构体指针
    WP wp1 = &amp;w1;
    printf(&quot;%s,%d\n&quot;, w1.name, w1.age);
    printf(&quot;%s,%d\n&quot;, wp1-&gt;name, wp1-&gt;age);

    getchar();
}
</code></pre><p>结构体函数指针成员</p>
<pre><code>struct Girl{
    char *name;
    int age;
    //函数指针
    void(*sayHi)(char*);
};
//Girl结构体类似于Java中的类，name和age类似于属性，sayHi类似于方法

void sayHi(char* text){
    MessageBoxA(0, text, &quot;title&quot;, 0);
}

void main(){
    struct Girl g1;
    g1.name = &quot;Lucy&quot;;
    g1.age = 18;
    g1.sayHi = sayHi;

    g1.sayHi(&quot;hello&quot;);

    getchar();
}
</code></pre><p>举例</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;Windows.h&gt;

//定义一个Girl结构体，包括属性和方法
typedef struct Girl{
    char *name;
    int age;
    //函数指针
    void(*sayHi)(char*);
}Girl;//给结构体取一个别名Girl（别名可以与结构体原本的名字相同）

//Girl结构体指针取别名GirlP
typedef Girl* GirlP;

//结构体的成员函数
void sayHi(char* text){
    MessageBoxA(0, text, &quot;title&quot;, 0);
}

//自定义的一个改名函数
void rename(GirlP gp1){
    gp1-&gt;name = &quot;Lily&quot;;
}

void main(){
    Girl g1 = { &quot;Lucy&quot;, 18, sayHi };
    GirlP gp1 = &amp;g1;
    gp1-&gt;sayHi(&quot;Byebye!&quot;);
    //传递指针，改名（只有传递指针才能修改值，所以指针是比较常用的方式）
    rename(gp1);

    getchar();
}
</code></pre><p>完！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/C语言学习系列-二-字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/C语言学习系列-二-字符串/" itemprop="url">
                  C语言学习系列(二)字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-24T15:33:26+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="c语言字符串的实现方式："><a href="#c语言字符串的实现方式：" class="headerlink" title="c语言字符串的实现方式："></a>c语言字符串的实现方式：</h1><p>1.字符数组实现：可修改某一个数组元素的值，不可整体赋值，如果需要，需要用strcpy方法实现整体赋值。</p>
<p>2.字符指针实现：不可修改某一个数组元素的值，可整体赋值，运用指针运算，可以截取字符串。</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


//使用字符数组存储字符串
void main(){
    //使用字符数组定义字符串，内存连续，可以修改（相当于Java中的StringBuilder、Buffer）
    //char str[] = {&apos;1&apos;,&apos;4&apos;,&apos;4&apos;,&apos;6&apos;,&apos;9&apos;,&apos;\0&apos;};//可以不指定长度，但是需要有结束符，否则会出现乱码
    //char str[6] = { &apos;1&apos;, &apos;4&apos;, &apos;4&apos;, &apos;6&apos;, &apos;9&apos;};//指定字符数组长度，指定的数组长度需大于数组长度，否则会出现乱码
    char str[] = &quot;china&quot;;//直接用双引号
    //使用上面的方式定义字符数组，可以修改其中某一个字符
    str[0] = &apos;f&apos;;

    //字符数组不能整体赋值，只能在声明的时候整体赋值，优点是可以局部修改某一个字符。如需要重新整体赋值的话，需要使用strcpy函数
    //str = &quot;abcde&quot;;
    char *a = &quot;10086&quot;;
    strcpy(str,a);

    printf(&quot;%s\n&quot;,str);
    printf(&quot;%#x\n&quot;,&amp;str);
    system(&quot;pause&quot;);
}


/*
//字符指针,不能修改某一个字符串（相当于Java中String）
void main(){
    char *str = &quot;how are you!&quot;;

    //不可以修改某一个字符，否则会提示访问冲突
    //str += 3;
    //*str = &apos;p&apos;;

    //但是可以整体赋值
    char p[] = &quot;www.chengweiblog.com&quot;;
    str = &amp;p;

    //使用指针加法截取字符串
    str += 3;
    while (*str)
    {
        printf(&quot;%c&quot;,*str);
        str++;
    }

    //printf(&quot;%s\n&quot;, str);
    //printf(&quot;%#x\n&quot;, str);
    system(&quot;pause&quot;);
}
*/

//字符串常用的方法
//在线手册：http://www.kuqin.com/clib/
//strcat字符串拼接函数
/*
void main(void){
char dest[50];
char *a = &quot;china&quot;;
char *b = &quot; is powerful!&quot;;
strcpy(dest, a);
strcat(dest, b);
printf(&quot;%s\n&quot;, dest);

system(&quot;pause&quot;);
}
*/


//strchr在一个串中查找给定字符的第一个匹配之处
/*
void main(void){
char *str = &quot;I want go to USA!&quot;;
printf(&quot;%#x\n&quot;, str);
//U元素的指针
//str+3
char* p = strchr(str, &apos;w&apos;);
if (p){
printf(&quot;索引位置：%d\n&quot;, p - str);
}
else{
printf(&quot;没有找到&quot;);
}

system(&quot;pause&quot;);
}
*/

//strstr 从字符串haystack中寻找needle第一次出现的位置

void main(void){
    char *haystack = &quot;I want go to USA!&quot;;
    char *needle = &quot;to&quot;;
    //U元素的指针

    char* p = strstr(haystack, needle);
    if (p){
        printf(&quot;索引位置：%d\n&quot;, p - haystack);
    }
    else{
        printf(&quot;没有找到&quot;);
    }

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/17/自定义view基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/自定义view基础知识/" itemprop="url">
                  自定义view基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T16:32:11+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于自定义组件有三种定义方式：</p>
<ol>
<li>完全自己自定义去写，组件类继承View;</li>
<li>从已经有的组件扩展；</li>
<li>将多个组件组合成一个组件；</li>
</ol>
<p>首先看一下继承自View的组件类的实现：</p>
<pre><code>public class MyView extends View{

    public MyView(Context context) {
        super(context);
    }

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }

}
</code></pre><p>需要重写两个方法和三个构造方法，对于三个构造方法的调用场景是不一样的，第一个只有一个参数，在代码中创建组件时会调用该构造方法，比如创建一个按钮：TextView tv = new TextView(this)，this 是指当前的 Activity，Activity 是 Context 的子类。第二个方法在 layout 布局文件中使用时调用，参数 attrs 表示当前配置中的属性集合，例如在要 layout.xml 中定义一个TextView：<textview android:layout_width="match_parent" android:layout_height="wrap_co-ntent" android:text="hello">，Android 会调用第二个构造方法 Inflate 出 TextView 对象。而第三个构造方法是不会自动调用的，当我们在 Theme 中定义了 Style 属性时通常在第二个构造方法中手动调用。</textview></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/c语言学习系列-一-基本数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/14/c语言学习系列-一-基本数据类型/" itemprop="url">
                  c语言学习系列(一)基本数据类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-14T11:18:29+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在学习c语言 ， 所以就跟着动脑学院的视频课程来进行一个简单的学习 ， 下面贴出自己在视频中学习的代码用于记录学习的过程 ：</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS //宏定义
//引入头文件，相当于Java的导包
//只有函数的声明，编译时会去找到函数的实现
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;Windows.h&gt;


/*
void main(){
    printf(&quot;hello world\n&quot;);    
    system(&quot;pause&quot;);
}
*/
//1.基本数据类型
//int short long float double char
/*
占位符
int %d
short %d
long %ld
float %f
double %lf
char %c
%x 十六进制
%o 八进制
%s 字符串
*/
/*
void main(){
    int i = 1;
    printf(&quot;%d\n&quot;,i);

    float f = 23.3;
    printf(&quot;%f\n&quot;,f);

    //基本数据类型所占的字节数
    printf(&quot;int占%d字节\n&quot;,sizeof(int));
    printf(&quot;char占%d字节\n&quot;, sizeof(char));
    printf(&quot;float占%d字节\n&quot;, sizeof(float));

    //循环(以下为标准格式，否则在不同的开发平台有的编译不通过，例如在window下可以编译通过在linux下就可能编译不通过)
    int n = 0;
    for (; n &lt; 10; n++){
        printf(&quot;%d\n&quot;,n);
    }

    //等待输入
    system(&quot;pause&quot;);
}
*/

//2.输入输出函数
/*
void main(){
    int i;
    printf(&quot;请输入一个整数：&quot;);
    //赋值
    scanf(&quot;%d&quot;,&amp;i);  //控制台输入，&amp;表示取地址符
    //打印
    printf(&quot;i的值为：%d\n&quot;,i);

    system(&quot;pause&quot;);
}
*/

//指针
//指针存储的是变量的内存地址
//内存地址：系统给数据分配的编号（相当于门牌号）
/*void main(){
    int i = 90;
    //指针变量，创建一个int类型的指针(可以写成int* p,也可以写成int *p)，指针的值只能是变量的内存地址
    int* p = &amp;i; //p的值就是i这个变量的内存地址
    printf(&quot;%#x\n&quot;,p);

    float f = 89.5f;
    //创建一个float类型的指针
    float *fp = &amp;f;
    printf(&quot;%#x\n&quot;, fp);

    system(&quot;pause&quot;);
}*/

/*
void change(int* p){
    *p = 300;
}

//变量名，对内存空间上的一段数据的抽象
void main(){
    int i = 90;
    //i = 89;
    //创建一个int类型的指针
    int *p = &amp;i;
    //输出地址
    printf(&quot;p的地址：%#x\n&quot;,&amp;p);
    printf(&quot;i的地址：%#x\n&quot;,&amp;i);

    printf(&quot;i的值为：%d\n&quot;, i);
    //间接赋值 i = 200;

    //对p存的地址指向的变量进行操作
    //*p = 200;
    //change(p);
    change(&amp;i);  // int *p = &amp;i;
    printf(&quot;i的值为：%d\n&quot;,i);

    system(&quot;pause&quot;);
}
*/

void main(){
    int time = 600;
    printf(&quot;time:%#x\n&quot;,&amp;time);
    while (time &gt; 0){
        time--;
        printf(&quot;游戏时间剩余%d秒\n&quot;,time);
        //睡眠
        Sleep(1000);
    }
    system(&quot;pause&quot;);
}
</code></pre><p>##关于c中数组的定义</p>
<p>c中定义数组，例如：int ids[] = { 78, 90, 23, 65, 19 };</p>
<p>java中定义数组有两种方式：int ids[] = { 78, 90, 23, 65, 19 }，或者int[] ids = { 78, 90, 23, 65, 19 };</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;Windows.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;

//1.指针为什么要有类型？
//指针有类型，地址没有类型
//地址只是开始的位置，类型表示读取到什么位置结束
/*
void main(){
    int i = 89;
    //int 类型的指针
    int *p = &amp;i;
    double j = 78.9;
    //赋值为double类型变量的地址
    p = &amp;j;
    printf(&quot;double size:%d\n&quot;, sizeof(double));
    printf(&quot;%#x,%lf\n&quot;,p,*p); //想通过4字节读取8字节变量的值，是不行的    

    getchar();
}
*/

//2.NULL空指针
/*
void main(){
    int i = 9;
    int *p = NULL;
    //p = &amp;i;

    //空指针的默认值为0
    printf(&quot;%#x\n&quot;,p);
    //访问内存地址0x000000操作系统不允许
    //p = 100; //操作系统不允许访问
    printf(&quot;%d\n&quot;,*p);
    getchar();
}
*/

//3.多级指针（二级指针）
//指针保存的是变量的地址，保存的这个变量还可以是一个指针变量
//动态内存分配给二维数组
/*
void main(){
    int a = 50;
    //p1上保存的a的地址
    int* p1 = &amp;a;

    //p2上保存的p1的地址
    int** p2 = &amp;p1;

    //int*** p3 = &amp;p2;

    printf(&quot;p1:%#x,p2:%#x\n&quot;,p1,p2);
    **p2 = 90;

    printf(&quot;%d\n&quot;,a);

    getchar();
}
*/

//4.指针的运算
//指针的运算，一般在数组遍历时才有意义，基于数组在内存中线性排列的方式
/*
void main(){
    //数组在内存中连续存储
    int ids[] = { 78, 90, 23, 65, 19 };
    //数组变量名：ids就是数组的首地址，下面三个输出结果是一样的
    printf(&quot;%#x\n&quot;,ids);
    printf(&quot;%#x\n&quot;,&amp;ids);
    printf(&quot;%#x\n&quot;,&amp;ids[0]);
    //指针变量
    int *p = ids;
    printf(&quot;%d\n&quot;,*p);
    //指针的加法
    p++; //p++向前移动sizeof(数据类型)个字节
    printf(&quot;p的值:%#x\n&quot;, p);
    //p--;
    printf(&quot;%d\n&quot;, *p);
    getchar();
}
*/
//5.通过指针给数组赋值
/*
void main(){
    int uids[5];
    //高级写法
    //int i = 0;
    //for (; i &lt; 5; i++){
    //    uids[i] = i;
    //}
    //早些版本的写法
    int* p = uids;
    printf(&quot;%#x\n&quot;,p);
    int i = 0; //i是数组元素的值
    for (; p &lt; uids + 5; p++){
        *p = i;
        i++;
    }

    getchar();
}
*/
</code></pre><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>关于动态内存分配的函数介绍：</p>
<p>Malloc()函数是在内存的动态存储区中分配一个长度为size字节的连续空间。其参数是一个无符号整型数，返回一个指向所分配的连续存储域的起始地址的指针。当函数未能成功分配存储空间时（如内存不足）则返回一个NULL指针。</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;Windows.h&gt;

//动态内存分配
/*
void main(){
    //40M
    //stack overflow错误，栈溢出
    //静态内存分配
    int a[1024 * 1024 * 10];
    //栈内存

    //C语言内存分配：
    //1.栈区(stack)
    //windows下，栈内存分配2M（确定的常数），超出了限制，提示stack overflow错误
    //栈内存自动分配，自动释放
    //2.堆区(heap)
    //程序员手动分配释放，占有操作系统80%内存
    //3.全局区或静态区
    //4.字符常量区
    //5.程序代码区

    getchar();
}
*/

/*
//栈内存
void stackFun(){
    int a[1024];
    //栈内存自动释放
}

//堆内存
void heapFun(){
    //40M内存
    //字节
    //void *任意类型的指针
    int* p = malloc(1024 * 1024 * 10 * sizeof(int));

    //释放
    free(p);
}

void main(){    
    //在堆内存上，分配40M的内存
    while (1){
        Sleep(1000);    
        stackFun();
    }

    getchar();
}
*/

//创建一个数组，动态指定数组的大小
//（在程序运行过程中，可以随意的开辟指定大小的内存，以供使用，相当于Java中的集合）
//静态内存分配，分配内存的大小是事先固定好的，因此容易造成两个问题：1.很容易超出栈内存的最大值 2.为了防止内存不够用会开辟更多的内存，容易浪费内存
//动态内存分配，在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用（活水）
/*
void main(){
    //静态内存分配创建数组，数组的大小是固定的
    //int i = 10;
    //int a[i];

    //动态内存分配，自己手动输入内存大小
    int len;
    printf(&quot;输入数组的长度：&quot;);
    scanf(&quot;%d&quot;,&amp;len);

    //开辟内存，大小len*4字节
    int* p = malloc(len * sizeof(int));
    //p是数组的首地址，p就是数组的名称
    //给数组元素赋值（使用这一块刚刚开辟出来的内存区域）
    int i = 0;
    for (; i &lt; len - 1; i++){
        p[i] = rand() % 100;
        printf(&quot;%d,%#x\n&quot;, p[i], &amp;p[i]);
    }

    //手动释放内存
    free(p);

    getchar();
}
*/

//realloc 重新分配内存
/*
void main(){
    int len;
    printf(&quot;第一次输入数组的长度：&quot;);
    scanf(&quot;%d&quot;, &amp;len);

    //malloc与calloc都可以开辟内存
    //int* p = malloc(len * sizeof(int));    
    int* p = calloc(len, sizeof(int));
    int i = 0;
    for (; i &lt; len; i++){
        p[i] = rand() % 100;
        printf(&quot;%d,%#x\n&quot;, p[i], &amp;p[i]);
    }

    int addLen;
    printf(&quot;输入数组增加的长度：&quot;);
    scanf(&quot;%d&quot;, &amp;addLen);
    //realloc（扩大或缩小内存）内存不够用，扩大刚刚分配的内存空间，需要传递下面两个参数
    //1.原来内存的指针 2.内存扩大之后的总大小        
    int* p2 = realloc(p, sizeof(int) * (len + addLen));
    if (p2 == NULL){
        printf(&quot;重新分配失败，世界那么大，容不下我。。。&quot;);
    }
    //重新分配内存的两种情况：
    //缩小，缩小的那一部分数据会丢失
    //扩大（扩大后的内存必须是连续的），有下面三种情况：
    //1.如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针（相同的内存地址）
    //2.如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存地址
    //3.如果申请失败，返回NULL，原来的指针仍然有效

    //重新赋值
    i = 0;
    printf(&quot;--------------------------\n&quot;);
    for (; i &lt; len + addLen; i++){
        p2[i] = rand() % 200;
        printf(&quot;%d,%#x\n&quot;, p2[i], &amp;p2[i]);
    }

    //手动释放内存
    if (p != NULL){
        free(p);
        p = NULL;
    }    
    if (p2 != NULL){
        free(p2);
        p2 = NULL;
    }

    getchar();
}
*/

//内存分配的几个注意细节
//1.不能多次释放（否则会产生中断）
//2.释放完之后（指针仍然有值），给指针置NULL，标志释放完成
//3.内存泄露（p重新赋值之后，再free，并没有真正释放内存（之前的内存））
/*
void main(){
    int len;
    printf(&quot;输入数组的长度：&quot;);
    scanf(&quot;%d&quot;, &amp;len);

    int* p = malloc(len * sizeof(int));        
    int i = 0;
    for (; i &lt; len; i++){
        p[i] = rand() % 100;
        printf(&quot;%d,%#x\n&quot;, p[i], &amp;p[i]);
    }

    if (p != NULL){
        free(p);
        p = NULL;
    }

    getchar();
}
*/

//内存泄漏的例子,p1重新赋值之后，再free，并没有真正释放内存，容易造成内存泄漏，所以在重新赋值之前要先free，如下：
void main(){
    //40M
    int* p1 = malloc(1024 * 1024 * 10 * sizeof(int));
    free(p1);
    p1 = NULL;
    printf(&quot;%#x\n&quot;,p1);

    //80M
    p1 = malloc(1024 * 1024 * 10 * sizeof(int) * 2);

    free(p1);
    p1 = NULL;

    getchar();
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/记一次Java关于金额计算的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/11/记一次Java关于金额计算的问题/" itemprop="url">
                  记一次Java关于金额计算的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T10:05:15+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在做一个关于理财的app ， 里面需要涉及到金额的计算 ，对于金额的存储用到什么数据类型 ， 我首先想到的是double双精度类型 ， 其实则不然 ， 在计算中我发现有的计算结果并不是我想要的 。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code>public class Test1 {
    public static void main(String[] args) {
        double a = 0.03;
        double b = 0.02;
        double result = a-b;
        System.out.println(result);
    }
}
</code></pre><p>结果：0.009999999999999998</p>
<p>为什么会这样呢？</p>
<p>因为float和double都是浮点数 ， 都有取值范围 ， 都有精度范围 ， 与小数不同 ， 使用中难以确定 ， 一次经过一系列的运算后得到的往往并不是我们想要的结果 。</p>
<p>怎么解决？</p>
<p>我们需要用到一个BigDecimal类 ， 需要把我们计算的类型转成BigDecimal来进行运算 。</p>
<pre><code>public class Test1 {
    public static void main(String[] args) {
        BigDecimal bd1 = new BigDecimal(&quot;0.03&quot;);
        BigDecimal bd2 = new BigDecimal(&quot;0.02&quot;);
        System.out.println(bd1.subtract(bd2));
    }
}
</code></pre><p>这样就可以得到我们想要的结果：0.01</p>
<h2 id="关于BigDecimal的一些运算"><a href="#关于BigDecimal的一些运算" class="headerlink" title="关于BigDecimal的一些运算"></a>关于BigDecimal的一些运算</h2><p>两个BigDecimal值的加减乘除并不是我们数学上的+、-、*、/ 。 我们通过下面的代码来看一下：</p>
<pre><code>public static void main(String[] args) {
        BigDecimal bd1 = new BigDecimal(&quot;0.03&quot;);
        BigDecimal bd2 = new BigDecimal(&quot;0.02&quot;);
        //加法 0.05
        System.out.println(bd1.add(bd2));
        //减法 0.01
        System.out.println(bd1.subtract(bd2));
        //乘法  0.0006
        System.out.println(bd1.multiply(bd2));
        //除法 1.5
        System.out.println(bd1.divide(bd2));
    }
</code></pre><p>还有一些关于大小的比较和四舍五入的运算就不在这里写啦 。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/08/Activity的组成结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/Activity的组成结构/" itemprop="url">
                  Activity的组成结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T09:33:52+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> <strong>Activity</strong>代表一个窗口，事实上，这里的“窗口”是由Activity的成员变量mWindow来表示的，mWindow本质上是一个PhoneWindow对象，PhoneWindow继承自Window抽象类，负责窗口的管理。但是，PhoneWindow并不用来呈现界面效果，呈现界面由PhoneWindow管理的DecorView对象来完成，DecorView类是FrameLayout的子类，也是整个View树的“根”。DecorView包含三部分内容：通知栏，标题栏，内容显示栏。从源码的 screen_title.xml（该布局文件是常见的窗口风格定义文件）的布局文件中来看一下：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:fitsSystemWindows=&quot;true&quot;&gt;
    &lt;!-- Popout bar for action modes --&gt;
    &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;
              android:inflatedId=&quot;@+id/action_mode_bar&quot;
              android:layout=&quot;@layout/action_mode_bar&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;wrap_content&quot;
              android:theme=&quot;?attr/actionBarTheme&quot; /&gt;
    &lt;FrameLayout
        android:layout_width=&quot;match_parent&quot; 
        android:layout_height=&quot;?android:attr/windowTitleSize&quot;
        style=&quot;?android:attr/windowTitleBackgroundStyle&quot;&gt;
        &lt;TextView android:id=&quot;@android:id/title&quot; 
            style=&quot;?android:attr/windowTitleStyle&quot;
            android:background=&quot;@null&quot;
            android:fadingEdge=&quot;horizontal&quot;
            android:gravity=&quot;center_vertical&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;
    &lt;/FrameLayout&gt;
    &lt;FrameLayout android:id=&quot;@android:id/content&quot;
        android:layout_width=&quot;match_parent&quot; 
        android:layout_height=&quot;0dip&quot;
        android:layout_weight=&quot;1&quot;
        android:foregroundGravity=&quot;fill_horizontal|top&quot;
        android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>从代码中可以看出 ， ActionBar 由 ViewStub 标签定义 ， 内容区包含了两个 FrameLayout 标签，分别代表标题栏和正文区 ， id为@android:id/content的FrameLayout被inflate成名为mContentParent的 FrameLayout 对象 ， 在 Activity 的 onCreate()方法中调用 setContentView()方法加载的布局内容终将成为 mContentParent 的子 View。</p>
<p>需要说明的是 ， PhoneWindow 类还关联了一个名为 mWindowManager 的 WindowManager对象 ，WindowManager 会创建一个 ViewRootImpl 对象来和 WindowManagerService 进行沟通 ， WindowManagerService 能获取触摸事件 、 键盘事件或轨迹球事件 ， 并通过 ViewRootImpl 将事件分发给各个 Actitivty；另外，ViewRootImpl 还负责 Activity 整个 GUI 的绘制 。 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Feng" />
          <p class="site-author-name" itemprop="name">Feng</p>
           
              <p class="site-description motion-element" itemprop="description">每天一小步，人生一大步</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
