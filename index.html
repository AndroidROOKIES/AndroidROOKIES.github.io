<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="每天一小步，人生一大步">
<meta property="og:type" content="website">
<meta property="og:title" content="Feng's Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Feng's Notes">
<meta property="og:description" content="每天一小步，人生一大步">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feng's Notes">
<meta name="twitter:description" content="每天一小步，人生一大步">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Feng's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Feng's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/FFmpeg学习系列-一-Linux下编译FFmpeg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/21/FFmpeg学习系列-一-Linux下编译FFmpeg/" itemprop="url">
                  FFmpeg学习系列(一)Linux下编译FFmpeg
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T14:48:55+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在android中进行FFmpeg开发时，我们需要用到编译好的.so库，这些.so需要在Linux环境下进行编译。</p>
<h2 id="Linux下编译FFmpeg步骤"><a href="#Linux下编译FFmpeg步骤" class="headerlink" title="Linux下编译FFmpeg步骤"></a>Linux下编译FFmpeg步骤</h2><p><strong>1.如果不是Linux操作系统，需要购买阿里云主机，镜像可以选择ubuntu 14.04 64位。</strong></p>
<p><strong>2.安装XShell（内含Xftp）、Xftp来对服务器进行操作、文件传输</strong></p>
<p>需要配置Xshell来连接阿里云服务器：</p>
<p>点击XShell客户端 文件-&gt;打开，弹出会话对话框，点击 “新建”，在对话框中填写“名称”（可随便起一个），主机处填写公网地址点击确认进行连接，然后填写用户，密码。</p>
<p>连接成功之后，点击Xshell客户端的“新建文件传输”，弹出Xftp,一般在usr下新建一个ndk文件，把我们的ndk拖入ndk文件中。</p>
<p><strong>3.安装VIM</strong>  sudo apt-get install vim-gtk</p>
<p>安装后如果输入vim不能使用,提示No such file or directory, 更新一下apt-get update</p>
<p>3.1通过vim编辑一个文本：</p>
<pre><code>vim isen.txt 进入命令模式。
</code></pre><p>在命令模式退出：</p>
<pre><code>按shift + :，输入q!强制退出（不保存退出）

保存退出,shift + z z
</code></pre><p>命令模式进入编辑模式：</p>
<pre><code>按i键
</code></pre><p>编辑模式退出进入命令模式：</p>
<pre><code>按Esc键
</code></pre><p>在命令模式中：</p>
<pre><code>x删除，dd删除行
</code></pre><p><strong>4.vim配置(高亮显示，行号之类的)</strong></p>
<p>一般vim正常安装在/etc/vim/中。</p>
<pre><code>通过vim打开vimrc

vim /etc/vim/vimrc

在末尾添加如下命令
set nu
set tabstop
set cursorline
set ruler
</code></pre><p><strong>5.NDK安装</strong></p>
<p>cd进入ndk目录中，输入ls命令</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/linux_ndk.png" alt=""></p>
<p>发现ndk字体是白色的，表示没有权限不可执行，绿色表示可执行，我们需要给权限让其可执行</p>
<pre><code>目录给权限：chmod 777 -R ndk
其中-R代表ndk是一个目录
</code></pre><p><img src="http://oph0qv0je.bkt.clouddn.com/linux_ndk2.png" alt=""></p>
<p>ndk目录为绿色可执行。</p>
<pre><code>解压ndk：./android-ndk-r10e-linux-x86_64.bin 
</code></pre><p>环境变量配置：</p>
<pre><code>命令vim ~/.bashrc
添加：
export NDKROOT=/usr/ndk/android-ndk-r10e
export PATH=$NDKROOT:$PATH
</code></pre><p>更新环境变量：</p>
<pre><code>source ~/.bashrc
</code></pre><p><strong>6.准备FFmpeg</strong></p>
<p>我们需要去FFmpeg官网下载FFmpeg的Linux源码，版本不需要太新：</p>
<pre><code>ffmpeg-2.6.9.zip
</code></pre><p>然后执行解压缩命令：</p>
<pre><code>unzip ffmpeg-2.6.9.zip
</code></pre><p><strong>7.编译FFmpeg</strong></p>
<p>我们需要编写shell脚本传参调用ffmpeg-2.6.9下的configure脚本进行编译。</p>
<p>1）编写shell脚本文件build_android.sh：</p>
<pre><code>#!/bin/bash
make clean
export NDK=/usr/ndk/android-ndk-r10e
export SYSROOT=$NDK/platforms/android-9/arch-arm/
export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64
export CPU=arm
export PREFIX=$(pwd)/android/$CPU
export ADDI_CFLAGS=&quot;-marm&quot;

./configure --target-os=linux \
--prefix=$PREFIX --arch=arm \
--disable-doc \
--enable-shared \
--disable-static \
--disable-yasm \
--disable-symver \
--enable-gpl \
--disable-ffmpeg \
--disable-ffplay \
--disable-ffprobe \
--disable-ffserver \
--disable-doc \
--disable-symver \
--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \
--enable-cross-compile \
--sysroot=$SYSROOT \
--extra-cflags=&quot;-Os -fpic $ADDI_CFLAGS&quot; \
--extra-ldflags=&quot;$ADDI_LDFLAGS&quot; \
$ADDITIONAL_CONFIGURE_FLAG
make clean
make
make install
</code></pre><p>shell脚本中指定NDK的一些路径（export NDK=/usr/ndk/android-ndk-r10e），配置CPU架构类型（export CPU=arm），PREFIX是指定动态库输出的路径，然后disable一些不需要的库（可减小输出的动态库的大小）等等。enable-shared是生成共享库的意思。</p>
<p>关于shell脚本需要注意：</p>
<ol>
<li><p>换行的时候需要有\，注意不要有额外的空格，否则编译出错</p>
</li>
<li><p>脚本文件统一转为UTF-8无BOM格式。可以通过note pad++进行转码，这样子Windows和Linux都通用了。也可以通过dos2unix命令进行转码后在Linux中使用。或者先由Linux创建文件再由Windows编辑。</p>
</li>
<li><p>NDK尽量不要使用太新的版本，一般使用Android-9即可。新版本会出现不兼容的问题，比如LOG2的问题等等。</p>
</li>
</ol>
<p>2）将编写好的shell脚本放在解压后的ffmpeg-2.6.9文件夹中。</p>
<pre><code>然后ffmpeg-2.6.9文件给权限
chmod 777 -R ffmpeg-2.6.9
</code></pre><p>3) cd进入ffmpeg-2.6.9文件夹中</p>
<pre><code>执行 ./android_build.sh
</code></pre><p>如果出现问题bad interpreter : No such file or directory,需要将文件转成Linux编码格式<br>有两种方式：</p>
<pre><code>1，在Linux下创建这个文件touch android_build.sh，从Linux传出到桌面把脚本命令拷入这个文件中，在上传上Linux中去给权限就可以啦

2，使用 dos2unix android_build.sh 转成Linux编码格式
</code></pre><p><strong>8.编译完成之后生成如下动态库：</strong></p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ffmpeg_so.png" alt=""></p>
<p>我们可以看到生成的有.56,.5之类的库，对于这种库android很难加载到，因此要把这个名字加载到前面，以.so结尾，因此，我们需要修改configure文件。</p>
<p><strong>9.修改configure文件</strong></p>
<p>ffmpeg-2.6.9根目录下有个configure文件，这个文件比较重要。我们自己写的脚本文件就是依据这个文件来写的。</p>
<p>这里我们需要修改一下输出的动态库的命名规则：</p>
<pre><code>#修改前
#SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;
#LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;
#SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;
#SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;
#修改后
SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;
LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;
SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;
SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;
</code></pre><p>然后进行重新编译，生成动态库如下：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ffmpeg_so2.png" alt=""></p>
<p>我们就可以在我们的android项目中应用这些库啦。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/18/C++学习系列-六-IO与STL标准模板库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/18/C++学习系列-六-IO与STL标准模板库/" itemprop="url">
                  C++学习系列(六)IO与STL标准模板库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-18T11:50:11+08:00">
                2017-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-的IO操作"><a href="#C-的IO操作" class="headerlink" title="C++的IO操作"></a>C++的IO操作</h2><p>文本文件操作</p>
<pre><code>void main(){
    char* fname = &quot;c://dest.txt&quot;;
    //输出流
    ofstream fout(fname);
    //创建失败
    if (fout.bad()){ //文件打开失败
        return;
    }

    fout &lt;&lt; &quot;jack&quot; &lt;&lt; endl;
    fout &lt;&lt; &quot;rose&quot; &lt;&lt; endl;

    //关闭
    fout.close();

    //读取
    ifstream fin(fname);
    if (fin.bad()){
        return;
    }
    char ch;
    while (fin.get(ch)){
        //输出
        cout &lt;&lt; ch;
    }
    fin.close();

    system(&quot;pause&quot;);
}
</code></pre><p>二进制文件操作</p>
<pre><code>void main(){
    char* src = &quot;c://src.jpg&quot;;
    char* dest = &quot;c://dest.jpg&quot;;

    //输入流
    ifstream fin(src, ios::binary);
    //输出流
    ofstream fout(dest, ios::binary);

    if (fin.bad() || fout.bad()){
        return;
    }

    while (!fin.eof()){
        //读取
        char buff[1024] = {0};
        fin.read(buff,1024);

        //写入
        fout.write(buff,1024);
    }

    //关闭
    fin.close();
    fout.close();

    system(&quot;pause&quot;);
}
</code></pre><p>C++对象的持久化</p>
<pre><code>class Person
{
public:
    Person()
    {

    }
    Person(char * name, int age)
    {
        this-&gt;name = name;
        this-&gt;age = age;
    }
    void print()
    {
        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;
    }
private:
    char * name;
    int age;
};


void main()
{
    Person p1(&quot;柳岩&quot;, 22);
    Person p2(&quot;rose&quot;, 18);
    //输出流
    ofstream fout(&quot;c://c_obj.data&quot;, ios::binary);
    fout.write((char*)(&amp;p1), sizeof(Person)); //指针能够读取到正确的数据，读取内存区的长度
    fout.write((char*)(&amp;p2), sizeof(Person));
    fout.close();

    //输入流
    ifstream fin(&quot;c://c_obj.data&quot;, ios::binary);
    Person tmp;
    fin.read((char*)(&amp;tmp), sizeof(Person));
    tmp.print();

    fin.read((char*)(&amp;tmp), sizeof(Person));
    tmp.print();

    system(&quot;pause&quot;);

}
</code></pre><h2 id="C-中STL"><a href="#C-中STL" class="headerlink" title="C++中STL"></a>C++中STL</h2><p>STL:standard template library 标准模板库，类似于Java中的util工具集等。</p>
<pre><code>#include &lt;string&gt;
void main()
{
    string s1 = &quot;craig david&quot;;
    string s2(&quot; 7 days&quot;);
    string s3 = s1 + s2;

    cout &lt;&lt; s3 &lt;&lt; endl;

    //转c字符串
    const char* c_str = s3.c_str();
    cout &lt;&lt; c_str &lt;&lt; endl;

    //s1.at(2);


    system(&quot;pause&quot;);
}
</code></pre><p>这里的是c++中的string，在jni开发时，需要先将c++中的string转为c的string，再转换成Java的string。</p>
<pre><code>//容器
#include &lt;vector&gt;

void main()
{
    //动态数组
    //不需要使用动态内存分配，就可以使用动态数组
    vector&lt;int&gt; v;
    v.push_back(12);
    v.push_back(10);
    v.push_back(5);

    for (int i = 0; i &lt; v.size(); i++)
    {
        cout &lt;&lt; v[i] &lt;&lt; endl;
    }

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/11/C++学习系列-五-C++中的类型转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/11/C++学习系列-五-C++中的类型转换/" itemprop="url">
                  C++学习系列(五)C++中的类型转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-11T09:11:34+08:00">
                2017-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h2><p>类型转换分类：</p>
<ol>
<li>static_cast 普遍情况（一般的数据类型转换等）。</li>
<li>const_cast 去常量。</li>
<li>dynamic_cast 子类类型转为父类类型。</li>
<li>reinterpret_cast 函数指针转型，不具备移植性。</li>
</ol>
<p>对于原始类型转换来说，所有情况都是一种写法，可读性不高，有可能有潜在的风险。</p>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>一般用于类型转换：</p>
<pre><code>//void*表示这个函数有可能返回不同类型的指针
void* func(int type){    
    switch (type){
    case 1:    {
                int i = 9;
                return &amp;i;
    }
    case 2:    {
                int a = &apos;X&apos;;
                return &amp;a;
    }
    default:{
                return NULL;
    }

    }    
}

void func2(char* c_p){
    cout &lt;&lt; *c_p &lt;&lt; endl;
}    

void main(){    
    //int i = 0;
    //自动转换
    //double d = i;
    //double d = 9.5;
    //int i = d;

    //int i = 8;
    //double d = 9.5;
    //i = static_cast&lt;int&gt;(d);

    //void* -&gt; char*
    //char* c_p = (char*)func(2);
    //char* c_p = static_cast&lt;char*&gt;(func(2));

    //C++ 意图明显
    func2(static_cast&lt;char*&gt;(func(2)));
    //C
    func2((char*)(func(2)));

    system(&quot;pause&quot;);
}
</code></pre><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>去除常量：</p>
<pre><code>void func(const char c[]){
    //c[1] = &apos;a&apos;;
    //通过指针间接赋值
    //其他人并不知道，这次转型是为了去常量
    //char* c_p = (char*)c;
    //c_p[1] = &apos;X&apos;;
    //提高了可读性
    char* c_p = const_cast&lt;char*&gt;(c);
    c_p[1] = &apos;Y&apos;;

    cout &lt;&lt; c &lt;&lt; endl;
}

void main(){
    char c[] = &quot;hello&quot;;
    func(c);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>用于继承关系中，父类、子类的转换：</p>
<pre><code>class Person{
public:
    virtual void print(){
        cout &lt;&lt; &quot;人&quot; &lt;&lt; endl;
    }
};

class Man : public Person{
public:
    void print(){
        cout &lt;&lt; &quot;男人&quot; &lt;&lt; endl;
    }

    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
};


class Woman : public Person{
public:
    void print(){
        cout &lt;&lt; &quot;女人&quot; &lt;&lt; endl;
    }

    void carebaby(){
        cout &lt;&lt; &quot;生孩子&quot; &lt;&lt; endl;
    }
};

void func(Person* obj){    

    //调用子类的特有的函数，转为实际类型
    //c的写法
    //并不知道转型失败
    //Man* m = (Man*)obj;
    //m-&gt;print();

    //C++的写法
    //转型失败，返回NULL
    Man* m = dynamic_cast&lt;Man*&gt;(obj);    
    if (m != NULL){
        m-&gt;chasing();
    }

    Woman* w = dynamic_cast&lt;Woman*&gt;(obj);
    if (w != NULL){
        w-&gt;carebaby();
    }
}

void main(){

    //Woman w1;
    //Person *p1 = &amp;w1;

    //func(p1);

    Woman w1;
    Woman* w_p = &amp;w1;


    system(&quot;pause&quot;);
}
</code></pre><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>函数指针的转换，不经常使用：</p>
<pre><code>void func1(){
    cout &lt;&lt; &quot;func1&quot; &lt;&lt; endl;
}

char* func2(){
    cout &lt;&lt; &quot;func2&quot; &lt;&lt; endl;
    return &quot;abc&quot;;
}

typedef void(*f_p)();

void main(){
    //函数指针数组
    f_p f_array[6];
    //赋值
    f_array[0] = func1;

    //C方式
    //f_array[1] = (f_p)(func2);
    //C++方式
    f_array[1] = reinterpret_cast&lt;f_p&gt;(func2);

    f_array[1]();

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/09/C++学习系列-四-C++中的异常处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/09/C++学习系列-四-C++中的异常处理/" itemprop="url">
                  C++学习系列(四)C++中的异常处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-09T10:09:55+08:00">
                2017-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++异常处理，根据抛出的异常数据类型，进入到相应的catch块中。</p>
<pre><code>void main(){
    try{
        int age = 300;
        if (age &gt; 200){
            throw 9.8;
        }
    }
    catch (int a){
        cout &lt;&lt; &quot;int异常&quot; &lt;&lt; endl;
    }
    catch (char* b){
        cout &lt;&lt; b &lt;&lt; endl;
    }
    catch (...){// ...表示任意类型
        cout &lt;&lt; &quot;未知异常&quot; &lt;&lt; endl;
    }
    system(&quot;pause&quot;);
}
</code></pre><p>根据throw抛出不同类型的异常，就会在相应的catch块里面捕获到，其中…代表任意类型。一旦有catch块捕获，后面的catch就不会执行。</p>
<p><strong>throw 抛出函数外</strong></p>
<pre><code>void mydiv(int a, int b){
    if (b == 0){
        throw &quot;除数为零&quot;;
    }
}

void func(){
    try{
        mydiv(8, 0);
    }
    catch (char* a){
        throw a;
    }
}

void main(){
    try{
        func();
    }
    catch (char* a){
        cout &lt;&lt; a &lt;&lt; endl;
    }
    system(&quot;pause&quot;);
}
</code></pre><p>异常在函数里面抛出的话，可以一层一层往外抛出。</p>
<p><strong>抛出对象</strong></p>
<pre><code>class MyException{

};

void mydiv(int a, int b){
    if (b == 0){
        throw MyException();
        //throw new MyException; //不要抛出异常指针        
    }
}

void main(){
    try{
        mydiv(8,0);
    }
    catch (MyException&amp; e2){
        cout &lt;&lt; &quot;MyException引用&quot; &lt;&lt; endl;
    }
    //会产生对象的副本
    //catch (MyException e){
    //    cout &lt;&lt; &quot;MyException&quot; &lt;&lt; endl;
    //}
    catch (MyException* e1){
        cout &lt;&lt; &quot;MyException指针&quot; &lt;&lt; endl;        
        delete e1;
    }

    system(&quot;pause&quot;);
}
</code></pre><p><strong>标准异常（类似于Java NullPointerException）</strong></p>
<pre><code>#include &lt;stdexcept&gt;

class NullPointerException : public exception{
public:
    NullPointerException(char* msg) : exception(msg){

    }
};

void mydiv(int a, int b){
    if (b &gt; 10){
        throw out_of_range(&quot;超出范围&quot;);        
    }    
    else if (b == NULL){
        throw NullPointerException(&quot;为空&quot;);
    }
    else if (b == 0){
        throw invalid_argument(&quot;参数不合法&quot;);
    }
}

void main(){
    try{
        mydiv(8,NULL);
    }
    catch (out_of_range e1){
        cout &lt;&lt; e1.what() &lt;&lt; endl;
    }
    catch (NullPointerException&amp; e2){
        cout &lt;&lt; e2.what() &lt;&lt; endl;
    }
    catch (...){

    }

    system(&quot;pause&quot;);
}
</code></pre><p><strong>外部类异常</strong></p>
<pre><code>class Err{
public:
    class MyException{
        public:MyException(){

        }
    };
};

void mydiv(int a, int b){
    if (b &gt; 10){
        throw Err::MyException();
    }

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/30/C++学习系列-三-继承与多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/30/C++学习系列-三-继承与多态/" itemprop="url">
                  C++学习系列(三)继承与多态
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-30T11:12:10+08:00">
                2017-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++是面向对象的编程语言，因此具有继承和多态的基本特征。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承主要是提高代码的重用性。</p>
<p>举例：</p>
<pre><code>//人类
class Human{
public:
    void say(){
        cout &lt;&lt; &quot;说话&quot; &lt;&lt; endl;
    }
protected:
    char* name;
    int age;
};

//男人
class Man : public Human{
public:
    //泡妞
    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;        
    }
private:
    //兄弟
    char* brother;
};

void work(Human&amp; h){
    h.say();
}

void main(){
    Man m1;
    m1.say();

    //1.父类类型的引用或指针
    Human* h_p = &amp;m1;
    h_p-&gt;say();

    Human &amp;h1 = m1;
    h1.say();

    //子类对象初始化父类类型的对象
    Human h2 = m1;

    system(&quot;pause&quot;);
}
</code></pre><p>上面代码我们可以看出，通过:public来继承Human。</p>
<h3 id="向父类构造方法传参"><a href="#向父类构造方法传参" class="headerlink" title="向父类构造方法传参"></a>向父类构造方法传参</h3><pre><code>class Human{
public:
    Human(char* name, int age){
        this-&gt;name = name;
        this-&gt;age = age;
    }
    void say(){
        cout &lt;&lt; &quot;说话&quot; &lt;&lt; endl;
    }
protected:
    char* name;
    int age;
};

//男人
class Man : public Human{
public:
    //给父类构造函数传参，同时给属性对象赋值
    Man(char *brother, char *s_name, int s_age, char *h_name, int h_age) : Human(s_name, s_age), h(h_name,h_age){
        this-&gt;brother = brother;
    }
    //泡妞
    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
private:
    //兄弟
    char* brother;
    Human h;
};

void main(){
    Man m1(&quot;danny&quot;,&quot;jack&quot;,18,&quot;jason&quot;,18);

    system(&quot;pause&quot;);
}
</code></pre><p>通过在自身构造的时候给父类构造函数传参。子类构造的时候，会先构造父类。</p>
<h3 id="子类与父类构造函数与析构函数调用的顺序"><a href="#子类与父类构造函数与析构函数调用的顺序" class="headerlink" title="子类与父类构造函数与析构函数调用的顺序"></a>子类与父类构造函数与析构函数调用的顺序</h3><pre><code>class Human{
public:
    Human(char* name, int age){
        this-&gt;name = name;
        this-&gt;age = age;
        cout &lt;&lt; &quot;Human 构造函数&quot; &lt;&lt; endl;
    }
    ~Human(){
        cout &lt;&lt; &quot;Human 析构函数&quot; &lt;&lt; endl;
    }
    void say(){
        cout &lt;&lt; &quot;说话&quot; &lt;&lt; endl;
    }
protected:
    char* name;
    int age;
};

//男人
class Man : public Human{
public:
    //给父类构造函数传参，同时给属性对象赋值
    Man(char *brother, char *s_name,int s_age) : Human(s_name, s_age){
        this-&gt;brother = brother;
        cout &lt;&lt; &quot;Man 构造函数&quot; &lt;&lt; endl;
    }
    ~Man(){
        cout &lt;&lt; &quot;Man 析构函数&quot; &lt;&lt; endl;
    }
    //泡妞
    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
private:
    //兄弟
    char* brother;    
};

void func(){
    //父类构造函数先调用
    //子类的析构函数先调用
    Man m1(&quot;danny&quot;, &quot;jack&quot;, 18);
}

void main(){
    func();

    system(&quot;pause&quot;);
}
</code></pre><p>构造的时候先调用父类的构造函数，然后调用子类的构造函数。析构的时候相反。总结就是，先构造，先释放。</p>
<h3 id="子类对象调用父类的成员"><a href="#子类对象调用父类的成员" class="headerlink" title="子类对象调用父类的成员"></a>子类对象调用父类的成员</h3><pre><code>class Human{
public:
    Human(char* name, int age){
        this-&gt;name = name;
        this-&gt;age = age;
        cout &lt;&lt; &quot;Human 构造函数&quot; &lt;&lt; endl;
    }
    ~Human(){
        cout &lt;&lt; &quot;Human 析构函数&quot; &lt;&lt; endl;
    }
    void say(){
        cout &lt;&lt; &quot;说话&quot; &lt;&lt; endl;
    }
public:
    char* name;
    int age;
};

//男人
class Man : public Human{
public:
    //给父类构造函数传参，同时给属性对象赋值
    Man(char *brother, char *s_name, int s_age) : Human(s_name, s_age){
        this-&gt;brother = brother;
        cout &lt;&lt; &quot;Man 构造函数&quot; &lt;&lt; endl;
    }
    ~Man(){
        cout &lt;&lt; &quot;Man 析构函数&quot; &lt;&lt; endl;
    }
    //泡妞
    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
    void say(){
        cout &lt;&lt; &quot;男人喜欢装逼&quot; &lt;&lt; endl;
    }
private:
    //兄弟
    char* brother;
};

void main(){
    //是覆盖，并非动态
    Man m1(&quot;alan&quot;,&quot;john&quot;,18);
    m1.say();
    //调用父类的say方法
    m1.Human::say();

    m1.Human::age = 10;

    system(&quot;pause&quot;);
}
</code></pre><p>注意：Java中就无法使用被覆盖的父类方法，可以通过JNI的方式访问。</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><pre><code>//人
class Person{

};

//公民
class Citizen{

};

//学生，既是人，又是公民
class Student : public Person, public Citizen{

};
</code></pre><h3 id="继承的访问修饰符"><a href="#继承的访问修饰符" class="headerlink" title="继承的访问修饰符"></a>继承的访问修饰符</h3><pre><code>基类中      继承方式             子类中
public     ＆ public继承        =&gt; public
public     ＆ protected继承     =&gt; protected   
public     ＆ private继承       =&gt; private

protected  ＆ public继承        =&gt; protected
protected  ＆ protected继承     =&gt; protected   
protected  ＆ private继承       =&gt; private

private    ＆ public继承        =&gt; 子类无权访问
private    ＆ protected继承     =&gt; 子类无权访问
private    ＆ private继承       =&gt; 子类无权访问
</code></pre><h3 id="继承的二义性"><a href="#继承的二义性" class="headerlink" title="继承的二义性"></a>继承的二义性</h3><pre><code>class A{
public:
    char* name;
};

class A1 : public A{

};

class A2 : public A{

};

class B : public A1, public A2{

};

void main(){
    B b;

    //这句话编译不通过，因为存在二义性
    b.name = &quot;jason&quot;;

    //B中有两个name的副本，我们可以指定使用哪个父类的name
    b.A1::name = &quot;jason&quot;;
    b.A2::name = &quot;jason&quot;;

    system(&quot;pause&quot;);
}
</code></pre><p>如图：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/virtual.png" alt=""></p>
<p>解决方法：虚继承，不同路径继承来的同名成员只有一份拷贝，解决不明确的问题</p>
<p>如果某个类B的两个父类（A1、A2）都继承于同一父类（A），那么这两个父类（A1、A2）可以通过在继承的时候加上virtual关键字来解决二义性问题。</p>
<pre><code>class A{
public:
    char* name;
};

class A1 : virtual public A{

};

class A2 : virtual public A{

};

class B : public A1, public A2{

};

void main(){
    B b;    
    b.name = &quot;jason&quot;;
    //指定父类显示调用
    //b.A1::name = &quot;jason&quot;;
    //b.A2::name = &quot;jason&quot;;
    system(&quot;pause&quot;);
}
</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态作用：程序的扩展性</p>
<p>动态多态：程序运行过程中，觉得哪一个函数被调用（重写）。</p>
<p>静态多态：重载。</p>
<p>发生动态多态的条件：</p>
<ol>
<li>继承</li>
<li>父类的引用或者指针指向子类的对象</li>
<li>函数的重写(需要增加virtual关键字，否则的话就是覆盖)</li>
</ol>
<p>举例：</p>
<p>Plane.h</p>
<pre><code>#pragma once

//普通飞机
class Plane{
public:
    virtual void fly();
    virtual void land();
};
</code></pre><p>Plane.cpp</p>
<pre><code>#include &quot;Plane.h&quot;

#include &lt;iostream&gt;
using namespace std;

void Plane::fly(){
    cout &lt;&lt; &quot;起飞&quot; &lt;&lt; endl;
}

void Plane::land(){
    cout &lt;&lt; &quot;着陆&quot; &lt;&lt; endl;
}
</code></pre><p>Jet.h</p>
<pre><code>#pragma once

#include &quot;Plane.h&quot;

//直升飞机
class Jet : public Plane{
    virtual void fly();
    virtual void land();
};
</code></pre><p>Jet.cpp</p>
<pre><code>#include &quot;Jet.h&quot;
#include &lt;iostream&gt;
using namespace std;

void Jet::fly(){
    cout &lt;&lt; &quot;直升飞机在原地起飞...&quot; &lt;&lt; endl;
}

void Jet::land(){
    cout &lt;&lt; &quot;直升飞机降落在女神的屋顶...&quot; &lt;&lt; endl;
}
</code></pre><p>Copter.h</p>
<pre><code>#pragma once

#include &quot;Plane.h&quot;

//普通飞机
class Copter : public Plane{
public:
    virtual void fly();
    virtual void land();
};
</code></pre><p>Copter.cpp</p>
<pre><code>#include &quot;Copter.h&quot;
#include &lt;iostream&gt;
using namespace std;

void Copter::fly(){
    cout &lt;&lt; &quot;喷气式飞机在跑道上起飞...&quot; &lt;&lt; endl;
}

void Copter::land(){
    cout &lt;&lt; &quot;喷气式飞机在跑道上降落...&quot; &lt;&lt; endl;
}
</code></pre><p>01.cpp</p>
<pre><code>#include &quot;Plane.h&quot;
#include &quot;Jet.h&quot;
#include &quot;Copter.h&quot;
//业务函数
void bizPlay(Plane&amp; p){
    p.fly();
    p.land();
}

void main(){
    Plane p1;
    bizPlay(p1);

    //直升飞机
    Jet p2;
    bizPlay(p2);

    Copter p3;
    bizPlay(p3);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="纯虚函数-抽象类"><a href="#纯虚函数-抽象类" class="headerlink" title="纯虚函数(抽象类)"></a>纯虚函数(抽象类)</h2><ol>
<li>当一个类具有一个纯虚函数，这个类就是抽象类</li>
<li>抽象类不能实例化对象</li>
<li>子类继承抽象类，必须要实现纯虚函数，如果没有，子类也是抽象类</li>
</ol>
<p>抽象类的作用：为了继承约束（新增加的类必须实现父类，提高代码重用性，保证系统的条理性、封闭性），根本不知道未来的实现</p>
<p>举例：</p>
<pre><code>class Shape{
public:
    //纯虚函数
    virtual void sayArea() = 0;
    void print(){
        cout &lt;&lt; &quot;hi&quot; &lt;&lt; endl;
    }
};

//圆
class Circle : public Shape{
public:
    Circle(int r){
        this-&gt;r = r;
    }
    void sayArea(){
        cout &lt;&lt; &quot;圆的面积：&quot; &lt;&lt; (3.14 * r * r) &lt;&lt; endl;
    }
private:
    int r;
};

void main(){
    //Shape s;抽象类不可实例化
    Circle c(10);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="接口（只是逻辑上的划分，语法上跟抽象类的写法没有区别）"><a href="#接口（只是逻辑上的划分，语法上跟抽象类的写法没有区别）" class="headerlink" title="接口（只是逻辑上的划分，语法上跟抽象类的写法没有区别）"></a>接口（只是逻辑上的划分，语法上跟抽象类的写法没有区别）</h2><p>下面代码可以当做一个接口</p>
<pre><code>class Drawble{
    virtual void draw();
};
</code></pre><h2 id="模板函数（泛型）"><a href="#模板函数（泛型）" class="headerlink" title="模板函数（泛型）"></a>模板函数（泛型）</h2><pre><code>void myswap(int&amp; a,int&amp; b){
    int tmp = 0;
    tmp = a;
    a = b;
    b = tmp;
}

void myswap(char&amp; a, char&amp; b){
    char tmp = 0;
    tmp = a;
    a = b;
    b = tmp;
}
</code></pre><p>发现上面这两个函数业务逻辑一样，数据类型不一样，因此可以写成模板函数</p>
<pre><code>//模板函数
template &lt;typename T&gt;
void myswap(T&amp; a, T&amp; b){
    T tmp = 0;
    tmp = a;
    a = b;
    b = tmp;
}

void main(){
    //根据实际类型，自动推导
    int a = 10, b = 20;
    myswap&lt;int&gt;(a,b);
    cout &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; endl;

    char x = &apos;v&apos;, y = &apos;w&apos;;
    myswap(x, y);
    cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;

    system(&quot;pause&quot;);
}
</code></pre><h2 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h2><p>自己定义一个模板类：</p>
<pre><code>template&lt;class T&gt;
class A{
public:
    A(T a){
        this-&gt;a = a;
    }
protected:
    T a;
};
</code></pre><p>普通类继承模板类</p>
<pre><code>class B : public A&lt;int&gt;{
public:
    B(int a,int b) : A&lt;int&gt;(a){
        this-&gt;b = b;
    }
private:
    int b;
};
</code></pre><p>模板类继承模板类</p>
<pre><code>template &lt;class T&gt;
class C : public A&lt;T&gt;{
public:
    C(T c, T a) : A&lt;T&gt;(a){
        this-&gt;c = c;
    }
protected:
    T c;
};
</code></pre><p>实例化模板类</p>
<pre><code>void main(){
    //实例化模板类对象
    //List&lt;String&gt; list;
    A&lt;int&gt; a(6);
    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/21/C++学习系列-二-C++中的类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/21/C++学习系列-二-C++中的类/" itemprop="url">
                  C++学习系列(二)C++中的类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T11:20:12+08:00">
                2017-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++与Java一样，也是一种面向对象的编程语言。</p>
<h2 id="C-类的普遍写法"><a href="#C-类的普遍写法" class="headerlink" title="C++类的普遍写法"></a>C++类的普遍写法</h2><p>类的定义是在头文件中（MyTeacher.h）：</p>
<pre><code>#pragma once

class MyTeacher{
//属性
public:
    int age;
    char* name;
//方法
public:
    void setAge(int age);
    int getAge();
    void setName(char* name);
    char* getName();
};
</code></pre><p>实现在源文件中(MyTeacher.cpp):</p>
<pre><code>#include &quot;MyTeacher.h&quot;

void MyTeacher::setAge(int age){
    this-&gt;age = age;
}

int MyTeacher::getAge(){
    return this-&gt;age;
}

void MyTeacher::setName(char* name){
    this-&gt;name = name;
}

char* MyTeacher::getName(){
    return this-&gt;name;
}
</code></pre><p>类的使用（01.cpp）：</p>
<pre><code>#include &quot;MyTeacher.h&quot;

void main(){
    MyTeacher t1;
    t1.name = &quot;Jack&quot;;
    t1.age = 20;

    cout &lt;&lt; t1.getName() &lt;&lt; endl;

    system(&quot;pause&quot;);
}
</code></pre><p>这就是一个c++类的普遍写法，下面为了方便，都写在源文件（01.cpp)中。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数分为有参构造和无参构造两种，无参构造函数是系统默认的，一旦提供啦有参构造就会覆盖无参构造。</p>
<p>举例：</p>
<pre><code>class Teacher{
private:
    char *name;
    int age;
public:
    //无参构造函数（写了，就会覆盖默认的无参构造函数）
    Teacher(){
        cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl;
    }
    //有参构造函数会覆盖默认的构造函数
    Teacher(char *name, int age){
        this-&gt;name = name;
        this-&gt;age = age;
        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;
    }    
};

void main(){
    //两种初始化对象的方法
    //Teacher t1;
    Teacher t2(&quot;yuehan&quot;,20);

    //另外一种调用方式
    Teacher t3 = Teacher(&quot;jack&quot;,21);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数：当对象要被系统释放时，析构函数被调用</p>
<p>作用：善后处理，例如释放动态分配的内存。</p>
<p>举例：</p>
<pre><code>class Teacher{
private:
    char *name;
    int age;
public:
    //无参构造函数赋默认值
    Teacher(){
        this-&gt;name = (char*)malloc(100);
        strcpy(name,&quot;jack walson&quot;);
        age = 20;
        cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl;
    }
    //析构函数
    //当对象要被系统释放时，析构函数被调用
    //作用：善后处理
    ~Teacher(){
        cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl;
        //释放内存
        free(this-&gt;name);
    }
};

void func(){
    Teacher t1;
}

void main(){
    func();

    system(&quot;pause&quot;);
}
</code></pre><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数被调用的场景：</p>
<ol>
<li>声明时赋值</li>
<li>作为参数传入，实参给形参赋值</li>
<li>作为函数返回值返回，给变量初始化赋值</li>
</ol>
<p>系统默认的拷贝构造函数就是拷贝值的，实例如下：</p>
<pre><code>class Teacher{
private:
    char *name;
    int age;
public:
    Teacher(char *name, int age){
        this-&gt;name = name;
        this-&gt;age = age;
        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;
    }
    //拷贝构造函数（值拷贝）
    //默认拷贝构造函数，就是值拷贝
    Teacher(const Teacher &amp;obj){
        this-&gt;name = obj.name;
        this-&gt;age = obj.age;
        cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;
    }
    void myprint(){
        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;
    }
};

Teacher func1(Teacher t){
    t.myprint();
    return t;
}

void main(){
    Teacher t1(&quot;rose&quot;,20);

    //拷贝构造函数被调用的场景
    //1.声明时赋值
    //Teacher t2 = t1;
    //t2.myprint();
    //2.作为参数传入，实参给形参赋值
    func1(t1);
    //3.作为函数返回值返回，给变量初始化赋值
    //Teacher t3 = func1(t1);

    //这里不会被调用
    //Teacher t1 ;
    //Teacher t2;
    //t1 = t2;

    system(&quot;pause&quot;);
}
</code></pre><h3 id="浅拷贝（值拷贝）问题"><a href="#浅拷贝（值拷贝）问题" class="headerlink" title="浅拷贝（值拷贝）问题"></a>浅拷贝（值拷贝）问题</h3><pre><code>class Teacher{
private:
    char *name;
    int age;
public:
    Teacher(char *name, int age){
        this-&gt;name = (char*)malloc(100);
        strcpy(this-&gt;name,name);
        this-&gt;age = age;
        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;
    }    
    ~Teacher(){
        cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl;
        //释放内存
        free(this-&gt;name);
    }
    void myprint(){
        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;
    }
};

void func(){
    Teacher t1(&quot;rose&quot;, 20);

    Teacher t2 = t1;
    t2.myprint();
}

void main(){
    func();

    system(&quot;pause&quot;);
}
</code></pre><p>以上代码，默认的拷贝构造函数实现是浅拷贝，即值拷贝，会带来一些问题：</p>
<p>如果有动态内存分配的时候，如果单纯是值拷贝，析构的时候就会析构两次。</p>
<p>上面代码中的char* name，t1、t2都指向了同一个地址，如下图，那么析构的时候就会free两次，因为一个内存地址不能释放两次，因此会触发异常中断。</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/copy01.png" alt=""></p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>通过深拷贝来解决浅拷贝这个问题</p>
<pre><code>class Teacher{
private:
    char *name;
    int age;
public:
    Teacher(char *name, int age){
        int len = strlen(name);
        this-&gt;name = (char*)malloc(len+1);
        strcpy(this-&gt;name, name);
        this-&gt;age = age;
        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;
    }
    ~Teacher(){
        cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl;
        //释放内存
        free(this-&gt;name);
    }
    //深拷贝
    Teacher(const Teacher &amp;obj){
        //复制name属性
        int len = strlen(obj.name);
        this-&gt;name = (char*)malloc(len+1);
        strcpy(this-&gt;name,obj.name);
        this-&gt;age = obj.age;
    }
    void myprint(){
        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;
    }
};

void func(){
    Teacher t1(&quot;rose&quot;, 20);

    Teacher t2 = t1;
    t2.myprint();
}

void main(){
    func();

    system(&quot;pause&quot;);
}
</code></pre><p>重写覆盖默认的浅拷贝，自己写一个深拷贝。</p>
<p>t1、t2都指向了不同的内存地址。</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/copy02.png" alt=""></p>
<h2 id="构造函数的属性初始化列表"><a href="#构造函数的属性初始化列表" class="headerlink" title="构造函数的属性初始化列表"></a>构造函数的属性初始化列表</h2><p>作用：在Student类中有两个Teacher的私有属性对象。在Student构造的时候需要初始化Teacher，但是又不能直接访问Teacher类的私有属性。因此只能通过初始化列表的方式来调用。相当于Java利用super(…)调用父类的构造函数初始化父类。</p>
<p>举例：</p>
<pre><code>class Teacher{
private:
    char* name;
public:
    Teacher(char* name){
        this-&gt;name = name;
        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;
    }
    ~Teacher(){
        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;
    }
    char* getName(){
        return this-&gt;name;
    }

};

class Student{
private:
    int id;
    //属性对象
    //Teacher t = Teacher(&quot;miss cang&quot;);
    Teacher t1;
    Teacher t2;
public:
    Student(int id,char *t1_n, char* t2_n) : t1(t1_n), t2(t2_n){
        this-&gt;id = id;
        cout &lt;&lt; &quot;Student有参构造函数&quot; &lt;&lt; endl;
    }
    void myprint(){
        cout &lt;&lt; id &lt;&lt; &quot;,&quot; &lt;&lt; t1.getName() &lt;&lt;&quot;,&quot; &lt;&lt; t2.getName() &lt;&lt; endl;
    }
    ~Student(){
        cout &lt;&lt; &quot;Student析构函数&quot; &lt;&lt; endl;
    }
};

void func(){
    Student s1(10, &quot;miss bo&quot;, &quot;mrs liu&quot;);
    //Student s2(20, &quot;miss cang&quot;, &quot;jason&quot;);
    s1.myprint();
    //s2.myprint();
}

void main(){
    func();

    system(&quot;pause&quot;);
}
</code></pre><h2 id="C-动态内存分配"><a href="#C-动态内存分配" class="headerlink" title="C++动态内存分配"></a>C++动态内存分配</h2><p>C++ 通过new(delete)动态内存分配，调用构造和析构函数。</p>
<p>C中通过malloc(free)进行动态内存分配，不会调用构造和析构函数。</p>
<p>举例：</p>
<pre><code>class Teacher{
private:
    char* name;
public:
    Teacher(char* name){
        this-&gt;name = name;
        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;
    }
    ~Teacher(){
        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;
    }
    void setName(char* name){
        this-&gt;name = name;
    }
    char* getName(){
        return this-&gt;name;
    }
};

void func(){
    //C++    
    //会调用构造和析构函数
    Teacher *t1 = new Teacher(&quot;jack&quot;);
    cout &lt;&lt; t1-&gt;getName() &lt;&lt; endl;
    //释放
    delete t1;

    //C
    //Teacher *t2 = (Teacher*)malloc(sizeof(Teacher));
    //t2-&gt;setName(&quot;jack&quot;);
    //free(t2);

}

void main(){

    func();


    //关于C与C++中数组类型比较
    //C
    //int *p1 = (int*)malloc(sizeof(int) * 10);
    //p1[0] = 9;
    //free(p1);

    //C++数组与Java类似
    int *p2 = new int[10];
    p2[0] = 2;
    //释放数组 []
    delete[] p2;

    system(&quot;pause&quot;);
}
</code></pre><p>注意：C++中数组的话，delete的时候需要加上[]</p>
<h2 id="static-静态属性和方法"><a href="#static-静态属性和方法" class="headerlink" title="static 静态属性和方法"></a>static 静态属性和方法</h2><p>C++类的静态属性必须放在全局的地方初始化。</p>
<p>非静态、静态函数可以访问静态属性，但是静态函数只能访问静态属性，这点与Java类似。</p>
<p>静态的属性和方法可以直接通过 类名来访问，也可以通过对象来访问。</p>
<p>举例：</p>
<pre><code>class Teacher{
public:
    char* name;
    //计数器
    static int total;
public:
    Teacher(char* name){
        this-&gt;name = name;        
        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;
    }
    ~Teacher(){
        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;
    }
    void setName(char* name){
        this-&gt;name = name;
    }
    char* getName(){
        return this-&gt;name;
    }
    //计数，静态函数
    static void count(){
        total++;        
        cout &lt;&lt; total &lt;&lt; endl;
    }
};

//静态属性初始化赋值
int Teacher::total = 9;

void main(){
    Teacher::total++;
    cout &lt;&lt; Teacher::total &lt;&lt; endl;
    //直接通过类名访问
    Teacher::count();

    //也可以通过对象名访问
    Teacher t1(&quot;yuehang&quot;);
    t1.count();

    system(&quot;pause&quot;);
}
</code></pre><h2 id="C-中类的大小"><a href="#C-中类的大小" class="headerlink" title="C++中类的大小"></a>C++中类的大小</h2><p>先来了解一下C++的内存分区：<br>分为：栈、堆、全局（静态、全局）、常量区（字符串）、程序代码区五个区域</p>
<p>结构体有字节对齐的概念，C++类的普通属性与结构体有相同的内存布局。</p>
<pre><code>class A{
public:
    int i;
    int j;
    int k;
    static int m;//存在于全局静态区
};

class B{
public:
    int i;
    int j;
    int k;
    void myprintf(){//相当于函数指针的写法，存放在代码区
        cout &lt;&lt; &quot;打印&quot; &lt;&lt; endl;
    }
};


void main(){
    cout &lt;&lt; sizeof(A) &lt;&lt; endl;
    cout &lt;&lt; sizeof(B) &lt;&lt; endl;

    //C/C++ 内存分区：栈、堆、全局（静态、全局）、常量区（字符串）、程序代码区
    //普通属性与结构体相同的内存布局

    system(&quot;pause&quot;);
}
</code></pre><h2 id="C-中的this"><a href="#C-中的this" class="headerlink" title="C++中的this"></a>C++中的this</h2><p>this表示当前对象的指针。</p>
<p>C++函数是共享的（多个对象共享代码区中的一个函数），必须要有能够标识当前对象是谁的办法，于是就用this指针。</p>
<p>举例：</p>
<pre><code>class Teacher{
private:
    char* name;
    int age;
public:
    Teacher(char* name,int age){
        this-&gt;name = name;
        this-&gt;age = age;
        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;
    }
    ~Teacher(){
        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;
    }
    //常函数（const写在函数后面），修饰的是this
    //既不能改变指针的值，又不能改变指针指向的内容
    //const Teacher* const this
    void myprint() const{
        printf(&quot;%#x\n&quot;,this);
        //改变属性的值
        //this-&gt;name = &quot;yuehang&quot;;
        //改变this指针的值
        //this = (Teacher*)0x00009;
        cout &lt;&lt; this-&gt;name &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;
    }
    void myprint2(){        
        cout &lt;&lt; this-&gt;name &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;        
    }
};

void main(){
    Teacher t1(&quot;jack&quot;,20);
    const Teacher t2(&quot;rose&quot;, 18);
    //t2.myprint2(); 常量对象只能调用常量函数，不能调用非常量函数
    //常函数，当前对象不能被修改，防止数据成员被非法访问
    printf(&quot;%#x\n&quot;, &amp;t1);
    t1.myprint();

    printf(&quot;%#x\n&quot;, &amp;t2);
    t2.myprint();

    system(&quot;pause&quot;);
}
</code></pre><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>在友元函数中可以访问类的私有的属性。</p>
<p>举例：modify_i是类A的友元函数，因此modify_i中可以访问A的私有属性</p>
<pre><code>class A{
    //友元函数
    friend void modify_i(A *p, int a);
private:
    int i;
public:
    A(int i){
        this-&gt;i = i;
    }
    void myprint(){
        cout &lt;&lt; i &lt;&lt; endl;
    }

};

//友元函数的实现，在友元函数中可以访问私有的属性
void modify_i(A *p, int a){
    p-&gt;i = a;
}

void main(){
    A* a = new A(10);
    a-&gt;myprint();

    modify_i(a,20);
    a-&gt;myprint();

    system(&quot;pause&quot;);
}
</code></pre><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><pre><code>class A{        
    //友元类
    friend class B;
private:
    int i;
public:
    A(int i){
        this-&gt;i = i;
    }
    void myprint(){
        cout &lt;&lt; i &lt;&lt; endl;
    }    
};

class B{
public:
    //B这个友元类可以访问A类的任何成员
    void accessAny(){
        a.i = 30;        
    }
private:
    A a;
};
</code></pre><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><pre><code>class Point{
public:
    int x;
    int y;
public:
    Point(int x = 0, int y = 0){
        this-&gt;x = x;
        this-&gt;y = y;
    }
    void myprint(){
        cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;
    }
};

//重载+号
Point operator+(Point &amp;p1, Point &amp;p2){
    Point tmp(p1.x + p2.x, p1.y + p2.y);
    return tmp;
}

//重载-号
Point operator-(Point &amp;p1, Point &amp;p2){
    Point tmp(p1.x - p2.x, p1.y - p2.y);
    return tmp;
}

void main(){
    Point p1(10,20);
    Point p2(20,10);

    Point p3 = p1 + p2;

    p3.myprint();

    system(&quot;pause&quot;);
}
</code></pre><h3 id="成员函数，运算符重载"><a href="#成员函数，运算符重载" class="headerlink" title="成员函数，运算符重载"></a>成员函数，运算符重载</h3><pre><code>class Point{
public:
    int x;
    int y;
public:
    Point(int x = 0, int y = 0){
        this-&gt;x = x;
        this-&gt;y = y;
    }
    //成员函数，运算符重载
    Point operator+(Point &amp;p2){
        Point tmp(this-&gt;x + p2.x, this-&gt;y + p2.y);
        return tmp;
    }
    void myprint(){
        cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;
    }
};

void main(){
    Point p1(10, 20);
    Point p2(20, 10);

    //运算符的重载，本质还是函数调用
    //p1.operator+(p2)
    Point p3 = p1 + p2;

    p3.myprint();

    system(&quot;pause&quot;);
}
</code></pre><h3 id="当属性私有时，通过友元函数完成运算符重载"><a href="#当属性私有时，通过友元函数完成运算符重载" class="headerlink" title="当属性私有时，通过友元函数完成运算符重载"></a>当属性私有时，通过友元函数完成运算符重载</h3><pre><code>class Point{
    friend Point operator+(Point &amp;p1, Point &amp;p2);
private:
    int x;
    int y;
public:
    Point(int x = 0, int y = 0){
        this-&gt;x = x;
        this-&gt;y = y;
    }    
    void myprint(){
        cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;
    }
};

Point operator+(Point &amp;p1, Point &amp;p2){
    Point tmp(p1.x + p2.x, p1.y + p2.y);
    return tmp;
}

void main(){
    Point p1(10, 20);
    Point p2(20, 10);

    //运算符的重载，本质还是函数调用
    //p1.operator+(p2)
    Point p3 = p1 + p2;

    p3.myprint();

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/17/C++学习系列-一-命名空间与引用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/17/C++学习系列-一-命名空间与引用/" itemprop="url">
                  C++学习系列(一)命名空间与引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-17T14:44:14+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C与C-的关系"><a href="#C与C-的关系" class="headerlink" title="C与C++的关系"></a>C与C++的关系</h2><ol>
<li>C++可以与C代码进行混编，即表示C++里面可以写C，但是反过来却不可以</li>
<li>C++是面向对象编程语言、C是面向过程的编程</li>
<li>C++是对C的一个增强，C++有class、引用的概念，堆内存的分配释放除了C语言的malloc、free，还有new、delete关键字</li>
</ol>
<h2 id="C-的命名空间"><a href="#C-的命名空间" class="headerlink" title="C++的命名空间"></a>C++的命名空间</h2><h3 id="C-的命名空间-1"><a href="#C-的命名空间-1" class="headerlink" title="C++的命名空间"></a>C++的命名空间</h3><p>命名空间，也叫名字空间，类似于Java中包（归类）。当项目比较大的时候，用于区分不同人写的代码、不同库的代码。不同命名空间下面，函数名、变量名、类名等都可以重复。</p>
<p>举例：</p>
<pre><code>#include &lt;iostream&gt;

//标准命名空间(包含很多标准的定义)
//standard
//命名空间类似于Java中包（归类）    
using namespace std;

void main(){
    //运算符重载
    //std::cout &lt;&lt; &quot;this is c plus plus&quot; &lt;&lt; std::endl;
    cout &lt;&lt; &quot;this is c plus plus&quot; &lt;&lt; endl;
    system(&quot;pause&quot;);
}
</code></pre><p>通过using namespace来使用std这个命名空间。也可以通过std::的方式来用命名空间，::叫做访问修饰符。</p>
<p>在C++中用cout来输出，它是头文件iostream的输出函数，由于C++可以与C代码进行混编也可以用printf()输出，其中&lt;&lt;是运算符重载，endl是换行的意思。</p>
<h3 id="自定义命名空间"><a href="#自定义命名空间" class="headerlink" title="自定义命名空间"></a>自定义命名空间</h3><pre><code>#include &lt;iostream&gt;

//标准命名空间
using namespace std;

//自定义命名空间
namespace NSP_A{
    int a = 9;
}

namespace NSP_B{
    int a = 12;
    //命名空间嵌套
    namespace NSP_C{
        int c = 90;        
    }
}

void main(){
    //使用命名空间
    //::访问修饰符
    cout &lt;&lt; NSP_A::a &lt;&lt; endl;
    cout &lt;&lt; NSP_B::a &lt;&lt; endl;

    cout &lt;&lt; NSP_B::NSP_C::c &lt;&lt; endl;    
    system(&quot;pause&quot;);
}
</code></pre><h3 id="C-命名空间中的结构体"><a href="#C-命名空间中的结构体" class="headerlink" title="C++命名空间中的结构体"></a>C++命名空间中的结构体</h3><p>说明一下：结构体不能被继承，类可以被继承</p>
<pre><code>include &lt;iostream&gt;

//自定义命名空间
namespace NSP_A{
    int a = 9;
    struct Teacher{
        char name[20];
        int age;
    };
    struct Student{
        char name[20];
        int age;
    };

}

void main(){
    //使用命名空间中的结构体
    using NSP_A::Student;
    Student t;
    t.age = 90;

    system(&quot;pause&quot;);
}
</code></pre><p>注意：C++中通过using使用了命名空间中的结构体，在使用结构体的时候，struct关键字可以省略。</p>
<h3 id="C-中的结构体"><a href="#C-中的结构体" class="headerlink" title="C++中的结构体"></a>C++中的结构体</h3><pre><code>//结构体

struct MyTeacher{
public:
    char name[20];
    int age;
public:
    void say(){
        cout &lt;&lt; this-&gt;age &lt;&lt; &quot;岁&quot; &lt;&lt; endl;
    }
};
void main(){
    MyTeacher t1;
    t1.age = 10;
    t1.say();
    system(&quot;pause&quot;);
}
</code></pre><p>C++是C的增强，C++中的结构体可以有访问修饰符，一个修饰符可以修饰多个变量或者函数。</p>
<p>C++中的结构体与Java中的类非常类似，在C语言中只能用函数指针当作成员函数，在C++中直接类似Java中的方法当做函数。</p>
<p>C++中的结构体有一个this指针，指向自身。</p>
<h3 id="C-中的类（class）"><a href="#C-中的类（class）" class="headerlink" title="C++中的类（class）"></a>C++中的类（class）</h3><pre><code>#define PI 3.14
//圆
class MyCircle{
//属性（共用权限访问修饰符）
private:
    double r;
    double s;
public:
    void setR(double r){
        this-&gt;r = r;
    }
    //获取面积
    double getS(){
        return PI * r * r;
    }
};

void main(){
    MyCircle c1;
    c1.setR(4);

    cout &lt;&lt; &quot;圆的面积：&quot; &lt;&lt; c1.getS() &lt;&lt; endl;

    system(&quot;pause&quot;);
}
</code></pre><p>与Java类似，有一个tihs指针指向自身。</p>
<p>类的定义末尾需要有分号。</p>
<h3 id="C-中布尔类型"><a href="#C-中布尔类型" class="headerlink" title="C++中布尔类型"></a>C++中布尔类型</h3><p>C++中有布尔类型bool，C语言没有</p>
<pre><code>void main(){
    //bool isSingle = true;
    bool isSingle = 17;
    //false -17

    if (isSingle){
        cout &lt;&lt; &quot;单身&quot; &lt;&lt; endl;
        cout &lt;&lt; sizeof(bool) &lt;&lt; endl;
    }
    else{
        cout &lt;&lt; &quot;有对象&quot; &lt;&lt; endl;
    }

    int a = 10, b = 20;
    //三目预算符，C++中可以左值，Java中不可以
    ((a &gt; b) ? a : b) = 30;
    cout &lt;&lt; b &lt;&lt; endl;

    system(&quot;pause&quot;);
}
</code></pre><h2 id="C-中的引用"><a href="#C-中的引用" class="headerlink" title="C++中的引用"></a>C++中的引用</h2><p>变量名相当于内存的“门牌号”，人为地取名字，因此可以有多个别名，而这种别名就是引用。</p>
<p>引用的主要作用：作为函数的参数或者返回值，代替指针，使得程序可读性加强。</p>
<p>1.单纯给变量取别名没有任何意义，作为函数参数传递，能保证参数传递过程中不产生副本。</p>
<p>2.引用可以直接操作变量，指针要通过取值(*p)，间接操作变量，指针的可读性差</p>
<pre><code>void main(){
    //变量名-门牌号(内存空间0x00001的别名，可不可以有多个名字？)
    int a = 10;
    //b就这个内存空间另外一个别名\
    //“&amp;”表示C++中的引用，与取地址符要区分开
    int &amp;b = a;    
    cout &lt;&lt; b &lt;&lt; endl;

    system(&quot;pause&quot;);
}
</code></pre><p>上例中引用变量b与变量a操作的是同一个内存地址。</p>
<p>值交换的例子：</p>
<pre><code>//指针值交换
void swap_1(int *a, int *b){
    int c = 0;
    c = *a;
    *a = *b;
    *b = c;
}

//引用值交换
void swap_2(int &amp;a, int &amp;b){
    int c = 0;
    c = a;
    a = b;
    b = c;
}

void main(){
    int x = 10;
    int y = 20;

    printf(&quot;%d,%d\n&quot;,x,y);
    //swap_1(&amp;x, &amp;y);

    //a成了x的别名（&amp;a = x &amp;b = y）
    swap_2(x,y);
    printf(&quot;%d,%d\n&quot;, x, y);

    system(&quot;pause&quot;);
}
</code></pre><p>引用的主要功能：作为函数的参数或返回值，例子如下：</p>
<pre><code>struct Teacher{
    char* name;
    int age;
};

void myprint(Teacher &amp;t){
    cout &lt;&lt; t.name &lt;&lt; &quot;,&quot; &lt;&lt; t.age &lt;&lt; endl;
    t.age = 21;
}

void myprint2(Teacher *t){
    cout &lt;&lt; t-&gt;name &lt;&lt; &quot;,&quot; &lt;&lt; t-&gt;age &lt;&lt; endl;    
    //(*t).name 
}

//引用的主要功能：作为函数的参数或返回值
void main(){
    Teacher t;
    t.name = &quot;Jason&quot;;
    t.age = 20;
    myprint(t);

    myprint2(&amp;t);

    system(&quot;pause&quot;);
}
</code></pre><p>指针的引用，代替二级指针，举例如下：</p>
<pre><code>struct Teacher{
    char* name;
    int age;
};

void getTeacher(Teacher **p){
    Teacher *tmp = (Teacher*)malloc(sizeof(Teacher));
    tmp-&gt;age = 20;
    *p = tmp;
}

//指针的引用，代替二级指针
//Teacher* &amp;p = (Teacher * *p)
void getTeacher(Teacher* &amp;p){
    p = (Teacher*)malloc(sizeof(Teacher));
    p-&gt;age = 20;
}

void main(){
    Teacher *t = NULL;

    getTeacher(&amp;t);

    system(&quot;pause&quot;);
}
</code></pre><h3 id="指针常量与常量指针"><a href="#指针常量与常量指针" class="headerlink" title="指针常量与常量指针"></a>指针常量与常量指针</h3><p>指针常量：指针的常量，不改变地址的指针，但是可以修改它指向的内容</p>
<p>常量指针：指向常量的指针，指向的内容不能修改，可以改变地址</p>
<pre><code>void main(){
    //指针常量，指针的常量，不改变地址的指针，但是可以修改它指向的内容
    int a = 2, b = 3;
    int *const p1 = &amp;a;
    //p1 = &amp;b;  //NO，不能再次赋值
    *p1 = 4;

    //常量指针，指向常量的指针，内容不能修改
    const int *p2 = &amp;a;
    p2 = &amp;b;
    //*p2 = 9;  //NO，内容不能修改
}
</code></pre><h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><p>常引用类似于java中final，不能再进行赋值。</p>
<p>引用必须有值，不为空，指针就不一定。使用指针的时候要注意非空判断。</p>
<pre><code>void myprintf(const int &amp;a){
    cout &lt;&lt; a &lt;&lt; endl;    
}

void main(){    
    //const int a;
    //引用必须要有值，不能为空
    //int &amp;a = NULL;

    //常引用
    int a = 10, b = 9;
    const int &amp;c = a;

    //字面量
    const int &amp;d = 70;

    //c = b;
    myprintf(c);

    system(&quot;pause&quot;);
}
</code></pre><h3 id="引用的大小"><a href="#引用的大小" class="headerlink" title="引用的大小"></a>引用的大小</h3><pre><code>struct Teacher{
    char name[20];
    int age;
};

void main(){
    Teacher t;

    Teacher &amp;t1 = t;
    Teacher *p = &amp;t;

    cout &lt;&lt; sizeof(t1) &lt;&lt; endl;
    cout &lt;&lt; sizeof(p) &lt;&lt; endl;
    system(&quot;pause&quot;);
}
</code></pre><p>输出结果是：引用的大小为24（20+4（int）），指针的大小为8</p>
<p>引用不能为空，没法传进去，举例如下：</p>
<pre><code>struct Teacher{
    char name[20];
    int age;
};

void myprint(Teacher *t){
    cout &lt;&lt; t-&gt;name &lt;&lt; &quot;,&quot; &lt;&lt; t-&gt;age &lt;&lt; endl;
}

void myprint2(Teacher &amp;t){
    cout &lt;&lt; t.name &lt;&lt; &quot;,&quot; &lt;&lt; t.age &lt;&lt; endl;
    t.age = 21;
}

void main(){
    Teacher t;

    Teacher *p = NULL;
    //报错，防止不报错，进行非空判断
    myprint(p);

    //引用不能为空，没法传进去
    Teacher &amp;t2 = NULL;
    myprint2(t2);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="C-中的函数"><a href="#C-中的函数" class="headerlink" title="C++中的函数"></a>C++中的函数</h2><h3 id="函数参数可以有默认值，与Java不同"><a href="#函数参数可以有默认值，与Java不同" class="headerlink" title="函数参数可以有默认值，与Java不同"></a>函数参数可以有默认值，与Java不同</h3><pre><code>void myprint(int x, int y = 9, int z = 8){
    cout &lt;&lt; x &lt;&lt; endl;
}
//重载
void myprint(int x,bool ret){
    cout &lt;&lt; x &lt;&lt; endl;
}

void main(){
    myprint(20);

    system(&quot;pause&quot;);
}
</code></pre><p>注意：如果函数参数y有默认值，那么y之后的参数都要有默认值。</p>
<h3 id="函数的可变参数"><a href="#函数的可变参数" class="headerlink" title="函数的可变参数"></a>函数的可变参数</h3><p>需要使用头文件stdarg.h</p>
<ol>
<li>通过va_start开始读取可变参数，其中形参i是最后一个固定参数。</li>
<li>通过va_arg读取，需要指定类型。</li>
<li><p>通过va_end结束读取。</p>
<pre><code>#include &lt;stdarg.h&gt;
void func(int i,...)
{
    //可变参数指针
    va_list args_p;
    //开始读取可变参数，i是最后一个固定参数
    va_start(args_p,i);
    int a = va_arg(args_p,int);
    char b = va_arg(args_p, char);
    int c = va_arg(args_p, int);
    cout &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; c &lt;&lt; endl;
    //结束
    va_end(args_p);
}

void main(){
    func(9,20,&apos;b&apos;,30);

    system(&quot;pause&quot;);
}
</code></pre></li>
</ol>
<p>也可以循环读取，需要有条件限制（比如可变参数都大于0），且可变参数的类型都一样，否则读取的结果不正确，例子：</p>
<pre><code>void func(int i,...)
{
    //可变参数指针
    va_list args_p;
    //开始读取可变参数，i是最后一个固定参数
    va_start(args_p,i);
    int value;
    while (1){
        value = va_arg(args_p,int);
        if (value &lt;= 0){
            break;
        }
        cout &lt;&lt; value &lt;&lt; endl;
    }

    //结束
    va_end(args_p);
}

void main(){
    func(9, 20, 40, 30);

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/17/JNI系列-七-文件的拆分与合并案例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/17/JNI系列-七-文件的拆分与合并案例/" itemprop="url">
                  JNI系列(七)文件的拆分与合并案例
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-17T10:10:31+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文件拆分"><a href="#文件拆分" class="headerlink" title="文件拆分"></a>文件拆分</h2><p>思路：</p>
<p>例如，我们需要拆分的文件大小为110M,需要拆分成9个小文件，那个有两种情况：</p>
<ol>
<li>如果110能够被9整除的话，那么每个文件大小是：110/9</li>
<li>很显然，这里不能够整除，那么我们前面（9-1）个文件需要大一些，大小为：110/（9-1）。最后一个文件的大小稍微小一些，大小为：110%（9-1）</li>
</ol>
<p>c代码如下：</p>
<pre><code>#include &quot;com_dongnaoedu_ndkfilepatch_NDKFileUtils.h&quot;

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#include &lt;android/log.h&gt;

#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,&quot;jason&quot;,FORMAT,__VA_ARGS__)
#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,&quot;jason&quot;,FORMAT,__VA_ARGS__)

//获取文件大小
long get_file_size(char *path){
    FILE *fp = fopen(path,&quot;rb&quot;);
    fseek(fp,0,SEEK_END);
    return ftell(fp);
}

//拆分
JNIEXPORT void JNICALL Java_com_dongnaoedu_ndkfilepatch_NDKFileUtils_diff
  (JNIEnv *env, jclass jcls, jstring path_jstr,jstring path_pattern_jstr, jint file_num){
    //jstring -&gt; char*
    //需要分割的文件路径
    const char* path = (*env)-&gt;GetStringUTFChars(env,path_jstr,NULL);
    const char* path_pattern = (*env)-&gt;GetStringUTFChars(env,path_pattern_jstr,NULL);

    //得到分割之后的子文件的路径列表
    char **patches = malloc(sizeof(char*) * file_num);
    int i = 0;
    for (; i &lt; file_num; i++) {
        patches[i] = malloc(sizeof(char) * 100);
        //元素赋值
        //需要分割的文件：C://jason/liuyan.png
        //子文件：C://jason/liuyan_%d.png
        sprintf(patches[i], path_pattern, (i+1));
        LOGI(&quot;patch path:%s&quot;,patches[i]);
    }

    //不断读取path文件，循环写入file_num个文件中
    //  整除
    //  文件大小：90，分成9个文件，每个文件10
    //  不整除
    //  文件大小：110，分成9个文件，
    //  前(9-1)个文件为(110/(9-1))=13
    //  最后一个文件(110%(9-1))=6
    int filesize = get_file_size(path);
    FILE *fpr = fopen(path,&quot;rb&quot;);
    //整除
    if(filesize % file_num == 0){
        //单个文件大小
        int part = filesize / file_num;
        i = 0;
        //逐一写入不同的分割子文件中
        for (; i &lt; file_num; i++) {
            FILE *fpw = fopen(patches[i], &quot;wb&quot;);
            int j = 0;
            for(; j &lt; part; j++){
                //边读边写
                fputc(fgetc(fpr),fpw);
            }
            fclose(fpw);
        }
    }
    else{
        //不整除
        int part = filesize / (file_num - 1);
        i = 0;
        //逐一写入不同的分割子文件中
        for (; i &lt; file_num - 1; i++) {
            FILE *fpw = fopen(patches[i], &quot;wb&quot;);
            int j = 0;
            for(; j &lt; part; j++){
                //边读边写
                fputc(fgetc(fpr),fpw);
            }
            fclose(fpw);
        }
        //the last one
        FILE *fpw = fopen(patches[file_num - 1], &quot;wb&quot;);
        i = 0;
        for(; i &lt; filesize % (file_num - 1); i++){
            fputc(fgetc(fpr),fpw);
        }
        fclose(fpw);
    }

    //关闭被分割的文件
    fclose(fpr);

    //释放
    i = 0;
    for(; i &lt; file_num; i++){
        free(patches[i]);
    }
    free(patches);

    (*env)-&gt;ReleaseStringUTFChars(env,path_jstr,path);
    (*env)-&gt;ReleaseStringUTFChars(env,path_pattern_jstr,path_pattern);
}
</code></pre><p>首先我们需要一个分割之后的字符串数组（也就是char二级指针），用于存放分割之后的文件路径。</p>
<p>然后分整除和不整除两种情况来分别处理，不断读取被分割的文件，循环写入每个子文件中。</p>
<h2 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h2><p>文件的合并就是一个逆向的过程。</p>
<pre><code>//合并
JNIEXPORT void JNICALL Java_com_dongnaoedu_ndkfilepatch_NDKFileUtils_patch
  (JNIEnv *env, jclass jcls,jstring path_pattern_jstr, jint file_num,jstring merge_path_jstr){
    //合并之后的文件
    const char* merge_path = (*env)-&gt;GetStringUTFChars(env,merge_path_jstr,NULL);
    //分割子文件的pattern
    const char* path_pattern = (*env)-&gt;GetStringUTFChars(env,path_pattern_jstr,NULL);

    //得到分割之后的子文件的路径列表
    char **patches = malloc(sizeof(char*) * file_num);
    int i = 0;
    for (; i &lt; file_num; i++) {
        patches[i] = malloc(sizeof(char) * 100);
        //元素赋值
        //需要分割的文件：C://jason/liuyan.png
        //子文件：C://jason/liuyan_%d.png
        sprintf(patches[i], path_pattern, (i+1));
        LOGI(&quot;patch path:%s&quot;,patches[i]);
    }

    FILE *fpw = fopen(merge_path,&quot;wb&quot;);
    //把所有的分割文件读取一遍，写入一个总的文件中
    i = 0;
    for(; i &lt; file_num; i++){
        //每个子文件的大小
        int filesize = get_file_size(patches[i]);
        FILE *fpr = fopen(patches[i], &quot;rb&quot;);
        int j = 0;
        for (; j &lt; filesize; j++) {
            fputc(fgetc(fpr),fpw);
        }
        fclose(fpr);
    }
    fclose(fpw);

    //释放
    i = 0;
    for(; i &lt; file_num; i++){
        free(patches[i]);
    }
    free(patches);

    (*env)-&gt;ReleaseStringUTFChars(env,path_pattern_jstr,path_pattern);
    (*env)-&gt;ReleaseStringUTFChars(env,merge_path_jstr,merge_path);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/JNI系列-六-Eclipse下NDK开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/JNI系列-六-Eclipse下NDK开发/" itemprop="url">
                  JNI系列(六)Eclipse下NDK开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-15T14:00:21+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Eclipse-NDK开发流程"><a href="#Eclipse-NDK开发流程" class="headerlink" title="Eclipse NDK开发流程"></a>Eclipse NDK开发流程</h2><ol>
<li>编写Java层Native方法</li>
<li>javah命令生成头文件</li>
<li>创建jni目录</li>
<li>配置NDK路径，添加本地支持add native support，配置ADT需要包含的头文件</li>
<li>实现头文件中定义的函数</li>
<li>编译生成.so动态库</li>
<li>加载动态库</li>
</ol>
<p>下面以文件加密解密的app为例：</p>
<h3 id="编写Java层Native方法："><a href="#编写Java层Native方法：" class="headerlink" title="编写Java层Native方法："></a>编写Java层Native方法：</h3><p>创建Cryptor类，实现两个native方法，加密，解密</p>
<pre><code>package com.dongnaoedu.ndkfilecrypt;

public class Cryptor {


    public native static void crypt(String normal_path, String crypt_path);


    public native static void decrypt(String crypt_path, String decrypt_path);

    static{
        System.loadLibrary(&quot;ndk_file_crypt&quot;);
    }
}
</code></pre><h3 id="javah命令生成头文件"><a href="#javah命令生成头文件" class="headerlink" title="javah命令生成头文件"></a>javah命令生成头文件</h3><p>在命令行下，通过cd命令转到工程的src目录，执行以下命令生成头文件：</p>
<pre><code>javah 完整类名
</code></pre><h3 id="创建jni目录"><a href="#创建jni目录" class="headerlink" title="创建jni目录"></a>创建jni目录</h3><p>在Eclipse的项目中创建jni文件，把生成的头文件放入jni中</p>
<h3 id="配置NDK路径，添加本地支持add-native-support，配置ADT需要包含的头文件"><a href="#配置NDK路径，添加本地支持add-native-support，配置ADT需要包含的头文件" class="headerlink" title="配置NDK路径，添加本地支持add native support，配置ADT需要包含的头文件"></a>配置NDK路径，添加本地支持add native support，配置ADT需要包含的头文件</h3><p>首先，需要设置NDK的路径：</p>
<p>Window-&gt;Preferences-&gt;Android-&gt;NDK:</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/eclipse-ndk.png" alt=""></p>
<p>如果出现“Not a valid NDK directory”，则在你安装的ndk的主目录下创建一个ndk-build空文件，然后重新打开对话框选择就可以了。</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ndk.png" alt=""></p>
<p>添加Add Native Support:</p>
<p>选择项目，点击右键，Android Tools-&gt;Add Native Support弹出下面的界面，输入lib的名字，前缀系统默认为lib</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ndk2.png" alt=""></p>
<p>在工程目录会生成下面的一些文件</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ndk3.png" alt=""></p>
<p>我们可以把.cpp改成.c(c语言文件，cpp为c++,也可不修改)，修改的话就是用c语言来写，不修改就是c++,如果修改的话，Android.mk文件中也要修改LOCAL_SRC_FILES := crypt.c</p>
<p>其中Application.mk是我们自己添加的，用于指定输出什么架构的so动态库文件，Application.mk如下：</p>
<pre><code># armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64
APP_ABI := armeabi armeabi-v7a
APP_PLATFORM := android-8
</code></pre><p>配置ADT中需要包含的NDK头文件：右击工程–&gt;属性–&gt;C/C++常规–&gt;路径和符号，添加NDK的以下目录：</p>
<pre><code>E:\eclipse\android-ndk-r14b\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64\lib\gcc\arm-linux-androideabi\4.9.x\include

E:\eclipse\android-ndk-r14b\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64\lib\gcc\arm-linux-androideabi\4.9.x\include-fixed

E:\eclipse\android-ndk-r14b\platforms\android-18\arch-arm\usr\include
</code></pre><p><img src="http://oph0qv0je.bkt.clouddn.com/ndk4.png" alt=""></p>
<p>配置后如下：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ndk5.png" alt=""></p>
<h3 id="实现头文件中定义的函数"><a href="#实现头文件中定义的函数" class="headerlink" title="实现头文件中定义的函数"></a>实现头文件中定义的函数</h3><p>在crpty.c中实现函数：</p>
<pre><code>#include &quot;com_example_firstndk_Cryptor.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char password[] = &quot;love you&quot;;

//加密
JNIEXPORT void JNICALL Java_com_example_firstndk_Cryptor_crypt
  (JNIEnv *env, jclass jcls, jstring normal_path_jstr, jstring crypt_path_jstr){

    //jstring -&gt; char*
        const char* normal_path = (*env)-&gt;GetStringUTFChars(env,normal_path_jstr,JNI_FALSE);
        const char* crypt_path = (*env)-&gt;GetStringUTFChars(env,crypt_path_jstr,JNI_FALSE);

        //打开文件
        FILE *normal_fp = fopen(normal_path, &quot;rb&quot;);
        FILE *crypt_fp = fopen(crypt_path, &quot;wb&quot;);
        //一次读取一个字符
        int ch;
        int i = 0; //循环使用密码中的字母进行异或运算
        int pwd_len = strlen(password); //密码的长度
        while ((ch = fgetc(normal_fp)) != EOF) { //End of File
            //写入（异或运算）
            fputc(ch ^ password[i % pwd_len], crypt_fp);
            i++;
        }
        //关闭
        fclose(crypt_fp);
        fclose(normal_fp);
}

//解密
JNIEXPORT void JNICALL Java_com_example_firstndk_Cryptor_decrypt
  (JNIEnv *env, jclass jcls, jstring crypt_path_jstr, jstring decrypt_path_jstr){

        const char* crypt_path = (*env)-&gt;GetStringUTFChars(env,crypt_path_jstr,JNI_FALSE);
        const char* decrypt_path = (*env)-&gt;GetStringUTFChars(env,decrypt_path_jstr,JNI_FALSE);

        //打开文件
        FILE *normal_fp = fopen(crypt_path, &quot;rb&quot;);
        FILE *crypt_fp = fopen(decrypt_path, &quot;wb&quot;);
        //一次读取一个字符
        int ch;
        int i = 0; //循环使用密码中的字母进行异或运算
        int pwd_len = strlen(password); //密码的长度
        while ((ch = fgetc(normal_fp)) != EOF) { //End of File
            //写入（异或运算）
            fputc(ch ^ password[i % pwd_len], crypt_fp);
            i++;
        }
        //关闭
        fclose(crypt_fp);
        fclose(normal_fp);

}
</code></pre><h3 id="编译生成-so动态库"><a href="#编译生成-so动态库" class="headerlink" title="编译生成.so动态库"></a>编译生成.so动态库</h3><p>直接make project（Build Project）一下即可。</p>
<h3 id="加载动态库"><a href="#加载动态库" class="headerlink" title="加载动态库"></a>加载动态库</h3><p>通过System.loadLibrary方法加载.so动态库文件，不用写lib前缀，系统会默认添加。</p>
<pre><code>package com.example.firstndk;

public class Cryptor {
    public native static void crypt(String normal_path, String crypt_path);
    public native static void decrypt(String crypt_path, String decrypt_path);

    static{
        System.loadLibrary(&quot;crypt&quot;);
    }
}
</code></pre><p>接下来，我们就需要写android代码来测试调用我们的动态库啦，书写两个按钮，在按钮点击时分别调用加密和解密功能，记得添加SD卡读写权限。</p>
<pre><code>package com.example.firstndk;

import java.io.File;

import android.app.Activity;
import android.os.Bundle;
import android.os.Environment;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;

public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void mCrypt(View v) {
        String normal_path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separatorChar
                + &quot;liuyan.png&quot;;
        String crypt_path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separatorChar
                + &quot;liuyan_crypt.png&quot;;
        Cryptor.crypt(normal_path, crypt_path);
        Log.d(&quot;isen&quot;, &quot;加密完成&quot;);
    }

    public void mDecrypt(View v) {
        String crypt_path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separatorChar
                + &quot;liuyan_crypt.png&quot;;
        String decrypt_path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separatorChar
                + &quot;liuyan_decrypt.png&quot;;
        Cryptor.decrypt(crypt_path, decrypt_path);
        Log.d(&quot;isen&quot;, &quot;解密完成&quot;);
    }

}
</code></pre><p>如果要适配所有平台，需要修改Application.mk为：</p>
<pre><code>APP_ABI := armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/JNI系列-五-JNI缓存策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/JNI系列-五-JNI缓存策略/" itemprop="url">
                  JNI系列(五)JNI缓存策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-15T10:46:24+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="局部static变量"><a href="#局部static变量" class="headerlink" title="局部static变量"></a>局部static变量</h3><p>c代码：</p>
<pre><code>JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_cached(JNIEnv *env, jobject jobj){
    jclass cls = (*env)-&gt;GetObjectClass(env, jobj);    
    //获取jfieldID只获取一次，作用域只在本方法中
    //局部静态变量
    static jfieldID key_id = NULL;
    if (key_id == NULL){
        key_id = (*env)-&gt;GetFieldID(env, cls, &quot;key&quot;, &quot;Ljava/lang/String;&quot;);
        printf(&quot;--------GetFieldID-------\n&quot;);
    }
}
</code></pre><p>测试：</p>
<pre><code>public native void cache();

public static void main(String[] args) {

    JniTest test = new JniTest();
    for (int i = 0; i &lt; 100; i++) {
        test.cache();
    }
}
</code></pre><p>局部静态变量生命周期：</p>
<p>函数第一次执行的时候初始化。</p>
<p>结束，作用域被销毁了，但是这个变量还会存在内存当中，直到程序结束。</p>
<h2 id="初始化全局变量，动态库加载完成之后，立刻缓存起来"><a href="#初始化全局变量，动态库加载完成之后，立刻缓存起来" class="headerlink" title="初始化全局变量，动态库加载完成之后，立刻缓存起来"></a>初始化全局变量，动态库加载完成之后，立刻缓存起来</h2><p>在动态库加载的时候初始化全局变量</p>
<pre><code>public static native void initIds();

static {
    System.loadLibrary(&quot;JniTest&quot;);
    initIds();
}

public static void main(String[] args) {

    JniTest test = new JniTest();
    for (int i = 0; i &lt; 100; i++) {
        test.cache();
    }
}
</code></pre><p>c代码：</p>
<pre><code>jfieldID key_fid;
jmethodID random_mid;
JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_initIds(JNIEnv *env, jclass jcls){    
    key_fid = (*env)-&gt;GetFieldID(env, jcls, &quot;key&quot;, &quot;Ljava/lang/String;&quot;);
    random_mid = (*env)-&gt;GetMethodID(env, jcls, &quot;genRandomInt&quot;, &quot;(I)I&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Feng" />
          <p class="site-author-name" itemprop="name">Feng</p>
           
              <p class="site-description motion-element" itemprop="description">每天一小步，人生一大步</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
