<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="每天一小步，人生一大步">
<meta property="og:type" content="website">
<meta property="og:title" content="Feng's Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Feng's Notes">
<meta property="og:description" content="每天一小步，人生一大步">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feng's Notes">
<meta name="twitter:description" content="每天一小步，人生一大步">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Feng's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Feng's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/JNI系列-五-JNI缓存策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/JNI系列-五-JNI缓存策略/" itemprop="url">
                  JNI系列(五)JNI缓存策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-15T10:46:24+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="局部static变量"><a href="#局部static变量" class="headerlink" title="局部static变量"></a>局部static变量</h3><p>c代码：</p>
<pre><code>JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_cached(JNIEnv *env, jobject jobj){
    jclass cls = (*env)-&gt;GetObjectClass(env, jobj);    
    //获取jfieldID只获取一次，作用域只在本方法中
    //局部静态变量
    static jfieldID key_id = NULL;
    if (key_id == NULL){
        key_id = (*env)-&gt;GetFieldID(env, cls, &quot;key&quot;, &quot;Ljava/lang/String;&quot;);
        printf(&quot;--------GetFieldID-------\n&quot;);
    }
}
</code></pre><p>测试：</p>
<pre><code>public native void cache();

public static void main(String[] args) {

    JniTest test = new JniTest();
    for (int i = 0; i &lt; 100; i++) {
        test.cache();
    }
}
</code></pre><p>局部静态变量生命周期：</p>
<p>函数第一次执行的时候初始化。</p>
<p>结束，作用域被销毁了，但是这个变量还会存在内存当中，直到程序结束。</p>
<h2 id="初始化全局变量，动态库加载完成之后，立刻缓存起来"><a href="#初始化全局变量，动态库加载完成之后，立刻缓存起来" class="headerlink" title="初始化全局变量，动态库加载完成之后，立刻缓存起来"></a>初始化全局变量，动态库加载完成之后，立刻缓存起来</h2><p>在动态库加载的时候初始化全局变量</p>
<pre><code>public static native void initIds();

static {
    System.loadLibrary(&quot;JniTest&quot;);
    initIds();
}

public static void main(String[] args) {

    JniTest test = new JniTest();
    for (int i = 0; i &lt; 100; i++) {
        test.cache();
    }
}
</code></pre><p>c代码：</p>
<pre><code>jfieldID key_fid;
jmethodID random_mid;
JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_initIds(JNIEnv *env, jclass jcls){    
    key_fid = (*env)-&gt;GetFieldID(env, jcls, &quot;key&quot;, &quot;Ljava/lang/String;&quot;);
    random_mid = (*env)-&gt;GetMethodID(env, jcls, &quot;genRandomInt&quot;, &quot;(I)I&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/JNI系列-四-JNI引用与异常处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/JNI系列-四-JNI引用与异常处理/" itemprop="url">
                  JNI系列(四)JNI引用与异常处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-15T09:31:32+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JNI引用变量"><a href="#JNI引用变量" class="headerlink" title="JNI引用变量"></a>JNI引用变量</h2><p>引用类型：局部引用和全局引用</p>
<p>作用：在JNI中告知虚拟机何时回收一个JNI变量</p>
<h3 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h3><p>局部引用，通过DeleteLocalRef手动释放对象</p>
<p>使用场景</p>
<p>1.访问一个很大的java对象，使用完之后，还要进行复杂的耗时操作。</p>
<p>2.创建了大量的局部引用，占用了太多的内存，而且这些局部引用跟后面的操作没有关联性。</p>
<p>举例：</p>
<p>Java代码：</p>
<pre><code>// 局部引用
public native void localRef();
</code></pre><p>c代码：</p>
<p>模拟：循环创建数组</p>
<pre><code>JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_localRef(JNIEnv *env, jobject jobj){
    int i = 0;
    for (; i &lt; 5; i++){
        //创建Date对象（在循环中创建了占用内存大的对象）
        jclass cls = (*env)-&gt;FindClass(env, &quot;java/util/Date&quot;);
        jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
        jobject obj = (*env)-&gt;NewObject(env, cls, constructor_mid);
        //此处省略一百行代码...

        //不在使用jobject对象了
        //通知垃圾回收器回收这些对象
        (*env)-&gt;DeleteLocalRef(env, obj);
        //此处省略一百行代码...
    }
}
</code></pre><p>测试：</p>
<pre><code>public static void main(String[] args) {

    JniTest test = new JniTest();
    test.localRef();

}
</code></pre><h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><p>作用：共享(可以跨多个线程)，手动控制内存使用</p>
<p>举例：</p>
<p>Java代码：提供三个方法，分别用于创建、获取、删除JNI全局引用</p>
<pre><code>public native void createGlobalRef();

public native String getGlobalRef();

public native void deteleGlobalRef();
</code></pre><p>c代码：<br>    //定义全局引用的字符串对象<br>    jstring global_str;</p>
<pre><code>//创建
JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_createGlobalRef(JNIEnv *env, jobject jobj){
    jstring obj = (*env)-&gt;NewStringUTF(env, &quot;jni development is powerful!&quot;);
    //创建全局引用
    global_str = (*env)-&gt;NewGlobalRef(env, obj);
}

//获得
JNIEXPORT jstring JNICALL Java_com_dongnaoedu_jni_JniTest_getGlobalRef(JNIEnv *env, jobject jobj){
    return global_str;
}

//释放
JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_deleteGlobalRef(JNIEnv *env, jobject jobj){
    //释放全局引用
    (*env)-&gt;DeleteGlobalRef(env, global_str);
}
</code></pre><p>测试：</p>
<pre><code>public static void main(String[] args) {

    JniTest test = new JniTest();
    test.localRef();

    test.createGlobalRef();
    System.out.println(test.getGlobalRef());
    test.deteleGlobalRef();

    //删除之后再取出会抛出空指针异常
    System.out.println(test.getGlobalRef());

}
</code></pre><h3 id="弱全局引用"><a href="#弱全局引用" class="headerlink" title="弱全局引用"></a>弱全局引用</h3><p>节省内存，在内存不足时可以是释放所引用的对象</p>
<p>可以引用一个不常用的对象，如果为NULL，临时创建</p>
<p>创建：NewWeakGlobalRef,销毁：DeleteGlobalWeakRef</p>
<h2 id="JNI异常处理"><a href="#JNI异常处理" class="headerlink" title="JNI异常处理"></a>JNI异常处理</h2><p>1.在JNI层手动清空异常信息（ExceptionClear），保证Java代码可以继续运行</p>
<p>2.补救措施保证C代码继续运行</p>
<p>JNI自己抛出的异常，在Java层无法被捕捉，只能在C层清空。</p>
<p>用户通过ThrowNew抛出的异常，可以在Java层捕捉。</p>
<p>例如：属性名字不小心写错了(本来想获取key的属性，结果写成不存在的key2)，拿到的是空jfieldID</p>
<pre><code>JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_exeception(JNIEnv *env, jobject jobj){
    jclass cls = (*env)-&gt;GetObjectClass(env, jobj);
    //属性名字不小心写错了(本来想获取key的属性，结果写成不存在的key2)，拿到的是空的jfieldID
    jfieldID fid = (*env)-&gt;GetFieldID(env, cls, &quot;key2&quot;, &quot;Ljava/lang/String;&quot;);
    //检测是否发生Java异常
    jthrowable exception = (*env)-&gt;ExceptionOccurred(env);
    if (exception != NULL){
        //让Java代码可以继续运行
        //手动清空异常信息
        (*env)-&gt;ExceptionClear(env);

        //提供补救措施，获取一个存在的key属性
        fid = (*env)-&gt;GetFieldID(env, cls, &quot;key&quot;, &quot;Ljava/lang/String;&quot;);
    }

    //获取属性的值
    jstring jstr = (*env)-&gt;GetObjectField(env, jobj, fid);
    char *str = (*env)-&gt;GetStringUTFChars(env, jstr, NULL);

    //对比属性值是否正确
    if (_stricmp(str, &quot;super jason&quot;) != 0){
        //认为抛出异常，给Java层处理
        jclass newExcCls = (*env)-&gt;FindClass(env, &quot;java/lang/IllegalArgumentException&quot;);
        (*env)-&gt;ThrowNew(env,newExcCls,&quot;key&apos;s value is invalid!&quot;);
    }
}
</code></pre><p>测试：</p>
<pre><code>public static void main(String[] args) {

    JniTest test = new JniTest();

    try {
        test.testException();
        System.out.println(&quot;JNI手动抛出了异常，Java不会继续执行，这句话不会被打印\n&quot;);
    } catch (Exception e) {
        System.out.println(&quot;捕获到JNI手动抛出的异常，这句话会被打印：&quot; + e.getMessage() + &quot;\n&quot;);
    }

    System.out.println(&quot;程序继续执行，这句话会被打印\n&quot;);

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/12/JNI系列-三-JNI数组处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/12/JNI系列-三-JNI数组处理/" itemprop="url">
                  JNI系列(三)数组处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T14:19:24+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组的处理"><a href="#数组的处理" class="headerlink" title="数组的处理"></a>数组的处理</h1><p>在Java中传入一个数组到c层，在c层给传入的数组进行排序。</p>
<p>Java代码：</p>
<pre><code>//数组处理
public native void giveArray(int array[]);

public static void main(String[] args) {

    JniTest test = new JniTest();
    int arr[] = { 9, 1, 100, 6, 4, 80 , 46 , 30};
    //进行排序
    test.giveArray(arr);
    System.out.println(Arrays.toString(arr));

}
</code></pre><p>c代码：</p>
<pre><code>int compare(int *a,int *b){
    return (*a) - (*b);
}

//传入
JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_giveArray
(JNIEnv *env, jobject jobj, jintArray arr){

    //jintArray -&gt; jint数组的指针 -&gt; c int 数组
    jint *elems = (*env)-&gt;GetIntArrayElements(env, arr, NULL);
    //printf(&quot;%#x,%#x\n&quot;, &amp;elems, &amp;arr);

    //数组的长度
    int len = (*env)-&gt;GetArrayLength(env, arr);

    //排序，其中compare是函数指针，用于比较大小
    qsort(elems, len, sizeof(jint), compare);    

    //同步：操作完之后需要同步C的数组到Java数组中
    //mode：函数ReleaseIntArrayElements的最后一个参数，有如下取值
    //0, Java数组进行更新，并且释放C/C++数组
    //JNI_ABORT, Java数组不进行更新，但是释放C/C++数组
    //JNI_COMMIT，Java数组进行更新，不释放C/C++数组（函数执行完，数组还是会释放）
    (*env)-&gt;ReleaseIntArrayElements(env, arr, elems, 0);
}
</code></pre><p>在Java中指定一个数组的长度，传入c中，c返回指定长度的数组</p>
<p>Java代码:</p>
<pre><code>public native int[] getArray(int len);

public static void main(String[] args) {

        JniTest test = new JniTest();
        int[] a = test.getArray(10);
        System.out.println(Arrays.toString(a));

    }
</code></pre><p>c代码：</p>
<pre><code>//返回数组
JNIEXPORT jintArray JNICALL Java_com_test_JniTest_getArray(JNIEnv *env, jobject jobj, jint len){
    //创建一个指定大小的数组
    jintArray jint_arr = (*env)-&gt;NewIntArray(env, len);
    jint *elems = (*env)-&gt;GetIntArrayElements(env, jint_arr, NULL);
    int i = 0;
    for (; i &lt; len; i++){
        elems[i] = i;
    }

    //同步
    (*env)-&gt;ReleaseIntArrayElements(env, jint_arr, elems, 0);

    return jint_arr;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/10/JNI系列-二-JNI数据类型与属性方法的访问/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/10/JNI系列-二-JNI数据类型与属性方法的访问/" itemprop="url">
                  JNI系列(二)JIN数据类型与属性方法的访问
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-10T16:08:15+08:00">
                2017-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于Java调c/c++或者c/c++调用Java中的方法属性，需要在c中实现函数，该函数的结构如下：</p>
<p>举例</p>
<pre><code>#include&quot;com_test_JniTest.h&quot;

//函数实现
JNIEXPORT jstring JNICALL Java_com_test_JniTest_getStringFromC
(JNIEnv *env, jclass jcls){

    //JNIEnv 结构体指针
    //env二级指针（一个结构体指针的指针，主要用来在C/C++中使用虚拟机的功能，
    //比如说：访问Java方法，属性，创建Java对象、处理字符串等等）
    //代表Java运行环境，调用Java中的代码
    //返回Java字符串
    return (*env)-&gt;NewStringUTF(env,&quot;marong&quot;);
}
</code></pre><p>#include”com_test_JniTest.h”是函数生成的头文件(javah命令)，也可以自己手写添加。</p>
<p>其中，jstring表示函数返回的JNI数据类型，字符串类型(相当于Java中的string类型)。</p>
<p>Java_com_test_JniTest_getStringFromC表示函数名 , 其组成为Java+Java工程中的类名+类中方法名。</p>
<p>函数的参数：一般都会包含至少两个参数（JNIEnv*,jclass或者jobject)</p>
<ol>
<li>当Java中的native方法为静态方法时：jclass 代表native方法所属类的class对象(JniTest.class)</li>
<li>当Java中的native方法为非静态方法时：jobject 代表native方法所属的对象（new出来的对象）</li>
</ol>
<h1 id="JNI基本数据类型"><a href="#JNI基本数据类型" class="headerlink" title="JNI基本数据类型"></a>JNI基本数据类型</h1><p>Java基本数据类型与JNI数据类型的映射关系</p>
<pre><code>Java类型-&gt;JNI类型-&gt;C类型
</code></pre><h2 id="JNI基本数据类型（左边Java，右边JNI，一一对应关系）"><a href="#JNI基本数据类型（左边Java，右边JNI，一一对应关系）" class="headerlink" title="JNI基本数据类型（左边Java，右边JNI，一一对应关系）"></a>JNI基本数据类型（左边Java，右边JNI，一一对应关系）</h2><pre><code>boolean  jboolean
byte     jbyte
char     jchar
short    jshort
int      jint
long     jlong
float    jfloat
double   jdouble
void     void
</code></pre><h2 id="引用类型-对象"><a href="#引用类型-对象" class="headerlink" title="引用类型(对象)"></a>引用类型(对象)</h2><pre><code>String jstring
object jobject
//数组,基本数据类型的数组
byte[] jByteArray
//对象数组
object[](String[]) jobjectArray
</code></pre><h1 id="C-C-中访问Java的成员"><a href="#C-C-中访问Java的成员" class="headerlink" title="C/C++中访问Java的成员"></a>C/C++中访问Java的成员</h1><p>C/C++通过JNI的api来访问Java的成员,在介绍访问Java成员之前先来说一下Java属性与方法的签名。</p>
<h2 id="关于属性与方法的签名"><a href="#关于属性与方法的签名" class="headerlink" title="关于属性与方法的签名"></a>关于属性与方法的签名</h2><h3 id="属性的签名"><a href="#属性的签名" class="headerlink" title="属性的签名"></a>属性的签名</h3><p>属性的签名其实就是属性的类型的简称，对应关系如下：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/Java%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E5%88%97%E8%A1%A8.png" alt=""></p>
<p>注意：类的签名格式（不要忘记”；”）如下</p>
<pre><code>L完整包名;
</code></pre><h3 id="方法的签名"><a href="#方法的签名" class="headerlink" title="方法的签名"></a>方法的签名</h3><p>通过命令来获取指定类的所有属性和方法的签名：</p>
<p>打开dos命令，输入javap来帮助查找每个命令的信息：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/dos.png" alt=""></p>
<p>通过以下命令就可以拿到指定类的所有属性和方法的签名了</p>
<pre><code>javap -s -p 完整类名
</code></pre><p>通过cd命令，来到Java工程的bin目录，然后输入命令：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/javap.png" alt=""></p>
<p>其中descriptor:后面就是我们需要的签名</p>
<p>方法签名的规律：</p>
<pre><code>(参数类型签名)返回值类型签名
</code></pre><h2 id="C-C-中访问Java的属性和方法"><a href="#C-C-中访问Java的属性和方法" class="headerlink" title="C/C++中访问Java的属性和方法"></a>C/C++中访问Java的属性和方法</h2><p>有以下几种情况：</p>
<ol>
<li>访问Java类的非静态属性</li>
<li>访问Java类的静态属性</li>
<li>访问Java类的非静态方法</li>
<li>访问Java类的静态方法</li>
<li>间接访问Java类的父类的方法</li>
<li>访问Java类的构造方法</li>
</ol>
<h3 id="访问Java的非静态属性"><a href="#访问Java的非静态属性" class="headerlink" title="访问Java的非静态属性"></a>访问Java的非静态属性</h3><p>c访问Java的属性，返回给Java修改之后的属性内容</p>
<p>首先，在Java中写一个native方法，通过调用accessField，利用C修改属性并返回：</p>
<pre><code>public String key = &quot;isen&quot;;
//访问属性，返回修改之后的属性内容
public native String accessField();
</code></pre><p>接下来书写c代码：</p>
<pre><code>//访问属性
//修改属性key
JNIEXPORT jstring JNICALL Java_com_dongnaoedu_jni_JniTest_accessField
(JNIEnv *env, jobject jobj){
    //jobj是t对象，通过对象拿到class(JniTest.class)
    jclass cls = (*env)-&gt;GetObjectClass(env, jobj);
    //jfieldID 拿到对应属性的id
    //传入参数：属性名称，属性签名
    jfieldID fid = (*env)-&gt;GetFieldID(env, cls, &quot;key&quot;, &quot;Ljava/lang/String;&quot;);    

    //通过属性id，获取key属性的值
    //Get&lt;Type&gt;Field
    jstring jstr = (*env)-&gt;GetObjectField(env, jobj, fid);    
    printf(&quot;jstr:%#x\n&quot;,&amp;jstr);

    //jstring 转为 c字符串，第三个参数是一个出参，用来告诉我们GetStringUTFChars内部是否复制了一份字符串
    //isCopy 是否复制（true代表复制，false不复制（或者为NULL））
    char *c_str = (*env)-&gt;GetStringUTFChars(env,jstr,JNI_FALSE);

    //在c中拼接修改属性值，得到新的字符串
    char text[20] = &quot;super &quot;;
    strcat(text,c_str);


    //拼接完成之后，从C字符串转为jstring
    jstring new_jstr = (*env)-&gt;NewStringUTF(env, text);

    //修改key（设置新的属性值）
    //注意规则：Set&lt;Type&gt;Field
    (*env)-&gt;SetObjectField(env, jobj, fid, new_jstr);

    printf(&quot;new_jstr:%#x\n&quot;, &amp;new_jstr);

    //最后释放资源，通知垃圾回收器来回收
    //良好的习惯就是，每次GetStringUTFChars，结束的时候都有一个  ReleaseStringUTFChars与之呼应
    (*env)-&gt;ReleaseStringUTFChars(env, jstr, cstr);

    return new_jstr;
}
</code></pre><p>c中代码可总结为：</p>
<ol>
<li>通过对象拿到class</li>
<li>拿到对应属性的ID</li>
<li>通过属性ID拿到属性值</li>
<li>jstring 转为 c字符串</li>
<li>拼接c字符串，生成新的字符串</li>
<li>c字符串转为jstring</li>
<li>设置新的属性</li>
<li>释放资源</li>
</ol>
<p>最后，在Java中测试：</p>
<pre><code>public static void main(String[] args) {

    JniTest test = new JniTest();
    System.out.println(test.str);
    //修改非静态属性str
    test.accessField();
    System.out.println(test.str);

}
</code></pre><h3 id="访问Java的静态属性"><a href="#访问Java的静态属性" class="headerlink" title="访问Java的静态属性"></a>访问Java的静态属性</h3><p>Java代码：</p>
<pre><code>//访问静态属性count，修改它的值
public static int count = 9;
public native void accessStaticField();
</code></pre><p>c代码：</p>
<p>c中访问静态属性count，修改它的值</p>
<pre><code>JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_accessStaticField
(JNIEnv *env, jobject jobj){
    //jclass
    jclass cls = (*env)-&gt;GetObjectClass(env, jobj);
    //jfieldID 获取静态属性id
    jfieldID fid = (*env)-&gt;GetStaticFieldID(env, cls, &quot;count&quot;, &quot;I&quot;);

    //获取静态属性值
    //GetStatic&lt;Type&gt;Field
    jint count = (*env)-&gt;GetStaticIntField(env, cls, fid);
    count++;
    //修改
    //SetStatic&lt;Type&gt;Field
    (*env)-&gt;SetStaticIntField(env,cls,fid,count);
}
</code></pre><p>最后在Java中测试：</p>
<p>public static void main(String[] args) {</p>
<pre><code>JniTest test = new JniTest();
System.out.println(count);
test.accessStaticField();
System.out.println(count);
</code></pre><p>}</p>
<h3 id="访问Java的非静态方法"><a href="#访问Java的非静态方法" class="headerlink" title="访问Java的非静态方法"></a>访问Java的非静态方法</h3><p>Java代码如下，通过调用accessMethod，在C语言中调用genRandomInt方法</p>
<pre><code>//产生指定范围的随机数
public int genRandomInt(int max){
    System.out.println(&quot;genRandomInt 执行了...&quot;);
    return new Random().nextInt(max); 
}

public native void accessMethod();
</code></pre><p>C代码如下：</p>
<pre><code>//借用java的api产生指定大小的随机数
JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_accessMethod(JNIEnv * env, jobject obj){
    //jclass
    jclass cls = (*env)-&gt;GetObjectClass(env, obj);
    //jmethodID，拿到方法的ID最后一个参数是方法的签名
    jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;genRandomInt&quot;, &quot;(I)I&quot;);
    //调用方法，产生了一个随机数，最后一个是可变参数，就是调用该方法所传入的参数
    //规则：Call&lt;Type&gt;Method 返回值类型
    jint random = (*env)-&gt;CallIntMethod(env, obj, mid, 200);
    printf(&quot;output from C ： %d&quot;, random);
}
</code></pre><p>最后在Java中测试：</p>
<pre><code>public static void main(String[] args) {

    JniTest test = new JniTest();
    test.accessMethod();

}
</code></pre><h3 id="访问Java的静态方法"><a href="#访问Java的静态方法" class="headerlink" title="访问Java的静态方法"></a>访问Java的静态方法</h3><p>Java代码如下，通过调用accessStaticMethod，在C语言中调用getUUID方法</p>
<pre><code>public native void accessStaticMethod();

//产生UUID字符串
public static String getUUID(){
    System.out.println(&quot;getUUID 执行了...&quot;);
    return UUID.randomUUID().toString();
}
</code></pre><p>C代码：</p>
<pre><code>JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_accessStaticMethod
(JNIEnv * env, jobject jobj){
    jclass clz = (*env)-&gt;GetObjectClass(env, jobj);
    jmethodID mid = (*env)-&gt;GetStaticMethodID(env, clz, &quot;getUUID&quot;, &quot;()Ljava/lang/String;&quot;);

    //调用java的静态方法，拿到返回值
    //CallStatic&lt;Type&gt;Method
    jstring jstr = (*env)-&gt;CallStaticObjectMethod(env, clz, mid);

    //随机文件名称 uuid.txt
    //jstring 转成 c字符串
    //isCopy JNI_FALSE，代表java和c操作的是同一个字符串
    char *uuid_str = (*env)-&gt;GetStringUTFChars(env, uuid, JNI_FALSE);

    //后续操作，产生以UUID为文件名的文件
    //拼接
    char fielName[100];
    sprintf(filename, &quot;D://%s.txt&quot;,uuid_str);
    FILE *fp = fopen(filename,&quot;w&quot;);
    fputs(&quot;i love isen&quot;, fp);
    fclose(fp);

    printf(&quot;output from C : File had saved&quot;, jstr);
}
</code></pre><p>最后在Java中测试：</p>
<pre><code>public static void main(String[] args) {

    JniTest test = new JniTest();
    test.accessStaticMethod();

}
</code></pre><h3 id="访问Java类的构造方法"><a href="#访问Java类的构造方法" class="headerlink" title="访问Java类的构造方法"></a>访问Java类的构造方法</h3><p>Java代码如下，通过调用accessConstructor，在底层用C语言调用java.util.Date产生一个当前的时间戳，并且返回。</p>
<pre><code>//调用Date的构造函数
public native long accessConstructor();
</code></pre><p>C代码:</p>
<pre><code>//使用java.util.Date产生一个当前的时间戳
JNIEXPORT jobject JNICALL Java_com_dongnaoedu_jni_JniTest_accessConstructor
(JNIEnv *env, jobject jobj){

    jclass cls = (*env)-&gt;FindClass(env, &quot;java/util/Date&quot;);

    //jmethodID
    //构造方法的函数名的格式是：&lt;init&gt;
    //不能写类名，因为构造方法函数名都一样区分不了，只能通过参数列表（签名）区分
    jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);

    //实例化一个Date对象
    jobject date_obj = (*env)-&gt;NewObject(env, cls, constructor_mid);

    //调用getTime方法(注意签名，返回值long的属性签名是J)
    jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;getTime&quot;, &quot;()J&quot;);
    jlong time = (*env)-&gt;CallLongMethod(env, date_obj, mid);

    printf(&quot;\ntime:%lld\n&quot;,time);

    return date_obj;
}
</code></pre><p>最后在Java中测试：</p>
<pre><code>public static void main(String[] args) {

    JniTest test = new JniTest();
    //直接在Java中构造Date然后调用getTime
    Date date = new Date();
    System.out.println(date.getTime());
    //通过C语音构造Date然后调用getTime
    long time = test.accessConstructor();
    System.out.println(time);

}
</code></pre><h3 id="调用Java类的父类的方法"><a href="#调用Java类的父类的方法" class="headerlink" title="调用Java类的父类的方法"></a>调用Java类的父类的方法</h3><p>Java代码：</p>
<p>父类：</p>
<pre><code>package com.test;

public class Human {
    protected void sayHi() {
        System.out.println(&quot;人开始打招呼....&quot;);
    }    
}
</code></pre><p>子类：</p>
<pre><code>package com.test;

public class Man extends Human {
    @Override
    protected void sayHi() {
        // 可以通过super关键字来访问父类的方法
        // super.sayHi();
        System.out.println(&quot;男人开始打招呼....，儿子是我的&quot;);
    }
}
</code></pre><p>在TestJni类中有Human属性：</p>
<pre><code>//父类的引用指向子类的对象
Human man= new Man();

public native void accessNonvirtualMethod();
</code></pre><p>如果是直接使用man.sayHi()的话，访问的是子类Man的方法。</p>
<p>但是通过底层C的方式可以间接访问到父类Human中的sayHi()方法，跳过子类的实现，这是Java做不到的。</p>
<p>C代码实现：</p>
<pre><code>//调用父类的方法
JNIEXPORT void JNICALL Java_com_dongnaoedu_jni_JniTest_accessNonvirtualMethod
(JNIEnv *env, jobject jobj){

    //1，先拿到属性man

    jclass cls = (*env)-&gt;GetObjectClass(env, jobj);
    //获取man（对象）属性的ID
    jfieldID fid = (*env)-&gt;GetFieldID(env, cls, &quot;human&quot;, &quot;Lcom/dongnaoedu/jni/Human;&quot;);
    //获取man对象
    jobject human_obj = (*env)-&gt;GetObjectField(env, jobj, fid);

     //2，拿到父类的类，以及sayHi的方法id

    jclass human_cls = (*env)-&gt;FindClass(env, &quot;com/dongnaoedu/jni/Human&quot;); //注意：传父类的名称
    jmethodID mid = (*env)-&gt;GetMethodID(env, human_cls, &quot;sayHi&quot;, &quot;()V&quot;);

    //执行,调用自己的(man)sayHi实现
    //(*env)-&gt;CallObjectMethod(env, human_obj, mid);
    //调用父类的sayHi方法实现
    (*env)-&gt;CallNonvirtualObjectMethod(env, human_obj, human_cls, mid);
}
</code></pre><ol>
<li>当存在该类的对象实例时，使用(*env)-&gt;GetObjectClass()获取jclass，相当于Java中的test.getClass()</li>
<li>当不存在该类的对象实例时，使用(*env)-&gt;FindClass()获取jclass，相当于Java中的Class.forName(“com.test.TestJni”)</li>
</ol>
<p>通过CallNonvirtualVoidMethod，访问不覆盖的父类方法（C++使用virtual关键字来覆盖父类的实现），当然你也可以指定哪个父类（如果有多个父类的话）。</p>
<p>最后在Java中测试：</p>
<pre><code>public static void main(String[] args) {

    JniTest test = new JniTest();
    //这时候是调用子类Man的方法
    test.man.sayHi();
    //但是通过JNI的方式，可以访问到父类的sayHi方法
    test.accessNonvirtualMethod();

}
</code></pre><h3 id="经典问题——中文乱码"><a href="#经典问题——中文乱码" class="headerlink" title="经典问题——中文乱码"></a>经典问题——中文乱码</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>从Java层传入中文到c层，在c中输出没有乱码问题，然而，在c层将字符串传入到Java层，在Java层输出打印时出现乱码问题。</p>
<p>测试乱码:</p>
<p>Java代码：</p>
<pre><code>//传入中文到c层
public native void testChineseIn(String chinese);
//c传入中文到Java层
public native String testChineseOut();

public static void main(String[] args) {

JniTest test = new JniTest();
test.testChineseIn(&quot;你好&quot;);
System.out.println(test.testChineseOut());

}
</code></pre><p>c代码:</p>
<pre><code>JNIEXPORT void JNICALL Java_com_test_JniTest_testChineseIn
(JNIEnv *env, jobject jobj,jstring chinese){
    char *str = (*env)-&gt;GetStringUTFChars(env,chinese,NULL);
    printf(&quot;%s&quot;,str);
}

JNIEXPORT jstring JNICALL Java_com_test_JniTest_testChineseOut
(JNIEnv *env, jobject jobj){
    char *chinese = &quot;你好，中国&quot;;
    jstring j_str =(*env)-&gt;NewStringUTF(env,chinese);
    return j_str;
}
</code></pre><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析:"></a>原因分析:</h4><p>调用NewStringUTF的时候，产生的是UTF-16的字符串，但是我们需要的时候UTF-8字符串。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><p>通过Java的String类的构造方法来进行字符集变换。</p>
<p>通过调用构造方法String string = new String(byte[], charsetName);来解决乱码问题</p>
<p>c代码：</p>
<pre><code>//中文问题
JNIEXPORT jstring JNICALL Java_com_test_JniTest_testChineseOut
(JNIEnv *env, jobject jobj, jstring in){

    //c -&gt; jstring
    char *c_str = &quot;马蓉与宋江&quot;;


    //执行String(byte bytes[], String charsetName)构造方法需要的条件
    //1.jmethodID：获取构造方法的ID
    //2.byte数组
    //3.字符编码jstring

    //1.得到string类，获取构造方法ID
    jclass str_cls = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
    jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, str_cls, &quot;&lt;init&gt;&quot;, &quot;([BLjava/lang/String;)V&quot;);

    //2.创建字节数组，并且将C的字符串拷贝进去
    jbyteArray bytes = (*env)-&gt;NewByteArray(env, strlen(c_str));

    //byte数组赋值
    //0-&gt;strlen(c_str)，从头到尾
    //对等于，从c_str这个字符数组，复制到bytes这个字符数组
    (*env)-&gt;SetByteArrayRegion(env, bytes, 0, strlen(c_str), c_str);

    //3.字符编码jstring
    jstring charsetName = (*env)-&gt;NewStringUTF(env, &quot;GB2312&quot;);

    //调用构造函数，返回编码之后的jstring
    return (*env)-&gt;NewObject(env,str_cls,constructor_mid,bytes,charsetName);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/04/JNI系列-一-JNI开发流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/04/JNI系列-一-JNI开发流程/" itemprop="url">
                  JNI系列(一)JNI开发流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T15:41:24+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1><h2 id="1-什么是JNI"><a href="#1-什么是JNI" class="headerlink" title="1.什么是JNI"></a>1.什么是JNI</h2><p>JNI（全称:Java Native Interface）</p>
<p>Java调用C/C++，或者C/C++调用Java的一套API。</p>
<p>NDK开发需要用到JNI。</p>
<p>为什么使用Java调用c/c++？</p>
<ol>
<li>提升效率</li>
<li>防止反编译</li>
</ol>
<h1 id="JNI开发流程"><a href="#JNI开发流程" class="headerlink" title="JNI开发流程"></a>JNI开发流程</h1><ol>
<li>编写native方法</li>
<li>javah命令，生成.h头文件</li>
<li>复制.h头文件到CPP工程中，目的是实现头文件中声明的函数</li>
<li>复制jni.h和jni_md.h文件到CPP工程中</li>
<li>实现.h头文件中声明的函数</li>
<li>生成dll文件</li>
<li>配置dll文件所在目录到环境变量</li>
<li>重启Eclipse</li>
</ol>
<h1 id="JNI详细开发步骤流程"><a href="#JNI详细开发步骤流程" class="headerlink" title="JNI详细开发步骤流程"></a>JNI详细开发步骤流程</h1><p>下面以一个Java工程项目调c为例：</p>
<p>创建Java工程，编写native方法，这里创建了getStringFromC方法：</p>
<pre><code>package com.test;

public class JniTest {

    public static native String getStringFromC();
}
</code></pre><p>打开dos命令，通过cd命令切换到当前Java工程的src目录下面，执行javah命令，参数是完整类名：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/01.png" alt=""></p>
<p>然后在src目录就会生成.h头文件：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/02.png" alt=""></p>
<p>然后将这个头文件拷贝到C/C++工程目录下，然后在VS2013中“头文件-&gt;添加-&gt;现有项”，加到工程中：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/03.png" alt=""></p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/04.png" alt=""></p>
<p>同时，到JDK目录下把jni.h、jni_md.h也通过这种方法加进来</p>
<p>注意：include&lt;&gt;是引入系统的头文件，include””是引入自己的头文件，因此这里需要改一下，否则会报错。</p>
<p>在Test.c文件中实现native方法：</p>
<pre><code>#include &quot;com_test_JniTest.h&quot;

JNIEXPORT jstring JNICALL Java_com_test_JniTest_getStringFromC
(JNIEnv * env, jclass jcls){

    //返回Java的字符串，这里先不作讲解
    return (*env)-&gt;NewStringUTF(env, &quot;String From C&quot;);

}
</code></pre><p>配置解决方案平台，新建平台，选择X64平台：</p>
<p>选择“配置管理器”</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/05.png" alt=""></p>
<p>“活动解决方案平台-&gt;新建</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/06.png" alt=""></p>
<p>选择x64,点击确定按钮</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/07.png" alt=""></p>
<p>配置解决方案的类型，选择输出动态库文件：</p>
<p>选中c项目,右键-&gt;属性</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/08.jpg" alt=""></p>
<p>点击“配置类型”-&gt;动态库(.dll)-&gt;应用-&gt;确定</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/09.png" alt=""></p>
<p>最后，点击“生成”-&gt;“生成解决方案”</p>
<p>注意：Windows下面动态库以dll结尾，Linux下面以so结尾</p>
<p>在工程生成dll文件，然后把这个目录添加到环境变量中(也可以直接把dll文件复制到Java工程)，这样做的目的是为了Java在执行的时候能够找到我们的动态库文件</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/10.png" alt=""></p>
<p>最后回到Java工程，通过System.loadLibrary导入动态库</p>
<pre><code>package com.test;

public class JniTest {

    static{
        System.loadLibrary(&quot;ConsoleApplication5&quot;);
    }
    public static native String getStringFromC();

    public static void main(String[] args) {
        String str =getStringFromC();
        System.out.println(str);
    }
}
</code></pre><p>重新启动eclipse进行测试</p>
<h2 id="JNI的调用过程"><a href="#JNI的调用过程" class="headerlink" title="JNI的调用过程"></a>JNI的调用过程</h2><p><img src="http://oph0qv0je.bkt.clouddn.com/11.png" alt=""></p>
<h2 id="动态库与静态库"><a href="#动态库与静态库" class="headerlink" title="动态库与静态库"></a>动态库与静态库</h2><p>Linux平台下：动态库是.so，静态库是.a</p>
<p>Windows平台下：动态库是.dll，静态库是.lib</p>
<p>动态库可以多个应用共享代码，静态库是全部都会包含在最终生成的exe文件里</p>
<p>JNIEnv：JNIEnv里面有很多方法，与Java进行交互，代表Java的运行环境。</p>
<p>在C中：</p>
<p>JNIEnv 结构体指针别名</p>
<p>env二级指针</p>
<p>在C++中：</p>
<p>JNIEnv 是一个结构体的别名</p>
<p>env 一级指针</p>
<p>C/C++中为什么有区别？</p>
<ol>
<li>为什么需要传入JNIEnv，函数执行过程中需要JNIEnv</li>
<li>C++为什么没有传入？this</li>
<li>C++只是对C的那一套进行的封装，给一个变量赋值为指针，这个变量是二级指针</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/04/C语言学习系列-五-预编译-宏定义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/04/C语言学习系列-五-预编译-宏定义/" itemprop="url">
                  C语言学习系列(五)预编译-宏定义
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T10:58:06+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><p>C语言执行的流程</p>
<ol>
<li>编译：形成目标代码(.obj)</li>
<li>连接：将目标代码与C函数库连接合并，形成最终的可执行文件</li>
<li>执行</li>
</ol>
<p>预编译（预处理），为编译做准备工作，完成代码文本的替换工作。</p>
<p>头文件告诉编译器有这样一个函数，连接器负责找到这个函数的实现，通过include引入。(类似android中include标签)。</p>
<p>举例：</p>
<p>创建头文件my.txt文件</p>
<pre><code>printf(&quot;hello&quot;);
</code></pre><p>主函数中使用：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

void main(){

    #include &quot;my.txt&quot;//其实就是替换my.txt中的内容（include包含我们自己定义的头文件时用“”，系统中的用&lt;&gt;）

    system(&quot;pause&quot;);
}
</code></pre><h1 id="宏定义、宏替换、预编译指令"><a href="#宏定义、宏替换、预编译指令" class="headerlink" title="宏定义、宏替换、预编译指令"></a>宏定义、宏替换、预编译指令</h1><p>define指令</p>
<ol>
<li>定义标示</li>
<li>定义常数（便于修改与阅读）</li>
<li>定义“宏函数”</li>
</ol>
<h2 id="1-定义标示"><a href="#1-定义标示" class="headerlink" title="1. 定义标示"></a>1. 定义标示</h2><p>举例1：</p>
<pre><code>//表示支持C++语法
#ifdef __cplusplus

#endif //相当于if(){}后面的括号

//表示支持Android、Windows、苹果平台等等
#ifdef ANDROID

#endif
</code></pre><p>举例2：</p>
<p>防止文件重复引入</p>
<p>有三个文件A.h、B.h、Test.cpp，分别如下：</p>
<p>A.h：</p>
<pre><code>#include &quot;B.h&quot;
void printfA();
</code></pre><p>B.h：</p>
<pre><code>#include &quot;A.h&quot;
void printfB();
</code></pre><p>Test.cpp里面引用了A.h</p>
<pre><code>#include &quot;A.h&quot;
</code></pre><p>当Test包含a的时候，a又会去包含b，b又会包含a，这样就会造成循环包含。类似于Hibernate里面的SQL循环引用。最终会报如下错误：</p>
<pre><code>fatal error C1014: 包含文件太多 : 深度 = 1024
</code></pre><p>通过宏定义判断来解决这个问题（修改A.h）：</p>
<pre><code>//如果没有定义AH，定义AH
#ifndef AH
#define AH
#include &quot;B.h&quot;

void printfA();

#endif
</code></pre><p>修改B.h:</p>
<pre><code>#ifndef BH
#define BH
#include &quot;A.h&quot;

void printfB();

#endif
</code></pre><p>以上为老版本的解决方法，在新版本中可以用：</p>
<p>修改A.h：</p>
<pre><code>//该头文件只被包含一次，让编译器自定处理好循环包含问题
#pragma once
#include &quot;B.h&quot;

void printfA();
</code></pre><p>修改B.h:</p>
<pre><code>#pragma once
#include &quot;A.h&quot;

void printfB();
</code></pre><h2 id="2-定义常数（便于修改与阅读）"><a href="#2-定义常数（便于修改与阅读）" class="headerlink" title="2. 定义常数（便于修改与阅读）"></a>2. 定义常数（便于修改与阅读）</h2><p>举例：</p>
<pre><code>#define MAX 100

void main(){

    int i = 90;
    if (i &lt; MAX){
    printf(&quot;比MAX小..&quot;);
    }

    system(&quot;pause&quot;);
}
</code></pre><h2 id="3-定义“宏函数”"><a href="#3-定义“宏函数”" class="headerlink" title="3. 定义“宏函数”"></a>3. 定义“宏函数”</h2><p>就是一个替换的过程</p>
<pre><code>//普通函数(无参数)
void dn_com_jni_read(){
    printf(&quot;read\n&quot;);
}

void dn_com_jni_write(){
    printf(&quot;write\n&quot;);
}

//宏函数
//NAME是参数（比如代表普通函数的read/write）
#define jni(NAME)  dn_com_jni_##NAME();

void main(){
     //调用
    jni(write);//替换：dn_com_jni_write();
    getchar();
}
</code></pre><p>日志输出：</p>
<pre><code>//__VA_ARGS__ 代表可变参数
#define LOG(FORMAT,...) printf(##FORMAT,__VA_ARGS__); 

void main(){

        LOG(&quot;%s%d&quot;,&quot;大小：&quot;,89);//相当于替换成：printf(&quot;%s%d&quot;,&quot;大小：&quot;,89);
        getchar();
    }
</code></pre><p>LOG会有级别，于是进一步升级：</p>
<pre><code>#define LOG_I(FORMAT,...)  printf(&quot;INFO:&quot;); printf(##FORMAT,__VA_ARGS__); 

#define LOG_E(FORMAT,...)  printf(&quot;ERRO:&quot;); printf(##FORMAT,__VA_ARGS__); 

void main(){

            LOG_I(&quot;%s%d&quot;,&quot;大小：&quot;,89);
            //替换成：printf(&quot;INFO:&quot;); printf(&quot;%s%d&quot;,&quot;大小：&quot;,89);
        }
</code></pre><p>进一步简化重复代码，重复LEVEL日志级别：</p>
<pre><code>#define LOG(LEVEL,FORMAT,...) printf(##LEVEL); printf(##FORMAT,__VA_ARGS__);
#define LOG_I(FORMAT,...) LOG(&quot;INFO:&quot;,##FORMAT,__VA_ARGS__);
#define LOG_E(FORMAT,...) LOG(&quot;ERROR:&quot;,##FORMAT,__VA_ARGS__);
#define LOG_W(FORMAT,...) LOG(&quot;WARN:&quot;,##FORMAT,__VA_ARGS__);
</code></pre><p>举例：</p>
<p>在Android JNI开发的时候，我们打印一句日志是通过__android_log_print函数来实现的，因此我们可以通过宏定义简化代码：</p>
<pre><code>//Android
#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,&quot;isen&quot;,FORMAT,##__VA_ARGS__);

LOGI(&quot;%s&quot;,&quot;ok&quot;);
//替换__android_log_print(ANDROID_LOG_INFO, &quot;isen&quot;, &quot;%s&quot;, &quot;ok&quot;);
</code></pre><p>C语言系列到此结束，接下来进入JNI系列。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/27/C语言学习系列-四-联合体-枚举-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/27/C语言学习系列-四-联合体-枚举-IO/" itemprop="url">
                  C语言学习系列(四)联合体-枚举-IO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T09:44:44+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="联合体-共用体"><a href="#联合体-共用体" class="headerlink" title="联合体(共用体)"></a>联合体(共用体)</h1><p>不同类型的变量共同占用一段内存（相互覆盖），联合变量任何时刻只有一个成员存在，节省内存。<br>联合体变量的大小=最大的成员所占的字节数</p>
<pre><code>union  MyValue{
    int x;
    int y;
    double z;
};

void main(){
    union MyValue d1;
    d1.x = 90;
    d1.y = 100; //最后一次赋值有效
    //d1.z = 23.8;

    printf(&quot;%d,%d,%lf\n&quot;,d1.x,d1.y,d1.z);
    system(&quot;pause&quot;);
}
</code></pre><p>JNI头文件中的联合体：</p>
<pre><code>typedef union jvalue {
    jboolean    z;
    jbyte       b;
    jchar       c;
    jshort      s;
    jint        i;
    jlong       j;
    jfloat      f;
    jdouble     d;
    jobject     l;
} jvalue;
</code></pre><h1 id="枚举（列举所有的情况）"><a href="#枚举（列举所有的情况）" class="headerlink" title="枚举（列举所有的情况）"></a>枚举（列举所有的情况）</h1><p>限定值，保证取值的安全性</p>
<pre><code>enum Day
{
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
};


void main(){
    //枚举的值，必须是括号中的值
    enum Day d = Monday;
    printf(&quot;%#x,%d\n&quot;,&amp;d,d);

    getchar();
}
</code></pre><h1 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h1><p>读写文本文件</p>
<p>主要用到了fgets和fputs两个函数（函数名中的s是指String，字符串的意思）：</p>
<pre><code>void main(){
    char *path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends.txt&quot;;
    //打开(r表示读)
    FILE *fp = fopen(path,&quot;r&quot;);
    if (fp == NULL){
        printf(&quot;文件打开失败...&quot;);
        return;
    }
    //读取
    char buff[50]; //缓冲
    while (fgets(buff,50,fp)){
        printf(&quot;%s&quot;,buff);
    }
    //关闭
    fclose(fp);
    system(&quot;pause&quot;);

    getchar();
}

//写入
void main(){
    char *path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends_new.txt&quot;;
    //打开
    FILE *fp = fopen(path, &quot;w&quot;);
    char *text = &quot;hchmily@sina.com,程华才,学清路 8\n号科技财富中心 A&quot;;
    fputs(text,fp);

    //关闭流
    fclose(fp);
    getchar();
}
</code></pre><h1 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h1><p>计算机的文件存储在物理上都是二进制，文本文件和二进制之分，其实是一个逻辑之分</p>
<p>C读写文本文件与二进制文件的差别仅仅体现在回车换行符：</p>
<ol>
<li>写文本时，每遇到一个’\n’，会将其转换成’\r\n’(回车换行)。</li>
<li>读文本时，每遇到一个’\r\n’，会将其转换成’\n’。</li>
<li>但是读写二进制文件的时候并不会做以上转换。</li>
</ol>
<p>文件复制</p>
<pre><code>void main(){
    char *read_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan.png&quot;;
    char *write_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan_new.png&quot;;
    //读的文件 b字符表示操作二进制文件binary
    FILE *read_fp = fopen(read_path, &quot;rb&quot;);
    //写的文件
    FILE *write_fp = fopen(write_path, &quot;wb&quot;);

    //复制
    int buff[50]; //缓冲区域（读写二进制文件，类型用int）
    int len = 0; //每次读到的数据长度
    while ((len = fread(buff, sizeof(int), 50, read_fp)) != 0){
        //将读到的内容写入新的文件
        fwrite(buff,sizeof(int),len,write_fp);
    }
    //关闭流
    fclose(read_fp);
    fclose(write_fp);
    getchar();
}
</code></pre><h1 id="获取文件的大小"><a href="#获取文件的大小" class="headerlink" title="获取文件的大小"></a>获取文件的大小</h1><pre><code>void main(){
    char *read_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan.png&quot;;
    FILE *fp = fopen(read_path, &quot;r&quot;);
    //重新定位文件指针
    //SEEK_END文件末尾，0偏移量
    fseek(fp,0,SEEK_END);
    //返回当前的文件指针，相对于文件开头的位移量
    long filesize = ftell(fp);
    printf(&quot;%d\n&quot;,filesize);

    getchar();
}
</code></pre><h1 id="文本文件加解密"><a href="#文本文件加解密" class="headerlink" title="文本文件加解密"></a>文本文件加解密</h1><p>用简单的异或运算进行加密，解密的话就是一个逆过程。</p>
<p>规则：1^1=0, 0^0=0, 1^0=1, 0^1=1 同为0，不同为1</p>
<pre><code>//加密
void crpypt(char normal_path[],char crypt_path[]){
    //打开文件
    FILE *normal_fp = fopen(normal_path, &quot;r&quot;);
    FILE *crypt_fp = fopen(crypt_path, &quot;w&quot;);
    //一次读取一个字符
    int ch;
    while ((ch = fgetc(normal_fp)) != EOF){ //End of File
        //写入（异或运算）
        fputc(ch ^ 9,crypt_fp);
    }
    //关闭
    fclose(crypt_fp);
    fclose(normal_fp);
}

//解密
void decrpypt(char crypt_path[], char decrypt_path[]){
    //打开文件
    FILE *normal_fp = fopen(crypt_path, &quot;r&quot;);
    FILE *crypt_fp = fopen(decrypt_path, &quot;w&quot;);
    //一次读取一个字符
    int ch;
    while ((ch = fgetc(normal_fp)) != EOF){ //End of File
        //写入（异或运算）
        fputc(ch ^ 9, crypt_fp);
    }
    //关闭
    fclose(crypt_fp);
    fclose(normal_fp);

}

void main(){
    char *normal_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends.txt&quot;;
    char *crypt_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends_crypt.txt&quot;;
    char *decrypt_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\friends_decrypt.txt&quot;;

    //crpypt(normal_path, crypt_path);
    //解密
    decrpypt(crypt_path, decrypt_path);

    getchar();
}
</code></pre><h1 id="二进制文件加解密"><a href="#二进制文件加解密" class="headerlink" title="二进制文件加解密"></a>二进制文件加解密</h1><pre><code>//二进制文件加解密
//读取二进制文件中的数据时，一个一个字符读取
//密码：ilovely
/*
void crpypt(char normal_path[], char crypt_path[],char password[]){
    //打开文件
    FILE *normal_fp = fopen(normal_path, &quot;rb&quot;);
    FILE *crypt_fp = fopen(crypt_path, &quot;wb&quot;);
    //一次读取一个字符
    int ch;
    int i = 0; //循环使用密码中的字母进行异或运算
    int pwd_len = strlen(password); //密码的长度
    while ((ch = fgetc(normal_fp)) != EOF){ //End of File
        //写入（异或运算）
        fputc(ch ^ password[i % pwd_len], crypt_fp);
        i++;
    }
    //关闭
    fclose(crypt_fp);
    fclose(normal_fp);
}

//解密
void decrpypt(char crypt_path[], char decrypt_path[],char password[]){
    //打开文件
    FILE *normal_fp = fopen(crypt_path, &quot;rb&quot;);
    FILE *crypt_fp = fopen(decrypt_path, &quot;wb&quot;);
    //一次读取一个字符
    int ch;
    int i = 0; //循环使用密码中的字母进行异或运算
    int pwd_len = strlen(password); //密码的长度
    while ((ch = fgetc(normal_fp)) != EOF){ //End of File
        //写入（异或运算）
        fputc(ch ^ password[i % pwd_len], crypt_fp);
        i++;
    }
    //关闭
    fclose(crypt_fp);
    fclose(normal_fp);

}

void main(){
    char *normal_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan.png&quot;;
    char *crypt_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan_crypt.png&quot;;
    char *decrypt_path = &quot;E:\\dongnao\\vip\\ndk\\08_08_C_05\\files\\liuyan_decrypt.png&quot;;

    //crpypt(normal_path, crypt_path,&quot;iloveqq&quot;);
    //解密
    decrpypt(crypt_path, decrypt_path,&quot;iloveqq&quot;);

    getchar();
}
*/
</code></pre><p>对于微信之类的应用，他们的数据库都是加密的，用的是C语言(动态库so)加密,不用Java去做，安全性不够，容易被反编译。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/C语言学习系列-三-结构体/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/25/C语言学习系列-三-结构体/" itemprop="url">
                  C语言学习系列(三)结构体
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-25T10:59:26+08:00">
                2017-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>结构体是一种构造数据类型(类似Java中的类)，把不同的数据类型整合起来成为一个自定义的数据类型。</p>
<p> 举例</p>
<pre><code>/*
struct Man{
    char name[20];
    int age;
};


void main(){
    //初始化结构体变量
    //结构体初始化方法一
    //struct Man m1 = {&quot;jack&quot;,19};

    //结构体初始化方法二
    struct Man m1;
    m1.age = 30;
    strcpy(m1.name,&quot;rose&quot;);

    printf(&quot;%d\n&quot;,m1.age);
    printf(&quot;%s\n&quot;,m1.name);
    system(&quot;pause&quot;);
};
*/
</code></pre><p>结构体的几种写法</p>
<pre><code>struct Man{
    char name[20];
    int age;
}m1, m2 = { &quot;jack&quot;, 20 };//m1结构体变量名

void main(){
    m1.age = 35;
    strcpy(m1.name,&quot;isen&quot;);
    printf(&quot;%d\n&quot;, m1.age);
    printf(&quot;%s\n&quot;, m1.name);
    system(&quot;pause&quot;);
};
</code></pre><p>匿名结构体：控制结构体变量的个数（限量版），相当于单例。</p>
<pre><code>struct{
    char name[20];
    int age;
}m1;
</code></pre><p>结构体嵌套</p>
<pre><code>/*
struct Teacher{
    char name[20];
};

struct Student{
    char name[20];
    int age;
    struct Teacher t;
};

void main(){
    //字面量的方式
    //struct Student s1 = { &quot;jack&quot;, 21, {&quot;Jason&quot;} };
    struct Student s1;
    s1.age = 10;
    strcpy(s1.t.name, &quot;Jason&quot;);
    system(&quot;pause&quot;);
}
*/
</code></pre><p>结构体嵌套2</p>
<pre><code>/*
struct Student{
    char name[20];
    int age;
    struct Teacher{
        char name[20];
    } t;
};

void main(){
    struct Student s1;
    strcpy(s1.t.name, &quot;Jason&quot;);
    //struct Teacher t;


    system(&quot;pause&quot;);
}
*/
</code></pre><p>结构体与指针</p>
<pre><code>struct Man{
    char name[20];
    int age;
};

void main(){
    struct Man m1 = {&quot;isen&quot;,20};
    //结构体指针
    struct Man *p = &amp;m1;
    printf(&quot;%s,%d\n&quot;, m1.name, m1.age);
    printf(&quot;%s,%d\n&quot;, (*p).name, (*p).age);

    //“-&gt;”（箭头）是“(*p).”简写形式
    printf(&quot;%s,%d\n&quot;,p-&gt;name,p-&gt;age);

    system(&quot;pause&quot;);
}
</code></pre><p>指针与结构体数组</p>
<pre><code>struct Man{
    char name[20];
    int age;
};

void main(){
    struct Man mans[] = { { &quot;isen&quot;, 26 }, { &quot;yahui&quot;, 25 } };
    //求出结构体数组的大小
    int size = sizeof(mans) / sizeof(struct Man);

    //遍历结构体数组方法一，通过指针遍历,mams可以表示数组的首地址，也可以是数组变量名
    struct Man *p = mans;
    for (; p &lt; mans + 2;p++){
        printf(&quot;%s,%d\n&quot;,p-&gt;name,p-&gt;age);
    }

    //遍历方式二，一般的数组方式去遍历
    int i = 0;
    for (; i &lt; size;i++){
        printf(&quot;%s,%d\n&quot;, mans[i].name, mans[i].age);
    }

    system(&quot;pause&quot;);
}
</code></pre><p>结构体的大小（字节对齐）</p>
<p>结构体变量的大小，必须是最宽基本数据类型的整数倍，通过空间换取时间来提升读取效率，其意义：提升读取的效率。</p>
<pre><code>struct Man{
    int age;//4字节
    double weight;//8字节    
};

void main(){
    //结构体变量的大小，必须是最宽基本数据类型的整数倍
    //提升读取的效率
    struct Man m1 = {20,89.0};
    printf(&quot;%#x,%d\n&quot;, &amp;m1,sizeof(m1));//大小应该是16字节
    getchar();
}
</code></pre><p>结构体与动态内存分配</p>
<pre><code>struct Man{
    char *name;
    int age;
};

void main(){
    //动态分配10个Man结构体的内存空间
    struct Man *m_p=(struct Man*)malloc(sizeof(struct Man)*10);
    struct Man *p = m_p;
    //赋值
    p-&gt;name = &quot;isen&quot;;
    p-&gt;age = 27;
    p++;
    p-&gt;name = &quot;rose&quot;;
    p-&gt;age = 30;

    struct Man *loop_p = m_p;
    for (; loop_p &lt; m_p + 2; loop_p++){
        printf(&quot;%s,%d\n&quot;, loop_p-&gt;name, loop_p-&gt;age);
    }

    free(m_p);
    system(&quot;pause&quot;);
}
</code></pre><p>typedef 表示类型取别名</p>
<pre><code>//typedef 类型取别名
//1.不同名称代表在干不同的事情typedef int jint;  
//2.不同情况下，使用不同的别名
//#if defined(__cplusplus)
//typedef _JNIEnv JNIEnv;
//typedef _JavaVM JavaVM;
//3.书写简洁

struct Man{
    char name[20];
    int age;
};

//Age int类型的别名
typedef int Age;
//Age int类型指针的别名
typedef int* Ap;

typedef struct Man JavaMan;
typedef struct Man* JM;

//结构体取别名
//typedef struct Woman W;
//typedef struct Woman* WP;

//简写
typedef struct Woman{
    char name[20];
    int age;
} W, *WP;  //W 是woman结构体的别名, WP 是woman结构体指针的别名

void main(){
    int i = 5;
    Ap p = &amp;i;

    //结构体变量
    W w1 = {&quot;Rose&quot;,20};
    //结构体指针
    WP wp1 = &amp;w1;
    printf(&quot;%s,%d\n&quot;, w1.name, w1.age);
    printf(&quot;%s,%d\n&quot;, wp1-&gt;name, wp1-&gt;age);

    getchar();
}
</code></pre><p>结构体函数指针成员</p>
<pre><code>struct Girl{
    char *name;
    int age;
    //函数指针
    void(*sayHi)(char*);
};
//Girl结构体类似于Java中的类，name和age类似于属性，sayHi类似于方法

void sayHi(char* text){
    MessageBoxA(0, text, &quot;title&quot;, 0);
}

void main(){
    struct Girl g1;
    g1.name = &quot;Lucy&quot;;
    g1.age = 18;
    g1.sayHi = sayHi;

    g1.sayHi(&quot;hello&quot;);

    getchar();
}
</code></pre><p>举例</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;Windows.h&gt;

//定义一个Girl结构体，包括属性和方法
typedef struct Girl{
    char *name;
    int age;
    //函数指针
    void(*sayHi)(char*);
}Girl;//给结构体取一个别名Girl（别名可以与结构体原本的名字相同）

//Girl结构体指针取别名GirlP
typedef Girl* GirlP;

//结构体的成员函数
void sayHi(char* text){
    MessageBoxA(0, text, &quot;title&quot;, 0);
}

//自定义的一个改名函数
void rename(GirlP gp1){
    gp1-&gt;name = &quot;Lily&quot;;
}

void main(){
    Girl g1 = { &quot;Lucy&quot;, 18, sayHi };
    GirlP gp1 = &amp;g1;
    gp1-&gt;sayHi(&quot;Byebye!&quot;);
    //传递指针，改名（只有传递指针才能修改值，所以指针是比较常用的方式）
    rename(gp1);

    getchar();
}
</code></pre><p>完！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/C语言学习系列-二-字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/C语言学习系列-二-字符串/" itemprop="url">
                  C语言学习系列(二)字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-24T15:33:26+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c语言/" itemprop="url" rel="index">
                    <span itemprop="name">c语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="c语言字符串的实现方式："><a href="#c语言字符串的实现方式：" class="headerlink" title="c语言字符串的实现方式："></a>c语言字符串的实现方式：</h1><p>1.字符数组实现：可修改某一个数组元素的值，不可整体赋值，如果需要，需要用strcpy方法实现整体赋值。</p>
<p>2.字符指针实现：不可修改某一个数组元素的值，可整体赋值，运用指针运算，可以截取字符串。</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


//使用字符数组存储字符串
void main(){
    //使用字符数组定义字符串，内存连续，可以修改（相当于Java中的StringBuilder、Buffer）
    //char str[] = {&apos;1&apos;,&apos;4&apos;,&apos;4&apos;,&apos;6&apos;,&apos;9&apos;,&apos;\0&apos;};//可以不指定长度，但是需要有结束符，否则会出现乱码
    //char str[6] = { &apos;1&apos;, &apos;4&apos;, &apos;4&apos;, &apos;6&apos;, &apos;9&apos;};//指定字符数组长度，指定的数组长度需大于数组长度，否则会出现乱码
    char str[] = &quot;china&quot;;//直接用双引号
    //使用上面的方式定义字符数组，可以修改其中某一个字符
    str[0] = &apos;f&apos;;

    //字符数组不能整体赋值，只能在声明的时候整体赋值，优点是可以局部修改某一个字符。如需要重新整体赋值的话，需要使用strcpy函数
    //str = &quot;abcde&quot;;
    char *a = &quot;10086&quot;;
    strcpy(str,a);

    printf(&quot;%s\n&quot;,str);
    printf(&quot;%#x\n&quot;,&amp;str);
    system(&quot;pause&quot;);
}


/*
//字符指针,不能修改某一个字符串（相当于Java中String）
void main(){
    char *str = &quot;how are you!&quot;;

    //不可以修改某一个字符，否则会提示访问冲突
    //str += 3;
    //*str = &apos;p&apos;;

    //但是可以整体赋值
    char p[] = &quot;www.chengweiblog.com&quot;;
    str = &amp;p;

    //使用指针加法截取字符串
    str += 3;
    while (*str)
    {
        printf(&quot;%c&quot;,*str);
        str++;
    }

    //printf(&quot;%s\n&quot;, str);
    //printf(&quot;%#x\n&quot;, str);
    system(&quot;pause&quot;);
}
*/

//字符串常用的方法
//在线手册：http://www.kuqin.com/clib/
//strcat字符串拼接函数
/*
void main(void){
char dest[50];
char *a = &quot;china&quot;;
char *b = &quot; is powerful!&quot;;
strcpy(dest, a);
strcat(dest, b);
printf(&quot;%s\n&quot;, dest);

system(&quot;pause&quot;);
}
*/


//strchr在一个串中查找给定字符的第一个匹配之处
/*
void main(void){
char *str = &quot;I want go to USA!&quot;;
printf(&quot;%#x\n&quot;, str);
//U元素的指针
//str+3
char* p = strchr(str, &apos;w&apos;);
if (p){
printf(&quot;索引位置：%d\n&quot;, p - str);
}
else{
printf(&quot;没有找到&quot;);
}

system(&quot;pause&quot;);
}
*/

//strstr 从字符串haystack中寻找needle第一次出现的位置

void main(void){
    char *haystack = &quot;I want go to USA!&quot;;
    char *needle = &quot;to&quot;;
    //U元素的指针

    char* p = strstr(haystack, needle);
    if (p){
        printf(&quot;索引位置：%d\n&quot;, p - haystack);
    }
    else{
        printf(&quot;没有找到&quot;);
    }

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/17/自定义view基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/自定义view基础知识/" itemprop="url">
                  自定义view基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T16:32:11+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于自定义组件有三种定义方式：</p>
<ol>
<li>完全自己自定义去写，组件类继承View;</li>
<li>从已经有的组件扩展；</li>
<li>将多个组件组合成一个组件；</li>
</ol>
<p>首先看一下继承自View的组件类的实现：</p>
<pre><code>public class MyView extends View{

    public MyView(Context context) {
        super(context);
    }

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }

}
</code></pre><p>需要重写两个方法和三个构造方法，对于三个构造方法的调用场景是不一样的，第一个只有一个参数，在代码中创建组件时会调用该构造方法，比如创建一个按钮：TextView tv = new TextView(this)，this 是指当前的 Activity，Activity 是 Context 的子类。第二个方法在 layout 布局文件中使用时调用，参数 attrs 表示当前配置中的属性集合，例如在要 layout.xml 中定义一个TextView：<textview android:layout_width="match_parent" android:layout_height="wrap_co-ntent" android:text="hello">，Android 会调用第二个构造方法 Inflate 出 TextView 对象。而第三个构造方法是不会自动调用的，当我们在 Theme 中定义了 Style 属性时通常在第二个构造方法中手动调用。</textview></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Feng" />
          <p class="site-author-name" itemprop="name">Feng</p>
           
              <p class="site-description motion-element" itemprop="description">每天一小步，人生一大步</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
