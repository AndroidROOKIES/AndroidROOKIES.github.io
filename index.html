<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="每天一小步，人生一大步">
<meta property="og:type" content="website">
<meta property="og:title" content="Feng's Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Feng's Notes">
<meta property="og:description" content="每天一小步，人生一大步">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feng's Notes">
<meta name="twitter:description" content="每天一小步，人生一大步">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Feng's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Feng's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/29/数据结构与算法-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/29/数据结构与算法-一/" itemprop="url">
                  数据结构与算法(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-29T14:09:14+08:00">
                2017-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/24/nginx流媒体服务器搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/24/nginx流媒体服务器搭建/" itemprop="url">
                  nginx流媒体服务器搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-24T09:55:59+08:00">
                2017-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>直播客户端与服务器端架构图：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/rtmp_zhibo.png" alt=""></p>
<p>Nginx服务器支持RTMP协议（有rtmp-module模块），因此我们把它作为流媒体服务器。高性能反向代理的服务器。</p>
<p>首先创建一个Nginx目录</p>
<pre><code>mkdir nginx
chmod +x nginx/
</code></pre><p>搭建流媒体服务器的环境步骤：</p>
<p>1.先下载安装  nginx 和 nginx-rtmp 编译依赖工具</p>
<pre><code>sudo apt-get install build-essential libpcre3 libpcre3-dev libssl-dev
</code></pre><p>2.创建一个工作目录，并切换到工作目录</p>
<pre><code>mkdir /usr/jason/nginx
cd /usr/jason/nginx
</code></pre><p>3.下载 nginx 和 nginx-rtmp源码（wget是一个从网络上自动下载文件的自由工具）</p>
<pre><code>wget http://nginx.org/download/nginx-1.8.1.tar.gz
wget https://github.com/arut/nginx-rtmp-module/archive/master.zip
</code></pre><p>4.安装unzip工具，解压下载的安装包</p>
<pre><code>sudo apt-get install unzip
</code></pre><p>5.解压 nginx 和 nginx-rtmp安装包</p>
<pre><code>tar -zxvf nginx-1.8.1.tar.gz
-zxvf分别是四个参数
x : 从 tar 包中把文件提取出来
z : 表示 tar 包是被 gzip 压缩过的，所以解压时需要用 gunzip 解压
v : 显示详细信息
f xxx.tar.gz :  指定被处理的文件是 xxx.tar.gz

unzip master.zip
</code></pre><p>6.切换到 nginx-目录</p>
<pre><code>cd nginx-1.8.1
</code></pre><p>7.添加 nginx-rtmp 模板编译到 nginx</p>
<pre><code>./configure --with-http_ssl_module --add-module=../nginx-rtmp-module-master
</code></pre><p>8.编译安装 </p>
<pre><code>make
sudo make install
</code></pre><p>9.安装nginx init 脚本(开机启动，执行Nginx脚本文件)</p>
<pre><code>下载init脚本到/etc/init.d/nginx目录中，其中/etc/init.d目录放是Linux进程启动的时候会执行的一些脚本
sudo wget https://raw.github.com/JasonGiedymin/nginx-init-ubuntu/master/nginx -O /etc/init.d/nginx

cd /etc/init.d/
chmod u+x nginx
//开机启动，去执行脚本文件
update-rc.d nginx defaults
</code></pre><p>开机启动也可手动启动：</p>
<p>手动启动一下：</p>
<pre><code>service nginx start
</code></pre><p>但是这里默认的是80的端口，可以修改端口，在下面目录修改：</p>
<pre><code>cd /usr/local/nginx/conf
vim nginx.conf
</code></pre><p>10.启动和停止nginx 服务，生成配置文件</p>
<pre><code>sudo service nginx start
sudo service nginx stop
</code></pre><p>在nginx启动之后访问你的远程服务器ip地址就会出现如下界面，说明配置成功：</p>
<p><img src="http://otqjpx0f1.bkt.clouddn.com/nginxsuccess.png" alt=""></p>
<p><strong>注</strong>：在此处遇到一个坑，nginx配置成功，并且成功启动，但是访问ip就是打不开上图的界面，最后查到是阿里云服务器中有权限对它进行了阻拦，在阿里云安全组，添加安全组规则。</p>
<p><img src="http://otqjpx0f1.bkt.clouddn.com/aliyun.png" alt=""></p>
<p>11.安装 FFmpeg</p>
<p>这里FFmpeg是用于做音视频的编解码的。</p>
<p>首先需要把解压后的ffmpeg-2.6.9拷贝到下载nginx与rtmp的目录中</p>
<pre><code>cd ffmpeg-2.6.9
编译FFmpeg
./configure --disable-yasm
make
make install
</code></pre><p>输入下面的命令测试是否安装好：</p>
<pre><code>输出安装信息
ffmpeg -v
</code></pre><p>12.配置 nginx-rtmp 服务器</p>
<p>打开 /usr/local/nginx/conf/nginx.conf（Nginx安装在/usr/local/nginx中）</p>
<p>在末尾添加如下 配置</p>
<p>复制代码</p>
<pre><code>rtmp {
    server {
            listen 1935;
            chunk_size 4096;

            application live {
                    live on;
                    record off;
                    exec ffmpeg -i rtmp://localhost/live/$name -threads 1 -c:v libx264 -profile:v baseline -b:v 350K -s 640x360 -f flv -c:a aac -ac 1 -strict -2 -b:a 56k rtmp://localhost/live360p/$name;
            }
            application live360p {
                    live on;
                    record off;
        }
    }
}
</code></pre><p>复制代码</p>
<p>这段代码主要是配置RTMP协议，Nginx是一种模块化的服务器，可以自由添加功能。这里主要是配置RTMP模块的一些参数，包括端口号，视频的编解码参数、格式等等。</p>
<p>13.保存上面配置文件，然后重新启动nginx服务</p>
<pre><code>sudo service nginx restart
</code></pre><p>14.如果你使用了防火墙，请允许端口 tcp 1935</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/05/FFmpeg学习系列-六-Linux之POSIX线程原语/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/FFmpeg学习系列-六-Linux之POSIX线程原语/" itemprop="url">
                  FFmpeg学习系列(六)Linux之POSIX线程原语
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-05T10:16:59+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>POSIX是一种标准，有多线程编程标准、网络编程标准等。</p>
<h3 id="POSIX多线程"><a href="#POSIX多线程" class="headerlink" title="POSIX多线程"></a>POSIX多线程</h3><p>Linux下，一般多线程的实现由POSIX多线程编程实现。Android系统属于Linux系统，因此NDK原生支持POSIX多线程编程。</p>
<p>Windows平台一般用Windows自带的API。</p>
<p><strong>POSIX的编译：</strong></p>
<p>在Linux平台中采用gcc编译（先编译生成目标文件然后链接生成可执行程序）：gcc test.c -o test -lpthread，执行：./test。</p>
<p><strong>POSIX帮助文档的查看：</strong></p>
<ol>
<li>在Linux系统中，安装POSIX帮助文档：sudo apt-get install manpages-posix-dev</li>
<li>列出所有函数man -k pthread；查看某个函数：man pthread_create</li>
</ol>
<h2 id="创建线程与结束线程"><a href="#创建线程与结束线程" class="headerlink" title="创建线程与结束线程"></a>创建线程与结束线程</h2><p>01.c:</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
//必须引入的头文件
#include &lt;pthread.h&gt;

//一个相当于Java的run方法
void* thr_fun(void* arg){

    //得到线程创建的参数
    char* no = (char*)arg;
    int i = 0;
    for(; i &lt; 10; i++){
        printf(&quot;%s thread, i:%d\n&quot;,no,i);
        if(i==5){
            //线程退出（自杀）
            pthread_exit(2);
            //他杀pthread_cancel          
        }
    }  
    //run方法执行完，线程结束，返回 
    return 1;
}

void main(){
    printf(&quot;main thread\n&quot;);
    //线程id
    pthread_t tid;
    //线程的属性，NULL默认属性
    //thr_fun，线程创建之后执行的函数,可以传入参数，在thr_fun方法的arg中可以取出
    pthread_create(&amp;tid,NULL,thr_fun,&quot;1&quot;);
    void* rval;
    //等待tid线程结束
    //thr_fun在线程退出时传入的参数，都作为第二个参数的内容
    pthread_join(tid,&amp;rval);
    printf(&quot;rval:%d\n&quot;,(int)rval);
}
</code></pre><p>书写完成编译gcc 01.c -o 01 -lpthread，执行./01,输出结果如下：</p>
<pre><code>main thread
1 thread,i:0
1 thread,i:1
1 thread,i:2
1 thread,i:3
1 thread,i:4
1 thread,i:5
rval:2
</code></pre><p>在代码中：</p>
<p>通过pthread_create创建线程，需要传入一个函数指针，相当于Java线程中的run方法。然后还需要传参，参数可以在run方法中取出。</p>
<p>线程被创建以后，就会执行“run”方法，该方法中可以拿到线程创建的参数，可以自杀掉线程。线程的结束需要参数。</p>
<p>可以通过pthread_join方法等待线程结束，并且可获取线程结束的参数。</p>
<h2 id="线程加锁"><a href="#线程加锁" class="headerlink" title="线程加锁"></a>线程加锁</h2><p>在多线程中我们需要一个线程执行完再执行另一个线程就需要给线程加锁。</p>
<p>02.c:</p>
<pre><code>#include &lt;stdlib.h&gt;                                                         
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

int i = 0;
//互斥锁
pthread_mutex_t mutex;

void* thr_fun(void* arg){
    //加锁
    pthread_mutex_lock(&amp;mutex);
    char* no = (char*)arg;
    for(;i &lt; 5; i++){
        printf(&quot;%s thread, i:%d\n&quot;,no,i);
        sleep(1);
    }
    i=0;
    //解锁
    pthread_mutex_unlock(&amp;mutex);
}

void main(){
    pthread_t tid1, tid2;
    //初始化互斥锁
    pthread_mutex_init(&amp;mutex,NULL);

    pthread_create(&amp;tid1,NULL,thr_fun,&quot;No1&quot;);
    pthread_create(&amp;tid2,NULL,thr_fun,&quot;No2&quot;);

    pthread_join(tid1,NULL);
    pthread_join(tid2,NULL);

    //销毁互斥锁
    pthread_mutex_destroy(&amp;mutex);
}
</code></pre><p>书写完成编译gcc 02.c -o 02 -lpthread，执行./02,输出结果如下：</p>
<pre><code>No2 thread, i:0
No2 thread, i:1
No2 thread, i:2
No2 thread, i:3
No2 thread, i:4
No1 thread, i:0
No1 thread, i:1
No1 thread, i:2
No1 thread, i:3
No1 thread, i:4
</code></pre><p>在代码中：</p>
<p>我们通过pthread_mutex_init初始化了一把互斥锁，最后通过pthread_mutex_destroy进行销毁。</p>
<p>在线程执行的时候，我们可以通过pthread_mutex_lock、pthread_mutex_unlock进行加锁和解锁。</p>
<p>使用互斥锁可以解决线程死锁（ABBA）的问题。</p>
<p>互斥锁是先让一个线程做完，然后另外一个线程做。还有一种情况就是，一个线程先执行生产，然后另外一个线程就会去消费。</p>
<p>其实视频解码的绘制使用的就是生产者–消费者的模式。图片的下载显示也是基于这种模式。比如说我们生产者生成的产品，放到一个队列里面，当生产者生产出产品的时候就会发送信号通知消费者去消费，例如RTMP推流的时候，我们本地采集音视频的时候就需要一种队列，因为本地的压缩比网络上传要快。</p>
<p>使用这一种模式，就需要条件变量。举例：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

//模拟产品队列
int productNum = 0;

//互斥锁
pthread_mutex_t m;
//条件变量
pthread_cond_t c;

void *produce(void* arg){

    char* no = (char*)arg;

    for (;;){
        //加锁
        pthread_mutex_lock(&amp;m);

        //生产者生产产品
        productNum++;
        printf(&quot;%s生产产品：%d\n&quot;, no, productNum);
        //通知消费者进行消费
        pthread_cond_signal(&amp;c);

        //解锁
        pthread_mutex_unlock(&amp;m);

        sleep(1);
    }
    return (void*)1;
}

void *comsume(void* arg){

    char* no = (char*)arg;

    for (;;){
        pthread_mutex_lock(&amp;m);
        //使用while是为了防止惊群效应唤醒条件变量
        while (productNum == 0){
            //1.没有产品可以消费，等待生产者生产，即等待条件变量被唤醒
            //2.释放互斥锁，使得其他消费者可以进来等待
            //3.被唤醒的时候，解除阻塞，重新申请获得互斥锁，保证只有一个消费者消费
            pthread_cond_wait(&amp;c, &amp;m);
        }
        productNum--;
        printf(&quot;%s消费者消费产品：%d\n&quot;, no, productNum);
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    }
    return (void*)1;
}

void main(){

    printf(&quot;main thread\n&quot;);

    //初始化互斥锁
    pthread_mutex_init(&amp;m, NULL);
    //初始化条件变量
    pthread_cond_init(&amp;c, NULL);

    pthread_t thread_producer;
    pthread_t thread_comsumer;
    //创建线程，指定run方法，并且可以传入参数，在run方法的arg中可以取出
    pthread_create(&amp;thread_producer, NULL, produce, &quot;producer&quot;);
    pthread_create(&amp;thread_comsumer, NULL, comsume, &quot;comsumer&quot;);

    //等待线程结束，获取线程返回参数
    pthread_join(thread_producer, NULL);
    pthread_join(thread_comsumer, NULL);

    //销毁互斥锁
    pthread_mutex_destroy(&amp;m);
    //销毁条件变量
    pthread_cond_destroy(&amp;c);
}
</code></pre><p>书写完成编译gcc 03.c -o 03 -lpthread，执行./03,输出结果如下：</p>
<pre><code>main thread
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
</code></pre><p>这里我通过sleep的方式控制了生产者与消费者的效率，一般来说生产的速度要比消费的速度快。</p>
<p>上面是只有一个生产者和一个消费者的示例代码。一般来说，生产者和消费者都会有多个。这里我们通过线程数组的方式来实现。</p>
<p>举例如下：</p>
<pre><code>#include &lt;stdlib.h&gt;                                                      
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

//消费者数量
#define CONSUMER_NUM 2
//生产者数量
#define PRODUCER_NUM 1

pthread_t pids[CONSUMER_NUM+PRODUCER_NUM];

//产品队列
int ready = 0;

//互斥锁
pthread_mutex_t mutex;
//条件变量
pthread_cond_t has_product;

//生产
void* producer(void* arg){
    int no = (int)arg;
    //条件变量
    for(;;){
        pthread_mutex_lock(&amp;mutex);
        //往队列中添加产品
        ready++;
        printf(&quot;producer %d, produce product\n&quot;,no);
        //fflush(NULL);
        //通知消费者，有新的产品可以消费了
        //会阻塞输出
        pthread_cond_signal(&amp;has_product);
        printf(&quot;producer %d, singal\n&quot;,no);
        pthread_mutex_unlock(&amp;mutex);
        sleep(1);
    }
}

//消费者
void* consumer(void* arg){
    int num = (int)arg;
    for(;;){
        pthread_mutex_lock(&amp;mutex);
        //while?
        //superious wake ‘惊群效应’
        while(ready==0){
            //没有产品，继续等待
            //1.阻塞等待has_product被唤醒
            //2.释放互斥锁，pthread_mutex_unlock
            //3.被唤醒时，解除阻塞，重新申请获得互斥锁pthread_mutex_lock
            printf(&quot;%d consumer wait\n&quot;,num);
            pthread_cond_wait(&amp;has_product,&amp;mutex);
        }
        //有产品，消费产品
        ready--;
        printf(&quot;%d consume product\n&quot;,num);
        pthread_mutex_unlock(&amp;mutex);
        sleep(1);
    }
}


void main(){
    //初始化互斥锁和条件变量                                                
    pthread_mutex_init(&amp;mutex,NULL);
    pthread_cond_init(&amp;has_product,NULL);
    printf(&quot;init\n&quot;);

    int i;
    for(i=0; i&lt;PRODUCER_NUM;i++){
        //生产者线程
        printf(&quot;%d\n&quot;,i);
        pthread_create(&amp;pids[i],NULL,producer,(void*)i);
    }

    for(i=0; i&lt;CONSUMER_NUM;i++){
        //消费者线程
        pthread_create(&amp;pids[PRODUCER_NUM+i],NULL,consumer,(void*)i);
    }

    //等待
    sleep(10);
    for(i=0; i&lt;PRODUCER_NUM+CONSUMER_NUM;i++){
        pthread_join(pids[i],NULL);
    }

    //销毁互斥锁和条件变量
    pthread_mutex_destroy(&amp;mutex);
    pthread_cond_destroy(&amp;has_product);

}
</code></pre><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>在Linux中通过gdb进行调试，步骤如下：</p>
<pre><code>编译加上-g参数
gcc test1.c -g -o test1

进入调试
gdb test1

开始调试
start

显示代码
list-简写l
list 函数名称(查看函数内容)
list 行数（查看某行代码）

执行下一步
next-简写n

查看变量
print 变量名-简写p

进入到某个函数
step-简写s

设置断点
break 行号(gdb中的行号)-简写b

全速运行
continue-遇到断点会停止-简写b

查看断点信息
info breakpoints

删除断点
delete breakpoints 断点编号

修改变量的值
set var 变量=值

程序调用堆栈
当前函数之前的所有已调用函数列表，每一个都分配一个“帧”，最近调用的函数在0号帧里
backtrace-简写bt

切换栈帧
frame 1（查看指定栈帧的变量）

自动显示
display 变量名
取消自动显示
undisplay 行号（自动显示的行号）

查看内存布局
x /20 地址
x /20 buff-查看buff数组的前20个元素
</code></pre><p>在linux中运行程序，程序非正常退出，如何查看错误？</p>
<ol>
<li>ulimit -a 查看core文件是否分配大小</li>
<li>ulimit -c 1024 创建的core文件大小为1024字节</li>
<li>gcc test2.c -g -o test2 编译链接得到带有-g选项的可执行程序</li>
<li>./test2 执行程序，会生成core日志文件</li>
<li>gdb test2 core 打开日志文件，定位错误信息到具体的代码行数</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/04/FFmpeg学习系列-五-Makefile与Android-mk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/04/FFmpeg学习系列-五-Makefile与Android-mk/" itemprop="url">
                  FFmpeg学习系列(五)Makefile与Android.mk
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-04T15:03:53+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>Makefile 构建工具，只需通过make一句命令就可以构建一个可执行程序。相当于Maven、ANT、Gradle构建工具。</p>
<p>gcc是一个编译工具，Makefile是一个构建工具，Makefile中会用到gcc。</p>
<p>在Linux中要把test.c得到一个可执行程序，我们需要编译它，通过 gcc -c test.c 编译生成 test.o 目标文件，这个目标文件不能去执行，需要继续执行 gcc -o test test.o 得到test可执行文件 。</p>
<p>在Java中使用ANT得到apk:</p>
<p>java源文件-&gt;javac编译(相当于gcc)-&gt;class文件-&gt;通过ANT打包得到apk</p>
<p>在c中使用gcc得到可执行文件：</p>
<p>.c源文件-&gt;gcc编译-&gt;.o目标文件-&gt;链接得到二进制可执行文件</p>
<p>如图：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/shell4.png" alt=""></p>
<p>Makefile里面就是包含一系列的生成可执行程序的过程。</p>
<p>在很多C/C++开源项目中，configrue文件用来检查系统配置生成配置文件（这些配置文件会在接下来的Makefile文件中被使用到）<br>Makefile文件用来生成我们需要的动态库文件(.so)。</p>
<h3 id="为什么要写Makefile文件？"><a href="#为什么要写Makefile文件？" class="headerlink" title="为什么要写Makefile文件？"></a>为什么要写Makefile文件？</h3><p>1.当项目非常庞大时，让构建过程，自动化，简单<br>2.依赖文件比目标更新，会重建目标文件</p>
<h3 id="如何编写一个Makefile"><a href="#如何编写一个Makefile" class="headerlink" title="如何编写一个Makefile"></a>如何编写一个Makefile</h3><p>假设一个项目中有<br>plus.c<br>minus.c<br>multi.c<br>divi.c<br>main.c五个.c文件。</p>
<p>我们需要：</p>
<p>.c -&gt; .o目标文件</p>
<p>.o -&gt; 打包myapp，可执行文件</p>
<p>开始编写Makefile文件：</p>
<pre><code>#编写文件需要三要素
#目标，依赖，命令

#myapp目标（最终目标，第一行是最终目标）
#:后的文件，这些都是依赖
#命令TAB键开头，如何由依赖文件得到目标
#step 1（复杂繁琐）
#myapp:main.o plus.o minus.o multi.o divi.o
#    gcc main.o plus.o minus.o multi.o divi.o -o myapp

#目标：main.o
#依赖：main.c
#命令：gcc -c main.c
#main.o:main.c
#    gcc -c main.c
#plus.o:plus.c
#    gcc -c plus.c
#minus.o:minus.c
#    gcc -c minus.c
#multi.o:multi.c
#    gcc -c multi.c
#divi.o:divi.c
#    gcc -c divi.c

#step 2（简写）
#变量
#OBJECTS=main.o plus.o minus.o multi.o divi.o

#step 3（简单明了，最终版本）
#所有.c源文件
SOURCES=$(wildcard *.c)
#把.c后缀，替换成.o后缀即是所有.o文件
OBJECTS=$(patsubst %.c,%.o,$(SOURCES))

myapp:$(OBJECTS)
#自动化变量 $^表示所有依赖，$@表示目标
    gcc $^ -o $@

#通配符
#main.o:main.c
%.o:%.c
#gcc -c main.c -o main.o
    gcc -c $^ -o $@


#没有依赖
#clean清除所有的.o中间文件
#伪目标
.PHONY:clean

clean:
    rm -f *.o
    rm -f myapp

#---------END-------------

#Makefile中一些变量与函数的书写
#递归展开式
#可以引用还没有定义的变量，展开是引用时展开
str2=$(str1)
str1=hello

#直接展开式
#必须引用定义好了的变量，定义之后就会展开
str3 := android
str4 := $(str3)
str5 := $(str1) world

#变量的值追加
str5 += hello

#自定义函数
myfun=$2 $1
#变量等于函数的执行结构
myfun_ret=$(call myfun,20,10)

test:
    @echo $(SOURCES)
    @echo $(OBJECTS)
    @echo $(str2)
    @echo $(str4)
    @echo $(str5)
    @echo $(myfun_ret)
    @echo $(call myfun,30,40)
</code></pre><p>Makefile文件编写完成之后直接执行make命令。</p>
<p>直接make，构建的是终极目标</p>
<p>构建非终极目标，make main.o</p>
<h3 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h3><p>在Android.mk文件中：</p>
<pre><code>调用my-dir函数，返回Android.mk文件所在的目录
LOCAL_PATH := $(call my-dir) 放在第一行，地址当前所在目录
include file Makefile可以引入其他的Makefile文件
include $(CLEAR_VARS) 编译模块时，清空LOCAL_MODULE等参数
LOCAL_MODULE 模块名称
LOCAL_SRC_FILES 编译需要的源文件
LOCAL_C_INCLUDES 需要的头文件
LOCAL_SHARED_LIBRARIES 编译需要的动态库
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/02/FFmpeg学习系列-四-Linux之shell脚本传参及ffmpeg的shell脚本编写/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/FFmpeg学习系列-四-Linux之shell脚本传参及ffmpeg的shell脚本编写/" itemprop="url">
                  FFmpeg学习系列(四)Linux之shell脚本传参及ffmpeg的shell脚本编写
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T15:55:53+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="脚本传参"><a href="#脚本传参" class="headerlink" title="脚本传参"></a>脚本传参</h2><h3 id="在执行脚本时传入参数"><a href="#在执行脚本时传入参数" class="headerlink" title="在执行脚本时传入参数"></a>在执行脚本时传入参数</h3><p><strong>举例如下：</strong></p>
<pre><code>执行脚本，后面是参数
./04.sh hello 47 90 76
</code></pre><p><strong>04.sh脚本：</strong></p>
<pre><code>#!/bin/bash
#获取文件名，basename为命令
filename=$(basename $0)
# $#内建变量，相当于系统参数
echo &quot;参数的总数：$#&quot;
echo $filename
#获取执行脚本时传入的参数
#路径
echo $0
#传入的第一个参数
echo $1
#传入的第二个参数
echo $2
echo $3

#使用$@遍历所有传入的参数
#getopt
echo &quot;遍历&quot;
for param in &quot;$@&quot;
do
    echo &quot;param:$param&quot;
done
</code></pre><p><strong>执行结果</strong></p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/shell3.png" alt=""></p>
<h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><pre><code>#!/bin/bash

##标准输入输出
#0 STDIN 
#1 STDOUT 标准输出
#2 STDERR 标准错误

#永久重定向
exec 1&gt;test7
exec 2&gt;test8

#自定义输出
exec 7&gt;test9
#输出到test9中
echo &quot;cc zz&quot; &gt;&amp;7
#输出到test7中
echo &quot;cc yy&quot;

#由于找不到ff文件，所以执行这句是会出现找不到文件的错误，这句错误不会输出在屏幕上而是输出在test8中
ls -a ./ff
</code></pre><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>06.sh:</p>
<pre><code>#!/bin/bash

#函数的传参，返回值
function myfun
{
    echo $[ $1 + $2 ]
}

value=$(myfun 10 90)
echo &quot;value:$value&quot;
</code></pre><h3 id="函数引入"><a href="#函数引入" class="headerlink" title="函数引入"></a>函数引入</h3><p>08.sh:</p>
<pre><code>#!/bin/bash
#函数库

function add()
{
    echo $[ $1 + $2 ]
}
</code></pre><p>07.sh:</p>
<pre><code>#!/bin/bash

#引入./08.sh
#source ./08.sh
#.表示source的快捷别名
. ./08.sh

function myfun()
{
    echo $value
}

value=20
myfun

echo &quot;add value:$(add 10 30)&quot;
</code></pre><h2 id="ffmpeg编译脚本"><a href="#ffmpeg编译脚本" class="headerlink" title="ffmpeg编译脚本"></a>ffmpeg编译脚本</h2><p>通过shell脚本的学习来编写一个ffmpeg的编译脚本</p>
<p>build_android.sh：</p>
<pre><code>#!/bin/bash

#export表示全局变量，多个shell脚本都可以使用
export ANDROID_NDK_HOME=/usr/ndk/android-ndk-r10e
export PLATFORM_VERSION=android-9

function build_ffmpeg
{
    echo &quot;start build ffmpeg $ARCH&quot;
    #./configure表示执行configure文件，后面一系列的是传入的参数
    ./configure --target-os=linux \
    --prefix=$PREFIX \
    --arch=$ARCH \
    --enable-shared \
    --disable-static \
    --disable-yasm \
    --disable-ffmpeg \
    --disable-ffplay \
    --disable-ffprobe \
    --disable-ffserver \
    --disable-doc \
    --enable-cross-compile \
    --cross-prefix=$CROSS_COMPILE \
    --sysroot=$PLATFORM \
    --extra-cflags=&quot;-fpic&quot;
    make clean
    make
    make install

    echo &quot;build finished $ARCH&quot;
}

#exec 1&gt;jason_build_stdout.txt
#exec 2&gt;jason_build_stdout.txt
#arm
ARCH=arm
CPU=arm
PREFIX=$(pwd)/android/$CPU
TOOLCHAIN=$ANDROID_NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64
CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-
PLATFORM=$ANDROID_NKD_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH
build_ffmpeg

#x86
ARCH=x86
CPU=x86
PREFIX=$(pwd)/android/$CPU
TOOLCHAIN=$ANDROID_NDK_HOME/toolchains/x86-4.9/prebuilt/linux-x86_64
CROSS_COMPILE=$TOOLCHAIN/bin/i686-linux-android-
PLATFORM=$ANDROID_NKD_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH
build_ffmpeg
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/01/FFmpeg学习系列-三-Linux之shell脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/01/FFmpeg学习系列-三-Linux之shell脚本/" itemprop="url">
                  FFmpeg学习系列(三)Linux之shell脚本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-01T10:00:41+08:00">
                2017-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>为什么使用shell脚本？</p>
<p>当命令比较复杂的时候，就需要专门写一个脚本文件。</p>
<p>脚本举例：</p>
<pre><code>#下面两个是命令可直接执行
date
who

#!/bin/bash
#创建变量，如果是字符串的话，有空格的一定要用双引号，否则会被解析成命令                                                                 
NDK=10
text=&quot;i love shell&quot;

#命令的执行结果的输出作为变量的值，其中下面的 ` 是键盘中英文状态下的ESC下面那个键
text1=`date`
text2=$(who)

echo $NDK
echo $text
#字符串拼接，同理：有空格需要用双引号
echo &quot;$text very much&quot;
#\转义字符
echo &quot;\$NDK&quot;
echo $text1
echo $text2
</code></pre><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><p>输出重定向:</p>
<pre><code>命令的执行结果输出到test.txt文件，不再输出到屏幕上
ls -al &gt; test.txt
</code></pre><p><img src="http://oph0qv0je.bkt.clouddn.com/shell1.png" alt=""></p>
<p>输入重定向:</p>
<pre><code>wc命令是输出test.txt文本中的行数，单词数，字节数,显示在屏幕上
wc &lt; test.txt
</code></pre><p><img src="http://oph0qv0je.bkt.clouddn.com/shell2.png" alt=""></p>
<p>wc命令在命令行中的使用</p>
<pre><code>wc &lt;&lt; EOF 然后输入一些文本，最后输入一个EOF结束
</code></pre><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><pre><code>#1、使用命令，输出的结果作为c的值
#注意除号左右两边要有空格
c=$(expr $b / $a)
#2、使用方括号运算符代替expr命令
d=$[$b/$a]

echo &quot;c:$c&quot;
echo &quot;d:$d&quot;
</code></pre><h3 id="浮点数的处理"><a href="#浮点数的处理" class="headerlink" title="浮点数的处理"></a>浮点数的处理</h3><p>基本运算不支持浮点数，为了支持浮点数，需要用bc命令：</p>
<pre><code>a=10
e=$(echo &quot;scale=4; $a / 3&quot; | bc)
echo &quot;e:$e&quot;
</code></pre><p>其中|是管道的意思，一个命令的输出作为另外一个命令的输入。</p>
<p>scale是自带的内建变量:</p>
<pre><code>#内联输入重定向，多次运算的时候
f=$(bc &lt;&lt; EOF
scale=4
a1=($a * $b)
a1 / 3
EOF
)
</code></pre><h2 id="命令执行退出的状态："><a href="#命令执行退出的状态：" class="headerlink" title="命令执行退出的状态："></a>命令执行退出的状态：</h2><pre><code>0 成功
127 没有找到命令
1 未知错误
126 命令不可执行
</code></pre><p>查看与退出状态指定：</p>
<pre><code>查看上一次命令的执行状态
echo $?

在shell脚本中，自己指定退出的状态
exit 状态码
</code></pre><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>只有if命令的退出状态码为0，才会执行then部分</p>
<pre><code>if 命令
then 
   命令
fi
</code></pre><p>if语句举例：</p>
<pre><code>#!/bin/bash
testuser=lady
#查找passwd里面是否有对应的目录
if grep $testuser /etc/passwd 
then
    echo &quot;ok&quot;
    ls -a /home/$testuser/
#如果passwd中没有目录，再判断是否有这个目录
elif ls -d /home/$testuser
then
    echo &quot;用户不存在，主目录仍然存在&quot;
#其他情况    
else
    #可以继续嵌套if
    #if 
    #then
    echo &quot;$testuser not exist&quot;
fi
</code></pre><p>grep命令是查找命令</p>
<p>可以结合test命令，如果条件成立，test命令以状态为0退出，if条件成立。</p>
<p>test命令简单形式，用中括号，注意空格要加上，举例如下：</p>
<pre><code>#!/bin/bash
a=10
b=5
#test命令简单形式
if [ $a -gt $b ]
then
    echo &quot;$a greater than $b&quot;
else
    echo &quot;$a smaller than $b&quot;
fi
</code></pre><p><strong>test数值比较：</strong></p>
<pre><code>-gt
-eq 等于
-le 
-ne 不等于
</code></pre><p>判空：</p>
<pre><code>#!/bin/bash
str1=&quot;&quot;
if [ str1 = &quot;&quot; ]                                                            
then
    echo &quot;有内容&quot;
else
    echo &quot;没内容&quot;
fi
</code></pre><p><strong>test字符串比较：</strong></p>
<pre><code>str1 == str2
str1 != str2
str1 &lt; str2
-n str1 长度是否非0
-z str1 长度是否为0
</code></pre><p><strong>test文件比较：</strong></p>
<pre><code>-d 检查是否存在，并且是一个目录
-e 检查file是否存在
-f 检查是否存在，并且是一个文件
-r 检查是否存在，并且可读
-w、-x
file1 -nt file2 file1比file2新
file1 -ot file2 file1比file2旧
</code></pre><p>举例：</p>
<pre><code>#!/bin/bash
mydir=/usr/jason
#-d检查目录是否存在
if [ -d $mydir ]
then
    echo &quot;$mydir exist&quot;
    cd $mydir
    ls
else
    echo &quot;mydir not exist&quot;
fi
</code></pre><p>多个条件的时候：</p>
<pre><code>#!/bin/bash
#多个条件 []
mydir=/usr/jason/shell
#任意数学赋值或者比较表达式
#if (( a++ &gt; 90 ))
if [ -d $HOME ] &amp;&amp; [ -w $mydir ]
then
    cd $mydir
    touch test5
else
    echo &quot;no&quot;
fi
</code></pre><h2 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h2><p>格式：</p>
<pre><code>case 变量 in
pattern1) 命令;;
pattern2) 命令;;
*) 默认命令;;
esac
</code></pre><p>举例：</p>
<pre><code>#!/bin/bash
testuser=rose

case $testuser in
rose)
    echo &quot;hi,$testuser&quot;;;
ricky)
    echo &quot;hello, ricky&quot;;;
*)
    echo &quot;defaults&quot;;;
esac
</code></pre><h2 id="for循环命令"><a href="#for循环命令" class="headerlink" title="for循环命令"></a>for循环命令</h2><p>格式：</p>
<pre><code>for var in list
do
    命令
done  
</code></pre><p>举例1：</p>
<pre><code>#!/bin/bash

for item in 1 2 3 4 5
do
    echo $item
done
</code></pre><p>举例2：</p>
<pre><code>#使用字符串的时候一定要注意转义字符，\#、\&apos;等
list=&quot;windows--linux--macos&quot;
#IFS字段分隔符
IFS=$--
for item in $list
do
    echo $item
done
</code></pre><h2 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a>while命令</h2><p>格式：</p>
<pre><code>while test command（或者[]）
do
    命令
done
</code></pre><p>举例：</p>
<pre><code>#!/bin/bash

a=10
while [ $a -gt 0 ]
do
    echo &quot;num:$a&quot;
    #赋值不用使用$符号
    a=$[ $a - 1 ]
    if [ $a -eq 5 ]
    then
        echo &quot;break&quot;
        break
    fi
done
</code></pre><p><strong>注意：</strong></p>
<p><strong>编译ffmpeg</strong></p>
<p><strong>编写shell脚本之前，要执行./configure –disable-yasm，主要目的进行一系列的准备工作，比如说检查gcc的版本，会生成config.mak等文件</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/FFmpeg学习系列-二-Linux基本命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/27/FFmpeg学习系列-二-Linux基本命令/" itemprop="url">
                  FFmpeg学习系列(二)Linux基本命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T13:45:49+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux相关命令"><a href="#Linux相关命令" class="headerlink" title="Linux相关命令"></a>Linux相关命令</h2><p>清空命令行：reset</p>
<p>文件操作：</p>
<pre><code>显示列表

ls -l 
ls -la 所有
ls -l ja* 通配符查找
</code></pre><p>创建目录：</p>
<pre><code>mkdir 目录名字
</code></pre><p>创建文件</p>
<pre><code>touch today.c
</code></pre><p>复制文件</p>
<pre><code>cp src.txt dest.txt
cp -i src.txt dest.txt 询问
cp src.txt . 复制到当前目录
cp -R 目录 dest 复制整个目录到指定路径
cp c_?1 ../  通配符复制到上级目录
</code></pre><p>删除文件</p>
<pre><code>rm file.txt
</code></pre><p>删除目录</p>
<pre><code>rm -rf 目录
</code></pre><p>查看文件类型：</p>
<pre><code>file src.txt
</code></pre><p>查看文件内容：</p>
<pre><code>cat src.txt
cat -n src.txt 显示行号
</code></pre><p>查看文件最后10行</p>
<pre><code>tail -n 10 src.txt
</code></pre><p>查看文件最开始的10行</p>
<pre><code>head -n 10 src.txt
</code></pre><p>安装与卸载软件</p>
<pre><code>sudo apt-get install vim-gtk
sudo apt remove vim
</code></pre><p>创建用户</p>
<pre><code>useradd -m jack 创建用户的同时，创建了home目录
userdel -r jack 删除用户
</code></pre><p>切换用户 </p>
<pre><code>su jack
</code></pre><p>修改用户密码</p>
<pre><code>sudo passwd 123456abc
</code></pre><p>退出</p>
<pre><code>exit
</code></pre><p>创建组</p>
<pre><code>groupadd androidgroup
</code></pre><p>分配用户到组</p>
<pre><code>usermod -G androidgroup jack
</code></pre><p>文件权限</p>
<pre><code>r读 w写 x执行
drwxr-xr-x
d rwx r-x r-x (d为目录，后面三个为一组，为一个二进制数)
d目录
这里用1,2,3表示上面三组数据的权限
1.文件所属用户具备的权限（root对该文件具备读写执行权限）
2.文件所属用户的所属组具备的权限（读、执行）
3.系统的其他用户具备的权限（读、执行）
</code></pre><p>rwx必须是固定顺序</p>
<pre><code>权限      二进制     八进制
---         000         0
--x         001         1
-w-         010         2
-wx         011         3
r--         100         4
r-x         101         5
rw-         110         6
rwx         111         7
</code></pre><p>修改文件权限</p>
<pre><code>chmod 644 file
</code></pre><p>给用户加上执行权限</p>
<pre><code>chmod u+x file
</code></pre><p>改变创建目录的默认权限：</p>
<pre><code>创建出来的权限就是 777 - 022 = 755权限
umask 022（默认是026）
</code></pre><p>改变文件的所属</p>
<pre><code>更改用户，使file文件在user用户下
chown user file
更改用户组
chown user.group file
chown .group file
</code></pre><p>每一个用户的Hmoe目录都会有bash、bashrc文件，bash、bashrc是每一个用户登录的时候会加载的文件，里面配置的是全局的配置，例如环境变量。</p>
<h2 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h2><p>vim有两种模式，命令模式、插入模式</p>
<p><strong>命令模式中的一些基本操作：</strong></p>
<ol>
<li>删除一行：dd ， 删除一个字符x</li>
<li>撤销：u，重做：ctrl+r</li>
<li>进入插入模式：i</li>
<li>翻页：ctrl + f（上一页） ctrl + b（下一页）</li>
<li>复制行：yy , 粘贴：p</li>
<li>文本搜索： ?正则enter 搜索n或者N控制方向</li>
<li>保存： :w</li>
<li>保存退出： :wq</li>
<li>不保存强制退出： q!</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/FFmpeg学习系列-一-Linux下编译FFmpeg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/21/FFmpeg学习系列-一-Linux下编译FFmpeg/" itemprop="url">
                  FFmpeg学习系列(一)Linux下编译FFmpeg
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T14:48:55+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在android中进行FFmpeg开发时，我们需要用到编译好的.so库，这些.so需要在Linux环境下进行编译。</p>
<h2 id="Linux下编译FFmpeg步骤"><a href="#Linux下编译FFmpeg步骤" class="headerlink" title="Linux下编译FFmpeg步骤"></a>Linux下编译FFmpeg步骤</h2><p><strong>1.如果不是Linux操作系统，需要购买阿里云主机，镜像可以选择ubuntu 14.04 64位。</strong></p>
<p><strong>2.安装XShell（内含Xftp）、Xftp来对服务器进行操作、文件传输</strong></p>
<p>需要配置Xshell来连接阿里云服务器：</p>
<p>点击XShell客户端 文件-&gt;打开，弹出会话对话框，点击 “新建”，在对话框中填写“名称”（可随便起一个），主机处填写公网地址点击确认进行连接，然后填写用户，密码。</p>
<p>连接成功之后，点击Xshell客户端的“新建文件传输”，弹出Xftp,一般在usr下新建一个ndk文件，把我们的ndk拖入ndk文件中。</p>
<p><strong>3.安装VIM</strong>  sudo apt-get install vim-gtk</p>
<p>安装后如果输入vim不能使用,提示No such file or directory, 更新一下apt-get update</p>
<p>3.1通过vim编辑一个文本：</p>
<pre><code>vim isen.txt 进入命令模式。
</code></pre><p>在命令模式退出：</p>
<pre><code>按shift + :，输入q!强制退出（不保存退出）

保存退出,shift + z z
</code></pre><p>命令模式进入编辑模式：</p>
<pre><code>按i键
</code></pre><p>编辑模式退出进入命令模式：</p>
<pre><code>按Esc键
</code></pre><p>在命令模式中：</p>
<pre><code>x删除，dd删除行
</code></pre><p><strong>4.vim配置(高亮显示，行号之类的)</strong></p>
<p>一般vim正常安装在/etc/vim/中。</p>
<pre><code>通过vim打开vimrc

vim /etc/vim/vimrc

在末尾添加如下命令
set nu
set tabstop
set cursorline
set ruler
</code></pre><p><strong>5.NDK安装</strong></p>
<p>cd进入ndk目录中，输入ls命令</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/linux_ndk.png" alt=""></p>
<p>发现ndk字体是白色的，表示没有权限不可执行，绿色表示可执行，我们需要给权限让其可执行</p>
<pre><code>目录给权限：chmod 777 -R ndk
其中-R代表ndk是一个目录
</code></pre><p><img src="http://oph0qv0je.bkt.clouddn.com/linux_ndk2.png" alt=""></p>
<p>ndk目录为绿色可执行。</p>
<pre><code>解压ndk：./android-ndk-r10e-linux-x86_64.bin 
</code></pre><p>环境变量配置：</p>
<pre><code>命令vim ~/.bashrc
添加：
export NDKROOT=/usr/ndk/android-ndk-r10e
export PATH=$NDKROOT:$PATH
</code></pre><p>更新环境变量：</p>
<pre><code>source ~/.bashrc
</code></pre><p><strong>6.准备FFmpeg</strong></p>
<p>我们需要去FFmpeg官网下载FFmpeg的Linux源码，版本不需要太新：</p>
<pre><code>ffmpeg-2.6.9.zip
</code></pre><p>然后执行解压缩命令：</p>
<pre><code>unzip ffmpeg-2.6.9.zip
</code></pre><p><strong>7.编译FFmpeg</strong></p>
<p>我们需要编写shell脚本传参调用ffmpeg-2.6.9下的configure脚本进行编译。</p>
<p>1）编写shell脚本文件build_android.sh：</p>
<pre><code>#!/bin/bash
make clean
export NDK=/usr/ndk/android-ndk-r10e
export SYSROOT=$NDK/platforms/android-9/arch-arm/
export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64
export CPU=arm
export PREFIX=$(pwd)/android/$CPU
export ADDI_CFLAGS=&quot;-marm&quot;

./configure --target-os=linux \
--prefix=$PREFIX --arch=arm \
--disable-doc \
--enable-shared \
--disable-static \
--disable-yasm \
--disable-symver \
--enable-gpl \
--disable-ffmpeg \
--disable-ffplay \
--disable-ffprobe \
--disable-ffserver \
--disable-doc \
--disable-symver \
--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \
--enable-cross-compile \
--sysroot=$SYSROOT \
--extra-cflags=&quot;-Os -fpic $ADDI_CFLAGS&quot; \
--extra-ldflags=&quot;$ADDI_LDFLAGS&quot; \
$ADDITIONAL_CONFIGURE_FLAG
make clean
make
make install
</code></pre><p>shell脚本中指定NDK的一些路径（export NDK=/usr/ndk/android-ndk-r10e），配置CPU架构类型（export CPU=arm），PREFIX是指定动态库输出的路径，然后disable一些不需要的库（可减小输出的动态库的大小）等等。enable-shared是生成共享库的意思。</p>
<p>关于shell脚本需要注意：</p>
<ol>
<li><p>换行的时候需要有\，注意不要有额外的空格，否则编译出错</p>
</li>
<li><p>脚本文件统一转为UTF-8无BOM格式。可以通过note pad++进行转码，这样子Windows和Linux都通用了。也可以通过dos2unix命令进行转码后在Linux中使用。或者先由Linux创建文件再由Windows编辑。</p>
</li>
<li><p>NDK尽量不要使用太新的版本，一般使用Android-9即可。新版本会出现不兼容的问题，比如LOG2的问题等等。</p>
</li>
</ol>
<p>2）将编写好的shell脚本放在解压后的ffmpeg-2.6.9文件夹中。</p>
<pre><code>然后ffmpeg-2.6.9文件给权限
chmod 777 -R ffmpeg-2.6.9
</code></pre><p>3) cd进入ffmpeg-2.6.9文件夹中</p>
<pre><code>执行 ./android_build.sh
</code></pre><p>如果出现问题bad interpreter : No such file or directory,需要将文件转成Linux编码格式<br>有两种方式：</p>
<pre><code>1，在Linux下创建这个文件touch android_build.sh，从Linux传出到桌面把脚本命令拷入这个文件中，在上传上Linux中去给权限就可以啦

2，使用 dos2unix android_build.sh 转成Linux编码格式
</code></pre><p><strong>8.编译完成之后生成如下动态库：</strong></p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ffmpeg_so.png" alt=""></p>
<p>我们可以看到生成的有.56,.5之类的库，对于这种库android很难加载到，因此要把这个名字加载到前面，以.so结尾，因此，我们需要修改configure文件。</p>
<p><strong>9.修改configure文件</strong></p>
<p>ffmpeg-2.6.9根目录下有个configure文件，这个文件比较重要，通过这个文件我们可以看到FFmpeg库之间的依赖关系。我们自己写的脚本文件就是依据这个文件来写的。</p>
<p>这里我们需要修改一下输出的动态库的命名规则：</p>
<pre><code>#修改前
#SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;
#LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;
#SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;
#SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;
#修改后
SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;
LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;
SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;
SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;
</code></pre><p>然后进行重新编译，生成动态库如下：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ffmpeg_so2.png" alt=""></p>
<p>我们就可以在我们的android项目中应用这些库啦（使用的时候我们用大版本号的.so库）。</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/big_version.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/18/C++学习系列-六-IO与STL标准模板库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/18/C++学习系列-六-IO与STL标准模板库/" itemprop="url">
                  C++学习系列(六)IO与STL标准模板库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-18T11:50:11+08:00">
                2017-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-的IO操作"><a href="#C-的IO操作" class="headerlink" title="C++的IO操作"></a>C++的IO操作</h2><p>文本文件操作</p>
<pre><code>void main(){
    char* fname = &quot;c://dest.txt&quot;;
    //输出流
    ofstream fout(fname);
    //创建失败
    if (fout.bad()){ //文件打开失败
        return;
    }

    fout &lt;&lt; &quot;jack&quot; &lt;&lt; endl;
    fout &lt;&lt; &quot;rose&quot; &lt;&lt; endl;

    //关闭
    fout.close();

    //读取
    ifstream fin(fname);
    if (fin.bad()){
        return;
    }
    char ch;
    while (fin.get(ch)){
        //输出
        cout &lt;&lt; ch;
    }
    fin.close();

    system(&quot;pause&quot;);
}
</code></pre><p>二进制文件操作</p>
<pre><code>void main(){
    char* src = &quot;c://src.jpg&quot;;
    char* dest = &quot;c://dest.jpg&quot;;

    //输入流
    ifstream fin(src, ios::binary);
    //输出流
    ofstream fout(dest, ios::binary);

    if (fin.bad() || fout.bad()){
        return;
    }

    while (!fin.eof()){
        //读取
        char buff[1024] = {0};
        fin.read(buff,1024);

        //写入
        fout.write(buff,1024);
    }

    //关闭
    fin.close();
    fout.close();

    system(&quot;pause&quot;);
}
</code></pre><p>C++对象的持久化</p>
<pre><code>class Person
{
public:
    Person()
    {

    }
    Person(char * name, int age)
    {
        this-&gt;name = name;
        this-&gt;age = age;
    }
    void print()
    {
        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;
    }
private:
    char * name;
    int age;
};


void main()
{
    Person p1(&quot;柳岩&quot;, 22);
    Person p2(&quot;rose&quot;, 18);
    //输出流
    ofstream fout(&quot;c://c_obj.data&quot;, ios::binary);
    fout.write((char*)(&amp;p1), sizeof(Person)); //指针能够读取到正确的数据，读取内存区的长度
    fout.write((char*)(&amp;p2), sizeof(Person));
    fout.close();

    //输入流
    ifstream fin(&quot;c://c_obj.data&quot;, ios::binary);
    Person tmp;
    fin.read((char*)(&amp;tmp), sizeof(Person));
    tmp.print();

    fin.read((char*)(&amp;tmp), sizeof(Person));
    tmp.print();

    system(&quot;pause&quot;);

}
</code></pre><h2 id="C-中STL"><a href="#C-中STL" class="headerlink" title="C++中STL"></a>C++中STL</h2><p>STL:standard template library 标准模板库，类似于Java中的util工具集等。</p>
<pre><code>#include &lt;string&gt;
void main()
{
    string s1 = &quot;craig david&quot;;
    string s2(&quot; 7 days&quot;);
    string s3 = s1 + s2;

    cout &lt;&lt; s3 &lt;&lt; endl;

    //转c字符串
    const char* c_str = s3.c_str();
    cout &lt;&lt; c_str &lt;&lt; endl;

    //s1.at(2);


    system(&quot;pause&quot;);
}
</code></pre><p>这里的是c++中的string，在jni开发时，需要先将c++中的string转为c的string，再转换成Java的string。</p>
<pre><code>//容器
#include &lt;vector&gt;

void main()
{
    //动态数组
    //不需要使用动态内存分配，就可以使用动态数组
    vector&lt;int&gt; v;
    v.push_back(12);
    v.push_back(10);
    v.push_back(5);

    for (int i = 0; i &lt; v.size(); i++)
    {
        cout &lt;&lt; v[i] &lt;&lt; endl;
    }

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/11/C++学习系列-五-C++中的类型转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/11/C++学习系列-五-C++中的类型转换/" itemprop="url">
                  C++学习系列(五)C++中的类型转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-11T09:11:34+08:00">
                2017-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h2><p>类型转换分类：</p>
<ol>
<li>static_cast 普遍情况（一般的数据类型转换等）。</li>
<li>const_cast 去常量。</li>
<li>dynamic_cast 子类类型转为父类类型。</li>
<li>reinterpret_cast 函数指针转型，不具备移植性。</li>
</ol>
<p>对于原始类型转换来说，所有情况都是一种写法，可读性不高，有可能有潜在的风险。</p>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>一般用于类型转换：</p>
<pre><code>//void*表示这个函数有可能返回不同类型的指针
void* func(int type){    
    switch (type){
    case 1:    {
                int i = 9;
                return &amp;i;
    }
    case 2:    {
                int a = &apos;X&apos;;
                return &amp;a;
    }
    default:{
                return NULL;
    }

    }    
}

void func2(char* c_p){
    cout &lt;&lt; *c_p &lt;&lt; endl;
}    

void main(){    
    //int i = 0;
    //自动转换
    //double d = i;
    //double d = 9.5;
    //int i = d;

    //int i = 8;
    //double d = 9.5;
    //i = static_cast&lt;int&gt;(d);

    //void* -&gt; char*
    //char* c_p = (char*)func(2);
    //char* c_p = static_cast&lt;char*&gt;(func(2));

    //C++ 意图明显
    func2(static_cast&lt;char*&gt;(func(2)));
    //C
    func2((char*)(func(2)));

    system(&quot;pause&quot;);
}
</code></pre><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>去除常量：</p>
<pre><code>void func(const char c[]){
    //c[1] = &apos;a&apos;;
    //通过指针间接赋值
    //其他人并不知道，这次转型是为了去常量
    //char* c_p = (char*)c;
    //c_p[1] = &apos;X&apos;;
    //提高了可读性
    char* c_p = const_cast&lt;char*&gt;(c);
    c_p[1] = &apos;Y&apos;;

    cout &lt;&lt; c &lt;&lt; endl;
}

void main(){
    char c[] = &quot;hello&quot;;
    func(c);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>用于继承关系中，父类、子类的转换：</p>
<pre><code>class Person{
public:
    virtual void print(){
        cout &lt;&lt; &quot;人&quot; &lt;&lt; endl;
    }
};

class Man : public Person{
public:
    void print(){
        cout &lt;&lt; &quot;男人&quot; &lt;&lt; endl;
    }

    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
};


class Woman : public Person{
public:
    void print(){
        cout &lt;&lt; &quot;女人&quot; &lt;&lt; endl;
    }

    void carebaby(){
        cout &lt;&lt; &quot;生孩子&quot; &lt;&lt; endl;
    }
};

void func(Person* obj){    

    //调用子类的特有的函数，转为实际类型
    //c的写法
    //并不知道转型失败
    //Man* m = (Man*)obj;
    //m-&gt;print();

    //C++的写法
    //转型失败，返回NULL
    Man* m = dynamic_cast&lt;Man*&gt;(obj);    
    if (m != NULL){
        m-&gt;chasing();
    }

    Woman* w = dynamic_cast&lt;Woman*&gt;(obj);
    if (w != NULL){
        w-&gt;carebaby();
    }
}

void main(){

    //Woman w1;
    //Person *p1 = &amp;w1;

    //func(p1);

    Woman w1;
    Woman* w_p = &amp;w1;


    system(&quot;pause&quot;);
}
</code></pre><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>函数指针的转换，不经常使用：</p>
<pre><code>void func1(){
    cout &lt;&lt; &quot;func1&quot; &lt;&lt; endl;
}

char* func2(){
    cout &lt;&lt; &quot;func2&quot; &lt;&lt; endl;
    return &quot;abc&quot;;
}

typedef void(*f_p)();

void main(){
    //函数指针数组
    f_p f_array[6];
    //赋值
    f_array[0] = func1;

    //C方式
    //f_array[1] = (f_p)(func2);
    //C++方式
    f_array[1] = reinterpret_cast&lt;f_p&gt;(func2);

    f_array[1]();

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Feng" />
          <p class="site-author-name" itemprop="name">Feng</p>
           
              <p class="site-description motion-element" itemprop="description">每天一小步，人生一大步</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
