<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="每天一小步，人生一大步">
<meta property="og:type" content="website">
<meta property="og:title" content="Feng's Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Feng's Notes">
<meta property="og:description" content="每天一小步，人生一大步">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feng's Notes">
<meta name="twitter:description" content="每天一小步，人生一大步">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Feng's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Feng's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/05/FFmpeg学习系列-六-Linux之POSIX线程原语/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/FFmpeg学习系列-六-Linux之POSIX线程原语/" itemprop="url">
                  FFmpeg学习系列(六)Linux之POSIX线程原语
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-05T10:16:59+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>POSIX是一种标准，有多线程编程标准、网络编程标准等。</p>
<h3 id="POSIX多线程"><a href="#POSIX多线程" class="headerlink" title="POSIX多线程"></a>POSIX多线程</h3><p>Linux下，一般多线程的实现由POSIX多线程编程实现。Android系统属于Linux系统，因此NDK原生支持POSIX多线程编程。</p>
<p>Windows平台一般用Windows自带的API。</p>
<p><strong>POSIX的编译：</strong></p>
<p>在Linux平台中采用gcc编译（先编译生成目标文件然后链接生成可执行程序）：gcc test.c -o test -lpthread，执行：./test。</p>
<p><strong>POSIX帮助文档的查看：</strong></p>
<ol>
<li>在Linux系统中，安装POSIX帮助文档：sudo apt-get install manpages-posix-dev</li>
<li>列出所有函数man -k pthread；查看某个函数：man pthread_create</li>
</ol>
<h2 id="创建线程与结束线程"><a href="#创建线程与结束线程" class="headerlink" title="创建线程与结束线程"></a>创建线程与结束线程</h2><p>01.c:</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
//必须引入的头文件
#include &lt;pthread.h&gt;

//一个相当于Java的run方法
void* thr_fun(void* arg){

    //得到线程创建的参数
    char* no = (char*)arg;
    int i = 0;
    for(; i &lt; 10; i++){
        printf(&quot;%s thread, i:%d\n&quot;,no,i);
        if(i==5){
            //线程退出（自杀）
            pthread_exit(2);
            //他杀pthread_cancel          
        }
    }  
    //run方法执行完，线程结束，返回 
    return 1;
}

void main(){
    printf(&quot;main thread\n&quot;);
    //线程id
    pthread_t tid;
    //线程的属性，NULL默认属性
    //thr_fun，线程创建之后执行的函数,可以传入参数，在thr_fun方法的arg中可以取出
    pthread_create(&amp;tid,NULL,thr_fun,&quot;1&quot;);
    void* rval;
    //等待tid线程结束
    //thr_fun在线程退出时传入的参数，都作为第二个参数的内容
    pthread_join(tid,&amp;rval);
    printf(&quot;rval:%d\n&quot;,(int)rval);
}
</code></pre><p>书写完成编译gcc 01.c -o 01 -lpthread，执行./01,输出结果如下：</p>
<pre><code>main thread
1 thread,i:0
1 thread,i:1
1 thread,i:2
1 thread,i:3
1 thread,i:4
1 thread,i:5
rval:2
</code></pre><p>在代码中：</p>
<p>通过pthread_create创建线程，需要传入一个函数指针，相当于Java线程中的run方法。然后还需要传参，参数可以在run方法中取出。</p>
<p>线程被创建以后，就会执行“run”方法，该方法中可以拿到线程创建的参数，可以自杀掉线程。线程的结束需要参数。</p>
<p>可以通过pthread_join方法等待线程结束，并且可获取线程结束的参数。</p>
<h2 id="线程加锁"><a href="#线程加锁" class="headerlink" title="线程加锁"></a>线程加锁</h2><p>在多线程中我们需要一个线程执行完再执行另一个线程就需要给线程加锁。</p>
<p>02.c:</p>
<pre><code>#include &lt;stdlib.h&gt;                                                         
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

int i = 0;
//互斥锁
pthread_mutex_t mutex;

void* thr_fun(void* arg){
    //加锁
    pthread_mutex_lock(&amp;mutex);
    char* no = (char*)arg;
    for(;i &lt; 5; i++){
        printf(&quot;%s thread, i:%d\n&quot;,no,i);
        sleep(1);
    }
    i=0;
    //解锁
    pthread_mutex_unlock(&amp;mutex);
}

void main(){
    pthread_t tid1, tid2;
    //初始化互斥锁
    pthread_mutex_init(&amp;mutex,NULL);

    pthread_create(&amp;tid1,NULL,thr_fun,&quot;No1&quot;);
    pthread_create(&amp;tid2,NULL,thr_fun,&quot;No2&quot;);

    pthread_join(tid1,NULL);
    pthread_join(tid2,NULL);

    //销毁互斥锁
    pthread_mutex_destroy(&amp;mutex);
}
</code></pre><p>书写完成编译gcc 02.c -o 02 -lpthread，执行./02,输出结果如下：</p>
<pre><code>No2 thread, i:0
No2 thread, i:1
No2 thread, i:2
No2 thread, i:3
No2 thread, i:4
No1 thread, i:0
No1 thread, i:1
No1 thread, i:2
No1 thread, i:3
No1 thread, i:4
</code></pre><p>在代码中：</p>
<p>我们通过pthread_mutex_init初始化了一把互斥锁，最后通过pthread_mutex_destroy进行销毁。</p>
<p>在线程执行的时候，我们可以通过pthread_mutex_lock、pthread_mutex_unlock进行加锁和解锁。</p>
<p>使用互斥锁可以解决线程死锁（ABBA）的问题。</p>
<p>互斥锁是先让一个线程做完，然后另外一个线程做。还有一种情况就是，一个线程先执行生产，然后另外一个线程就会去消费。</p>
<p>其实视频解码的绘制使用的就是生产者–消费者的模式。图片的下载显示也是基于这种模式。比如说我们生产者生成的产品，放到一个队列里面，当生产者生产出产品的时候就会发送信号通知消费者去消费，例如RTMP推流的时候，我们本地采集音视频的时候就需要一种队列，因为本地的压缩比网络上传要快。</p>
<p>使用这一种模式，就需要条件变量。举例：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

//模拟产品队列
int productNum = 0;

//互斥锁
pthread_mutex_t m;
//条件变量
pthread_cond_t c;

void *produce(void* arg){

    char* no = (char*)arg;

    for (;;){
        //加锁
        pthread_mutex_lock(&amp;m);

        //生产者生产产品
        productNum++;
        printf(&quot;%s生产产品：%d\n&quot;, no, productNum);
        //通知消费者进行消费
        pthread_cond_signal(&amp;c);

        //解锁
        pthread_mutex_unlock(&amp;m);

        sleep(1);
    }
    return (void*)1;
}

void *comsume(void* arg){

    char* no = (char*)arg;

    for (;;){
        pthread_mutex_lock(&amp;m);
        //使用while是为了防止惊群效应唤醒条件变量
        while (productNum == 0){
            //1.没有产品可以消费，等待生产者生产，即等待条件变量被唤醒
            //2.释放互斥锁，使得其他消费者可以进来等待
            //3.被唤醒的时候，解除阻塞，重新申请获得互斥锁，保证只有一个消费者消费
            pthread_cond_wait(&amp;c, &amp;m);
        }
        productNum--;
        printf(&quot;%s消费者消费产品：%d\n&quot;, no, productNum);
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    }
    return (void*)1;
}

void main(){

    printf(&quot;main thread\n&quot;);

    //初始化互斥锁
    pthread_mutex_init(&amp;m, NULL);
    //初始化条件变量
    pthread_cond_init(&amp;c, NULL);

    pthread_t thread_producer;
    pthread_t thread_comsumer;
    //创建线程，指定run方法，并且可以传入参数，在run方法的arg中可以取出
    pthread_create(&amp;thread_producer, NULL, produce, &quot;producer&quot;);
    pthread_create(&amp;thread_comsumer, NULL, comsume, &quot;comsumer&quot;);

    //等待线程结束，获取线程返回参数
    pthread_join(thread_producer, NULL);
    pthread_join(thread_comsumer, NULL);

    //销毁互斥锁
    pthread_mutex_destroy(&amp;m);
    //销毁条件变量
    pthread_cond_destroy(&amp;c);
}
</code></pre><p>书写完成编译gcc 03.c -o 03 -lpthread，执行./03,输出结果如下：</p>
<pre><code>main thread
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
producer生产产品：1
comsumer消费者消费产品：0
</code></pre><p>这里我通过sleep的方式控制了生产者与消费者的效率，一般来说生产的速度要比消费的速度快。</p>
<p>上面是只有一个生产者和一个消费者的示例代码。一般来说，生产者和消费者都会有多个。这里我们通过线程数组的方式来实现。</p>
<p>举例如下：</p>
<pre><code>#include &lt;stdlib.h&gt;                                                      
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

//消费者数量
#define CONSUMER_NUM 2
//生产者数量
#define PRODUCER_NUM 1

pthread_t pids[CONSUMER_NUM+PRODUCER_NUM];

//产品队列
int ready = 0;

//互斥锁
pthread_mutex_t mutex;
//条件变量
pthread_cond_t has_product;

//生产
void* producer(void* arg){
    int no = (int)arg;
    //条件变量
    for(;;){
        pthread_mutex_lock(&amp;mutex);
        //往队列中添加产品
        ready++;
        printf(&quot;producer %d, produce product\n&quot;,no);
        //fflush(NULL);
        //通知消费者，有新的产品可以消费了
        //会阻塞输出
        pthread_cond_signal(&amp;has_product);
        printf(&quot;producer %d, singal\n&quot;,no);
        pthread_mutex_unlock(&amp;mutex);
        sleep(1);
    }
}

//消费者
void* consumer(void* arg){
    int num = (int)arg;
    for(;;){
        pthread_mutex_lock(&amp;mutex);
        //while?
        //superious wake ‘惊群效应’
        while(ready==0){
            //没有产品，继续等待
            //1.阻塞等待has_product被唤醒
            //2.释放互斥锁，pthread_mutex_unlock
            //3.被唤醒时，解除阻塞，重新申请获得互斥锁pthread_mutex_lock
            printf(&quot;%d consumer wait\n&quot;,num);
            pthread_cond_wait(&amp;has_product,&amp;mutex);
        }
        //有产品，消费产品
        ready--;
        printf(&quot;%d consume product\n&quot;,num);
        pthread_mutex_unlock(&amp;mutex);
        sleep(1);
    }
}


void main(){
    //初始化互斥锁和条件变量                                                
    pthread_mutex_init(&amp;mutex,NULL);
    pthread_cond_init(&amp;has_product,NULL);
    printf(&quot;init\n&quot;);

    int i;
    for(i=0; i&lt;PRODUCER_NUM;i++){
        //生产者线程
        printf(&quot;%d\n&quot;,i);
        pthread_create(&amp;pids[i],NULL,producer,(void*)i);
    }

    for(i=0; i&lt;CONSUMER_NUM;i++){
        //消费者线程
        pthread_create(&amp;pids[PRODUCER_NUM+i],NULL,consumer,(void*)i);
    }

    //等待
    sleep(10);
    for(i=0; i&lt;PRODUCER_NUM+CONSUMER_NUM;i++){
        pthread_join(pids[i],NULL);
    }

    //销毁互斥锁和条件变量
    pthread_mutex_destroy(&amp;mutex);
    pthread_cond_destroy(&amp;has_product);

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/04/FFmpeg学习系列-五-Makefile与Android-mk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/04/FFmpeg学习系列-五-Makefile与Android-mk/" itemprop="url">
                  FFmpeg学习系列(五)Makefile与Android.mk
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-04T15:03:53+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>Makefile 构建工具，只需通过make一句命令就可以构建一个可执行程序。相当于Maven、ANT、Gradle构建工具。</p>
<p>gcc是一个编译工具，Makefile是一个构建工具，Makefile中会用到gcc。</p>
<p>在Linux中要把test.c得到一个可执行程序，我们需要编译它，通过 gcc -c test.c 编译生成 test.o 目标文件，这个目标文件不能去执行，需要继续执行 gcc -o test test.o 得到test可执行文件 。</p>
<p>在Java中使用ANT得到apk:</p>
<p>java源文件-&gt;javac编译(相当于gcc)-&gt;class文件-&gt;通过ANT打包得到apk</p>
<p>在c中使用gcc得到可执行文件：</p>
<p>.c源文件-&gt;gcc编译-&gt;.o目标文件-&gt;链接得到二进制可执行文件</p>
<p>如图：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/shell4.png" alt=""></p>
<p>Makefile里面就是包含一系列的生成可执行程序的过程。</p>
<p>在很多C/C++开源项目中，configrue文件用来检查系统配置生成配置文件（这些配置文件会在接下来的Makefile文件中被使用到）<br>Makefile文件用来生成我们需要的动态库文件(.so)。</p>
<h3 id="为什么要写Makefile文件？"><a href="#为什么要写Makefile文件？" class="headerlink" title="为什么要写Makefile文件？"></a>为什么要写Makefile文件？</h3><p>1.当项目非常庞大时，让构建过程，自动化，简单<br>2.依赖文件比目标更新，会重建目标文件</p>
<h3 id="如何编写一个Makefile"><a href="#如何编写一个Makefile" class="headerlink" title="如何编写一个Makefile"></a>如何编写一个Makefile</h3><p>假设一个项目中有<br>plus.c<br>minus.c<br>multi.c<br>divi.c<br>main.c五个.c文件。</p>
<p>我们需要：</p>
<p>.c -&gt; .o目标文件</p>
<p>.o -&gt; 打包myapp，可执行文件</p>
<p>开始编写Makefile文件：</p>
<pre><code>#编写文件需要三要素
#目标，依赖，命令

#myapp目标（最终目标，第一行是最终目标）
#:后的文件，这些都是依赖
#命令TAB键开头，如何由依赖文件得到目标
#step 1（复杂繁琐）
#myapp:main.o plus.o minus.o multi.o divi.o
#    gcc main.o plus.o minus.o multi.o divi.o -o myapp

#目标：main.o
#依赖：main.c
#命令：gcc -c main.c
#main.o:main.c
#    gcc -c main.c
#plus.o:plus.c
#    gcc -c plus.c
#minus.o:minus.c
#    gcc -c minus.c
#multi.o:multi.c
#    gcc -c multi.c
#divi.o:divi.c
#    gcc -c divi.c

#step 2（简写）
#变量
#OBJECTS=main.o plus.o minus.o multi.o divi.o

#step 3（简单明了，最终版本）
#所有.c源文件
SOURCES=$(wildcard *.c)
#把.c后缀，替换成.o后缀即是所有.o文件
OBJECTS=$(patsubst %.c,%.o,$(SOURCES))

myapp:$(OBJECTS)
#自动化变量 $^表示所有依赖，$@表示目标
    gcc $^ -o $@

#通配符
#main.o:main.c
%.o:%.c
#gcc -c main.c -o main.o
    gcc -c $^ -o $@


#没有依赖
#clean清除所有的.o中间文件
#伪目标
.PHONY:clean

clean:
    rm -f *.o
    rm -f myapp

#---------END-------------

#Makefile中一些变量与函数的书写
#递归展开式
#可以引用还没有定义的变量，展开是引用时展开
str2=$(str1)
str1=hello

#直接展开式
#必须引用定义好了的变量，定义之后就会展开
str3 := android
str4 := $(str3)
str5 := $(str1) world

#变量的值追加
str5 += hello

#自定义函数
myfun=$2 $1
#变量等于函数的执行结构
myfun_ret=$(call myfun,20,10)

test:
    @echo $(SOURCES)
    @echo $(OBJECTS)
    @echo $(str2)
    @echo $(str4)
    @echo $(str5)
    @echo $(myfun_ret)
    @echo $(call myfun,30,40)
</code></pre><p>Makefile文件编写完成之后直接执行make命令。</p>
<p>直接make，构建的是终极目标</p>
<p>构建非终极目标，make main.o</p>
<h3 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h3><p>在Android.mk文件中：</p>
<pre><code>调用my-dir函数，返回Android.mk文件所在的目录
LOCAL_PATH := $(call my-dir) 放在第一行，地址当前所在目录
include file Makefile可以引入其他的Makefile文件
include $(CLEAR_VARS) 编译模块时，清空LOCAL_MODULE等参数
LOCAL_MODULE 模块名称
LOCAL_SRC_FILES 编译需要的源文件
LOCAL_C_INCLUDES 需要的头文件
LOCAL_SHARED_LIBRARIES 编译需要的动态库
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/02/FFmpeg学习系列-四-Linux之shell脚本传参及ffmpeg的shell脚本编写/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/FFmpeg学习系列-四-Linux之shell脚本传参及ffmpeg的shell脚本编写/" itemprop="url">
                  FFmpeg学习系列(四)Linux之shell脚本传参及ffmpeg的shell脚本编写
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T15:55:53+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="脚本传参"><a href="#脚本传参" class="headerlink" title="脚本传参"></a>脚本传参</h2><h3 id="在执行脚本时传入参数"><a href="#在执行脚本时传入参数" class="headerlink" title="在执行脚本时传入参数"></a>在执行脚本时传入参数</h3><p><strong>举例如下：</strong></p>
<pre><code>执行脚本，后面是参数
./04.sh hello 47 90 76
</code></pre><p><strong>04.sh脚本：</strong></p>
<pre><code>#!/bin/bash
#获取文件名，basename为命令
filename=$(basename $0)
# $#内建变量，相当于系统参数
echo &quot;参数的总数：$#&quot;
echo $filename
#获取执行脚本时传入的参数
#路径
echo $0
#传入的第一个参数
echo $1
#传入的第二个参数
echo $2
echo $3

#使用$@遍历所有传入的参数
#getopt
echo &quot;遍历&quot;
for param in &quot;$@&quot;
do
    echo &quot;param:$param&quot;
done
</code></pre><p><strong>执行结果</strong></p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/shell3.png" alt=""></p>
<h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><pre><code>#!/bin/bash

##标准输入输出
#0 STDIN 
#1 STDOUT 标准输出
#2 STDERR 标准错误

#永久重定向
exec 1&gt;test7
exec 2&gt;test8

#自定义输出
exec 7&gt;test9
#输出到test9中
echo &quot;cc zz&quot; &gt;&amp;7
#输出到test7中
echo &quot;cc yy&quot;

#由于找不到ff文件，所以执行这句是会出现找不到文件的错误，这句错误不会输出在屏幕上而是输出在test8中
ls -a ./ff
</code></pre><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>06.sh:</p>
<pre><code>#!/bin/bash

#函数的传参，返回值
function myfun
{
    echo $[ $1 + $2 ]
}

value=$(myfun 10 90)
echo &quot;value:$value&quot;
</code></pre><h3 id="函数引入"><a href="#函数引入" class="headerlink" title="函数引入"></a>函数引入</h3><p>08.sh:</p>
<pre><code>#!/bin/bash
#函数库

function add()
{
    echo $[ $1 + $2 ]
}
</code></pre><p>07.sh:</p>
<pre><code>#!/bin/bash

#引入./08.sh
#source ./08.sh
#.表示source的快捷别名
. ./08.sh

function myfun()
{
    echo $value
}

value=20
myfun

echo &quot;add value:$(add 10 30)&quot;
</code></pre><h2 id="ffmpeg编译脚本"><a href="#ffmpeg编译脚本" class="headerlink" title="ffmpeg编译脚本"></a>ffmpeg编译脚本</h2><p>通过shell脚本的学习来编写一个ffmpeg的编译脚本</p>
<p>build_android.sh：</p>
<pre><code>#!/bin/bash

#export表示全局变量，多个shell脚本都可以使用
export ANDROID_NDK_HOME=/usr/ndk/android-ndk-r10e
export PLATFORM_VERSION=android-9

function build_ffmpeg
{
    echo &quot;start build ffmpeg $ARCH&quot;
    #./configure表示执行configure文件，后面一系列的是传入的参数
    ./configure --target-os=linux \
    --prefix=$PREFIX \
    --arch=$ARCH \
    --enable-shared \
    --disable-static \
    --disable-yasm \
    --disable-ffmpeg \
    --disable-ffplay \
    --disable-ffprobe \
    --disable-ffserver \
    --disable-doc \
    --enable-cross-compile \
    --cross-prefix=$CROSS_COMPILE \
    --sysroot=$PLATFORM \
    --extra-cflags=&quot;-fpic&quot;
    make clean
    make
    make install

    echo &quot;build finished $ARCH&quot;
}

#exec 1&gt;jason_build_stdout.txt
#exec 2&gt;jason_build_stdout.txt
#arm
ARCH=arm
CPU=arm
PREFIX=$(pwd)/android/$CPU
TOOLCHAIN=$ANDROID_NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64
CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-
PLATFORM=$ANDROID_NKD_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH
build_ffmpeg

#x86
ARCH=x86
CPU=x86
PREFIX=$(pwd)/android/$CPU
TOOLCHAIN=$ANDROID_NDK_HOME/toolchains/x86-4.9/prebuilt/linux-x86_64
CROSS_COMPILE=$TOOLCHAIN/bin/i686-linux-android-
PLATFORM=$ANDROID_NKD_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH
build_ffmpeg
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/01/FFmpeg学习系列-三-Linux之shell脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/01/FFmpeg学习系列-三-Linux之shell脚本/" itemprop="url">
                  FFmpeg学习系列(三)Linux之shell脚本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-01T10:00:41+08:00">
                2017-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>为什么使用shell脚本？</p>
<p>当命令比较复杂的时候，就需要专门写一个脚本文件。</p>
<p>脚本举例：</p>
<pre><code>#下面两个是命令可直接执行
date
who

#!/bin/bash
#创建变量，如果是字符串的话，有空格的一定要用双引号，否则会被解析成命令                                                                 
NDK=10
text=&quot;i love shell&quot;

#命令的执行结果的输出作为变量的值，其中下面的 ` 是键盘中英文状态下的ESC下面那个键
text1=`date`
text2=$(who)

echo $NDK
echo $text
#字符串拼接，同理：有空格需要用双引号
echo &quot;$text very much&quot;
#\转义字符
echo &quot;\$NDK&quot;
echo $text1
echo $text2
</code></pre><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><p>输出重定向:</p>
<pre><code>命令的执行结果输出到test.txt文件，不再输出到屏幕上
ls -al &gt; test.txt
</code></pre><p><img src="http://oph0qv0je.bkt.clouddn.com/shell1.png" alt=""></p>
<p>输入重定向:</p>
<pre><code>wc命令是输出test.txt文本中的行数，单词数，字节数,显示在屏幕上
wc &lt; test.txt
</code></pre><p><img src="http://oph0qv0je.bkt.clouddn.com/shell2.png" alt=""></p>
<p>wc命令在命令行中的使用</p>
<pre><code>wc &lt;&lt; EOF 然后输入一些文本，最后输入一个EOF结束
</code></pre><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><pre><code>#1、使用命令，输出的结果作为c的值
#注意除号左右两边要有空格
c=$(expr $b / $a)
#2、使用方括号运算符代替expr命令
d=$[$b/$a]

echo &quot;c:$c&quot;
echo &quot;d:$d&quot;
</code></pre><h3 id="浮点数的处理"><a href="#浮点数的处理" class="headerlink" title="浮点数的处理"></a>浮点数的处理</h3><p>基本运算不支持浮点数，为了支持浮点数，需要用bc命令：</p>
<pre><code>a=10
e=$(echo &quot;scale=4; $a / 3&quot; | bc)
echo &quot;e:$e&quot;
</code></pre><p>其中|是管道的意思，一个命令的输出作为另外一个命令的输入。</p>
<p>scale是自带的内建变量:</p>
<pre><code>#内联输入重定向，多次运算的时候
f=$(bc &lt;&lt; EOF
scale=4
a1=($a * $b)
a1 / 3
EOF
)
</code></pre><h2 id="命令执行退出的状态："><a href="#命令执行退出的状态：" class="headerlink" title="命令执行退出的状态："></a>命令执行退出的状态：</h2><pre><code>0 成功
127 没有找到命令
1 未知错误
126 命令不可执行
</code></pre><p>查看与退出状态指定：</p>
<pre><code>查看上一次命令的执行状态
echo $?

在shell脚本中，自己指定退出的状态
exit 状态码
</code></pre><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>只有if命令的退出状态码为0，才会执行then部分</p>
<pre><code>if 命令
then 
   命令
fi
</code></pre><p>if语句举例：</p>
<pre><code>#!/bin/bash
testuser=lady
#查找passwd里面是否有对应的目录
if grep $testuser /etc/passwd 
then
    echo &quot;ok&quot;
    ls -a /home/$testuser/
#如果passwd中没有目录，再判断是否有这个目录
elif ls -d /home/$testuser
then
    echo &quot;用户不存在，主目录仍然存在&quot;
#其他情况    
else
    #可以继续嵌套if
    #if 
    #then
    echo &quot;$testuser not exist&quot;
fi
</code></pre><p>grep命令是查找命令</p>
<p>可以结合test命令，如果条件成立，test命令以状态为0退出，if条件成立。</p>
<p>test命令简单形式，用中括号，注意空格要加上，举例如下：</p>
<pre><code>#!/bin/bash
a=10
b=5
#test命令简单形式
if [ $a -gt $b ]
then
    echo &quot;$a greater than $b&quot;
else
    echo &quot;$a smaller than $b&quot;
fi
</code></pre><p><strong>test数值比较：</strong></p>
<pre><code>-gt
-eq 等于
-le 
-ne 不等于
</code></pre><p>判空：</p>
<pre><code>#!/bin/bash
str1=&quot;&quot;
if [ str1 = &quot;&quot; ]                                                            
then
    echo &quot;有内容&quot;
else
    echo &quot;没内容&quot;
fi
</code></pre><p><strong>test字符串比较：</strong></p>
<pre><code>str1 == str2
str1 != str2
str1 &lt; str2
-n str1 长度是否非0
-z str1 长度是否为0
</code></pre><p><strong>test文件比较：</strong></p>
<pre><code>-d 检查是否存在，并且是一个目录
-e 检查file是否存在
-f 检查是否存在，并且是一个文件
-r 检查是否存在，并且可读
-w、-x
file1 -nt file2 file1比file2新
file1 -ot file2 file1比file2旧
</code></pre><p>举例：</p>
<pre><code>#!/bin/bash
mydir=/usr/jason
#-d检查目录是否存在
if [ -d $mydir ]
then
    echo &quot;$mydir exist&quot;
    cd $mydir
    ls
else
    echo &quot;mydir not exist&quot;
fi
</code></pre><p>多个条件的时候：</p>
<pre><code>#!/bin/bash
#多个条件 []
mydir=/usr/jason/shell
#任意数学赋值或者比较表达式
#if (( a++ &gt; 90 ))
if [ -d $HOME ] &amp;&amp; [ -w $mydir ]
then
    cd $mydir
    touch test5
else
    echo &quot;no&quot;
fi
</code></pre><h2 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h2><p>格式：</p>
<pre><code>case 变量 in
pattern1) 命令;;
pattern2) 命令;;
*) 默认命令;;
esac
</code></pre><p>举例：</p>
<pre><code>#!/bin/bash
testuser=rose

case $testuser in
rose)
    echo &quot;hi,$testuser&quot;;;
ricky)
    echo &quot;hello, ricky&quot;;;
*)
    echo &quot;defaults&quot;;;
esac
</code></pre><h2 id="for循环命令"><a href="#for循环命令" class="headerlink" title="for循环命令"></a>for循环命令</h2><p>格式：</p>
<pre><code>for var in list
do
    命令
done  
</code></pre><p>举例1：</p>
<pre><code>#!/bin/bash

for item in 1 2 3 4 5
do
    echo $item
done
</code></pre><p>举例2：</p>
<pre><code>#使用字符串的时候一定要注意转义字符，\#、\&apos;等
list=&quot;windows--linux--macos&quot;
#IFS字段分隔符
IFS=$--
for item in $list
do
    echo $item
done
</code></pre><h2 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a>while命令</h2><p>格式：</p>
<pre><code>while test command（或者[]）
do
    命令
done
</code></pre><p>举例：</p>
<pre><code>#!/bin/bash

a=10
while [ $a -gt 0 ]
do
    echo &quot;num:$a&quot;
    #赋值不用使用$符号
    a=$[ $a - 1 ]
    if [ $a -eq 5 ]
    then
        echo &quot;break&quot;
        break
    fi
done
</code></pre><p><strong>注意：</strong></p>
<p><strong>编译ffmpeg</strong></p>
<p><strong>编写shell脚本之前，要执行./configure –disable-yasm，主要目的进行一系列的准备工作，比如说检查gcc的版本，会生成config.mak等文件</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/FFmpeg学习系列-二-Linux基本命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/27/FFmpeg学习系列-二-Linux基本命令/" itemprop="url">
                  FFmpeg学习系列(二)Linux基本命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T13:45:49+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux相关命令"><a href="#Linux相关命令" class="headerlink" title="Linux相关命令"></a>Linux相关命令</h2><p>清空命令行：reset</p>
<p>文件操作：</p>
<pre><code>显示列表

ls -l 
ls -la 所有
ls -l ja* 通配符查找
</code></pre><p>创建目录：</p>
<pre><code>mkdir 目录名字
</code></pre><p>创建文件</p>
<pre><code>touch today.c
</code></pre><p>复制文件</p>
<pre><code>cp src.txt dest.txt
cp -i src.txt dest.txt 询问
cp src.txt . 复制到当前目录
cp -R 目录 dest 复制整个目录到指定路径
cp c_?1 ../  通配符复制到上级目录
</code></pre><p>删除文件</p>
<pre><code>rm file.txt
</code></pre><p>删除目录</p>
<pre><code>rm -rf 目录
</code></pre><p>查看文件类型：</p>
<pre><code>file src.txt
</code></pre><p>查看文件内容：</p>
<pre><code>cat src.txt
cat -n src.txt 显示行号
</code></pre><p>查看文件最后10行</p>
<pre><code>tail -n 10 src.txt
</code></pre><p>查看文件最开始的10行</p>
<pre><code>head -n 10 src.txt
</code></pre><p>安装与卸载软件</p>
<pre><code>sudo apt-get install vim-gtk
sudo apt remove vim
</code></pre><p>创建用户</p>
<pre><code>useradd -m jack 创建用户的同时，创建了home目录
userdel -r jack 删除用户
</code></pre><p>切换用户 </p>
<pre><code>su jack
</code></pre><p>修改用户密码</p>
<pre><code>sudo passwd 123456abc
</code></pre><p>退出</p>
<pre><code>exit
</code></pre><p>创建组</p>
<pre><code>groupadd androidgroup
</code></pre><p>分配用户到组</p>
<pre><code>usermod -G androidgroup jack
</code></pre><p>文件权限</p>
<pre><code>r读 w写 x执行
drwxr-xr-x
d rwx r-x r-x (d为目录，后面三个为一组，为一个二进制数)
d目录
这里用1,2,3表示上面三组数据的权限
1.文件所属用户具备的权限（root对该文件具备读写执行权限）
2.文件所属用户的所属组具备的权限（读、执行）
3.系统的其他用户具备的权限（读、执行）
</code></pre><p>rwx必须是固定顺序</p>
<pre><code>权限      二进制     八进制
---         000         0
--x         001         1
-w-         010         2
-wx         011         3
r--         100         4
r-x         101         5
rw-         110         6
rwx         111         7
</code></pre><p>修改文件权限</p>
<pre><code>chmod 644 file
</code></pre><p>给用户加上执行权限</p>
<pre><code>chmod u+x file
</code></pre><p>改变创建目录的默认权限：</p>
<pre><code>创建出来的权限就是 777 - 022 = 755权限
umask 022（默认是026）
</code></pre><p>改变文件的所属</p>
<pre><code>更改用户，使file文件在user用户下
chown user file
更改用户组
chown user.group file
chown .group file
</code></pre><p>每一个用户的Hmoe目录都会有bash、bashrc文件，bash、bashrc是每一个用户登录的时候会加载的文件，里面配置的是全局的配置，例如环境变量。</p>
<h2 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h2><p>vim有两种模式，命令模式、插入模式</p>
<p><strong>命令模式中的一些基本操作：</strong></p>
<ol>
<li>删除一行：dd ， 删除一个字符x</li>
<li>撤销：u，重做：ctrl+r</li>
<li>进入插入模式：i</li>
<li>翻页：ctrl + f（上一页） ctrl + b（下一页）</li>
<li>复制行：yy , 粘贴：p</li>
<li>文本搜索： ?正则enter 搜索n或者N控制方向</li>
<li>保存： :w</li>
<li>保存退出： :wq</li>
<li>不保存强制退出： q!</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/FFmpeg学习系列-一-Linux下编译FFmpeg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/21/FFmpeg学习系列-一-Linux下编译FFmpeg/" itemprop="url">
                  FFmpeg学习系列(一)Linux下编译FFmpeg
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T14:48:55+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">FFmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在android中进行FFmpeg开发时，我们需要用到编译好的.so库，这些.so需要在Linux环境下进行编译。</p>
<h2 id="Linux下编译FFmpeg步骤"><a href="#Linux下编译FFmpeg步骤" class="headerlink" title="Linux下编译FFmpeg步骤"></a>Linux下编译FFmpeg步骤</h2><p><strong>1.如果不是Linux操作系统，需要购买阿里云主机，镜像可以选择ubuntu 14.04 64位。</strong></p>
<p><strong>2.安装XShell（内含Xftp）、Xftp来对服务器进行操作、文件传输</strong></p>
<p>需要配置Xshell来连接阿里云服务器：</p>
<p>点击XShell客户端 文件-&gt;打开，弹出会话对话框，点击 “新建”，在对话框中填写“名称”（可随便起一个），主机处填写公网地址点击确认进行连接，然后填写用户，密码。</p>
<p>连接成功之后，点击Xshell客户端的“新建文件传输”，弹出Xftp,一般在usr下新建一个ndk文件，把我们的ndk拖入ndk文件中。</p>
<p><strong>3.安装VIM</strong>  sudo apt-get install vim-gtk</p>
<p>安装后如果输入vim不能使用,提示No such file or directory, 更新一下apt-get update</p>
<p>3.1通过vim编辑一个文本：</p>
<pre><code>vim isen.txt 进入命令模式。
</code></pre><p>在命令模式退出：</p>
<pre><code>按shift + :，输入q!强制退出（不保存退出）

保存退出,shift + z z
</code></pre><p>命令模式进入编辑模式：</p>
<pre><code>按i键
</code></pre><p>编辑模式退出进入命令模式：</p>
<pre><code>按Esc键
</code></pre><p>在命令模式中：</p>
<pre><code>x删除，dd删除行
</code></pre><p><strong>4.vim配置(高亮显示，行号之类的)</strong></p>
<p>一般vim正常安装在/etc/vim/中。</p>
<pre><code>通过vim打开vimrc

vim /etc/vim/vimrc

在末尾添加如下命令
set nu
set tabstop
set cursorline
set ruler
</code></pre><p><strong>5.NDK安装</strong></p>
<p>cd进入ndk目录中，输入ls命令</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/linux_ndk.png" alt=""></p>
<p>发现ndk字体是白色的，表示没有权限不可执行，绿色表示可执行，我们需要给权限让其可执行</p>
<pre><code>目录给权限：chmod 777 -R ndk
其中-R代表ndk是一个目录
</code></pre><p><img src="http://oph0qv0je.bkt.clouddn.com/linux_ndk2.png" alt=""></p>
<p>ndk目录为绿色可执行。</p>
<pre><code>解压ndk：./android-ndk-r10e-linux-x86_64.bin 
</code></pre><p>环境变量配置：</p>
<pre><code>命令vim ~/.bashrc
添加：
export NDKROOT=/usr/ndk/android-ndk-r10e
export PATH=$NDKROOT:$PATH
</code></pre><p>更新环境变量：</p>
<pre><code>source ~/.bashrc
</code></pre><p><strong>6.准备FFmpeg</strong></p>
<p>我们需要去FFmpeg官网下载FFmpeg的Linux源码，版本不需要太新：</p>
<pre><code>ffmpeg-2.6.9.zip
</code></pre><p>然后执行解压缩命令：</p>
<pre><code>unzip ffmpeg-2.6.9.zip
</code></pre><p><strong>7.编译FFmpeg</strong></p>
<p>我们需要编写shell脚本传参调用ffmpeg-2.6.9下的configure脚本进行编译。</p>
<p>1）编写shell脚本文件build_android.sh：</p>
<pre><code>#!/bin/bash
make clean
export NDK=/usr/ndk/android-ndk-r10e
export SYSROOT=$NDK/platforms/android-9/arch-arm/
export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64
export CPU=arm
export PREFIX=$(pwd)/android/$CPU
export ADDI_CFLAGS=&quot;-marm&quot;

./configure --target-os=linux \
--prefix=$PREFIX --arch=arm \
--disable-doc \
--enable-shared \
--disable-static \
--disable-yasm \
--disable-symver \
--enable-gpl \
--disable-ffmpeg \
--disable-ffplay \
--disable-ffprobe \
--disable-ffserver \
--disable-doc \
--disable-symver \
--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \
--enable-cross-compile \
--sysroot=$SYSROOT \
--extra-cflags=&quot;-Os -fpic $ADDI_CFLAGS&quot; \
--extra-ldflags=&quot;$ADDI_LDFLAGS&quot; \
$ADDITIONAL_CONFIGURE_FLAG
make clean
make
make install
</code></pre><p>shell脚本中指定NDK的一些路径（export NDK=/usr/ndk/android-ndk-r10e），配置CPU架构类型（export CPU=arm），PREFIX是指定动态库输出的路径，然后disable一些不需要的库（可减小输出的动态库的大小）等等。enable-shared是生成共享库的意思。</p>
<p>关于shell脚本需要注意：</p>
<ol>
<li><p>换行的时候需要有\，注意不要有额外的空格，否则编译出错</p>
</li>
<li><p>脚本文件统一转为UTF-8无BOM格式。可以通过note pad++进行转码，这样子Windows和Linux都通用了。也可以通过dos2unix命令进行转码后在Linux中使用。或者先由Linux创建文件再由Windows编辑。</p>
</li>
<li><p>NDK尽量不要使用太新的版本，一般使用Android-9即可。新版本会出现不兼容的问题，比如LOG2的问题等等。</p>
</li>
</ol>
<p>2）将编写好的shell脚本放在解压后的ffmpeg-2.6.9文件夹中。</p>
<pre><code>然后ffmpeg-2.6.9文件给权限
chmod 777 -R ffmpeg-2.6.9
</code></pre><p>3) cd进入ffmpeg-2.6.9文件夹中</p>
<pre><code>执行 ./android_build.sh
</code></pre><p>如果出现问题bad interpreter : No such file or directory,需要将文件转成Linux编码格式<br>有两种方式：</p>
<pre><code>1，在Linux下创建这个文件touch android_build.sh，从Linux传出到桌面把脚本命令拷入这个文件中，在上传上Linux中去给权限就可以啦

2，使用 dos2unix android_build.sh 转成Linux编码格式
</code></pre><p><strong>8.编译完成之后生成如下动态库：</strong></p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ffmpeg_so.png" alt=""></p>
<p>我们可以看到生成的有.56,.5之类的库，对于这种库android很难加载到，因此要把这个名字加载到前面，以.so结尾，因此，我们需要修改configure文件。</p>
<p><strong>9.修改configure文件</strong></p>
<p>ffmpeg-2.6.9根目录下有个configure文件，这个文件比较重要，通过这个文件我们可以看到FFmpeg库之间的依赖关系。我们自己写的脚本文件就是依据这个文件来写的。</p>
<p>这里我们需要修改一下输出的动态库的命名规则：</p>
<pre><code>#修改前
#SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;
#LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;
#SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;
#SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;
#修改后
SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;
LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;
SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;
SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;
</code></pre><p>然后进行重新编译，生成动态库如下：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/ffmpeg_so2.png" alt=""></p>
<p>我们就可以在我们的android项目中应用这些库啦（使用的时候我们用大版本号的.so库）。</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/big_version.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/18/C++学习系列-六-IO与STL标准模板库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/18/C++学习系列-六-IO与STL标准模板库/" itemprop="url">
                  C++学习系列(六)IO与STL标准模板库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-18T11:50:11+08:00">
                2017-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-的IO操作"><a href="#C-的IO操作" class="headerlink" title="C++的IO操作"></a>C++的IO操作</h2><p>文本文件操作</p>
<pre><code>void main(){
    char* fname = &quot;c://dest.txt&quot;;
    //输出流
    ofstream fout(fname);
    //创建失败
    if (fout.bad()){ //文件打开失败
        return;
    }

    fout &lt;&lt; &quot;jack&quot; &lt;&lt; endl;
    fout &lt;&lt; &quot;rose&quot; &lt;&lt; endl;

    //关闭
    fout.close();

    //读取
    ifstream fin(fname);
    if (fin.bad()){
        return;
    }
    char ch;
    while (fin.get(ch)){
        //输出
        cout &lt;&lt; ch;
    }
    fin.close();

    system(&quot;pause&quot;);
}
</code></pre><p>二进制文件操作</p>
<pre><code>void main(){
    char* src = &quot;c://src.jpg&quot;;
    char* dest = &quot;c://dest.jpg&quot;;

    //输入流
    ifstream fin(src, ios::binary);
    //输出流
    ofstream fout(dest, ios::binary);

    if (fin.bad() || fout.bad()){
        return;
    }

    while (!fin.eof()){
        //读取
        char buff[1024] = {0};
        fin.read(buff,1024);

        //写入
        fout.write(buff,1024);
    }

    //关闭
    fin.close();
    fout.close();

    system(&quot;pause&quot;);
}
</code></pre><p>C++对象的持久化</p>
<pre><code>class Person
{
public:
    Person()
    {

    }
    Person(char * name, int age)
    {
        this-&gt;name = name;
        this-&gt;age = age;
    }
    void print()
    {
        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;
    }
private:
    char * name;
    int age;
};


void main()
{
    Person p1(&quot;柳岩&quot;, 22);
    Person p2(&quot;rose&quot;, 18);
    //输出流
    ofstream fout(&quot;c://c_obj.data&quot;, ios::binary);
    fout.write((char*)(&amp;p1), sizeof(Person)); //指针能够读取到正确的数据，读取内存区的长度
    fout.write((char*)(&amp;p2), sizeof(Person));
    fout.close();

    //输入流
    ifstream fin(&quot;c://c_obj.data&quot;, ios::binary);
    Person tmp;
    fin.read((char*)(&amp;tmp), sizeof(Person));
    tmp.print();

    fin.read((char*)(&amp;tmp), sizeof(Person));
    tmp.print();

    system(&quot;pause&quot;);

}
</code></pre><h2 id="C-中STL"><a href="#C-中STL" class="headerlink" title="C++中STL"></a>C++中STL</h2><p>STL:standard template library 标准模板库，类似于Java中的util工具集等。</p>
<pre><code>#include &lt;string&gt;
void main()
{
    string s1 = &quot;craig david&quot;;
    string s2(&quot; 7 days&quot;);
    string s3 = s1 + s2;

    cout &lt;&lt; s3 &lt;&lt; endl;

    //转c字符串
    const char* c_str = s3.c_str();
    cout &lt;&lt; c_str &lt;&lt; endl;

    //s1.at(2);


    system(&quot;pause&quot;);
}
</code></pre><p>这里的是c++中的string，在jni开发时，需要先将c++中的string转为c的string，再转换成Java的string。</p>
<pre><code>//容器
#include &lt;vector&gt;

void main()
{
    //动态数组
    //不需要使用动态内存分配，就可以使用动态数组
    vector&lt;int&gt; v;
    v.push_back(12);
    v.push_back(10);
    v.push_back(5);

    for (int i = 0; i &lt; v.size(); i++)
    {
        cout &lt;&lt; v[i] &lt;&lt; endl;
    }

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/11/C++学习系列-五-C++中的类型转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/11/C++学习系列-五-C++中的类型转换/" itemprop="url">
                  C++学习系列(五)C++中的类型转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-11T09:11:34+08:00">
                2017-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h2><p>类型转换分类：</p>
<ol>
<li>static_cast 普遍情况（一般的数据类型转换等）。</li>
<li>const_cast 去常量。</li>
<li>dynamic_cast 子类类型转为父类类型。</li>
<li>reinterpret_cast 函数指针转型，不具备移植性。</li>
</ol>
<p>对于原始类型转换来说，所有情况都是一种写法，可读性不高，有可能有潜在的风险。</p>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>一般用于类型转换：</p>
<pre><code>//void*表示这个函数有可能返回不同类型的指针
void* func(int type){    
    switch (type){
    case 1:    {
                int i = 9;
                return &amp;i;
    }
    case 2:    {
                int a = &apos;X&apos;;
                return &amp;a;
    }
    default:{
                return NULL;
    }

    }    
}

void func2(char* c_p){
    cout &lt;&lt; *c_p &lt;&lt; endl;
}    

void main(){    
    //int i = 0;
    //自动转换
    //double d = i;
    //double d = 9.5;
    //int i = d;

    //int i = 8;
    //double d = 9.5;
    //i = static_cast&lt;int&gt;(d);

    //void* -&gt; char*
    //char* c_p = (char*)func(2);
    //char* c_p = static_cast&lt;char*&gt;(func(2));

    //C++ 意图明显
    func2(static_cast&lt;char*&gt;(func(2)));
    //C
    func2((char*)(func(2)));

    system(&quot;pause&quot;);
}
</code></pre><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>去除常量：</p>
<pre><code>void func(const char c[]){
    //c[1] = &apos;a&apos;;
    //通过指针间接赋值
    //其他人并不知道，这次转型是为了去常量
    //char* c_p = (char*)c;
    //c_p[1] = &apos;X&apos;;
    //提高了可读性
    char* c_p = const_cast&lt;char*&gt;(c);
    c_p[1] = &apos;Y&apos;;

    cout &lt;&lt; c &lt;&lt; endl;
}

void main(){
    char c[] = &quot;hello&quot;;
    func(c);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>用于继承关系中，父类、子类的转换：</p>
<pre><code>class Person{
public:
    virtual void print(){
        cout &lt;&lt; &quot;人&quot; &lt;&lt; endl;
    }
};

class Man : public Person{
public:
    void print(){
        cout &lt;&lt; &quot;男人&quot; &lt;&lt; endl;
    }

    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
};


class Woman : public Person{
public:
    void print(){
        cout &lt;&lt; &quot;女人&quot; &lt;&lt; endl;
    }

    void carebaby(){
        cout &lt;&lt; &quot;生孩子&quot; &lt;&lt; endl;
    }
};

void func(Person* obj){    

    //调用子类的特有的函数，转为实际类型
    //c的写法
    //并不知道转型失败
    //Man* m = (Man*)obj;
    //m-&gt;print();

    //C++的写法
    //转型失败，返回NULL
    Man* m = dynamic_cast&lt;Man*&gt;(obj);    
    if (m != NULL){
        m-&gt;chasing();
    }

    Woman* w = dynamic_cast&lt;Woman*&gt;(obj);
    if (w != NULL){
        w-&gt;carebaby();
    }
}

void main(){

    //Woman w1;
    //Person *p1 = &amp;w1;

    //func(p1);

    Woman w1;
    Woman* w_p = &amp;w1;


    system(&quot;pause&quot;);
}
</code></pre><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>函数指针的转换，不经常使用：</p>
<pre><code>void func1(){
    cout &lt;&lt; &quot;func1&quot; &lt;&lt; endl;
}

char* func2(){
    cout &lt;&lt; &quot;func2&quot; &lt;&lt; endl;
    return &quot;abc&quot;;
}

typedef void(*f_p)();

void main(){
    //函数指针数组
    f_p f_array[6];
    //赋值
    f_array[0] = func1;

    //C方式
    //f_array[1] = (f_p)(func2);
    //C++方式
    f_array[1] = reinterpret_cast&lt;f_p&gt;(func2);

    f_array[1]();

    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/09/C++学习系列-四-C++中的异常处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/09/C++学习系列-四-C++中的异常处理/" itemprop="url">
                  C++学习系列(四)C++中的异常处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-09T10:09:55+08:00">
                2017-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++异常处理，根据抛出的异常数据类型，进入到相应的catch块中。</p>
<pre><code>void main(){
    try{
        int age = 300;
        if (age &gt; 200){
            throw 9.8;
        }
    }
    catch (int a){
        cout &lt;&lt; &quot;int异常&quot; &lt;&lt; endl;
    }
    catch (char* b){
        cout &lt;&lt; b &lt;&lt; endl;
    }
    catch (...){// ...表示任意类型
        cout &lt;&lt; &quot;未知异常&quot; &lt;&lt; endl;
    }
    system(&quot;pause&quot;);
}
</code></pre><p>根据throw抛出不同类型的异常，就会在相应的catch块里面捕获到，其中…代表任意类型。一旦有catch块捕获，后面的catch就不会执行。</p>
<p><strong>throw 抛出函数外</strong></p>
<pre><code>void mydiv(int a, int b){
    if (b == 0){
        throw &quot;除数为零&quot;;
    }
}

void func(){
    try{
        mydiv(8, 0);
    }
    catch (char* a){
        throw a;
    }
}

void main(){
    try{
        func();
    }
    catch (char* a){
        cout &lt;&lt; a &lt;&lt; endl;
    }
    system(&quot;pause&quot;);
}
</code></pre><p>异常在函数里面抛出的话，可以一层一层往外抛出。</p>
<p><strong>抛出对象</strong></p>
<pre><code>class MyException{

};

void mydiv(int a, int b){
    if (b == 0){
        throw MyException();
        //throw new MyException; //不要抛出异常指针        
    }
}

void main(){
    try{
        mydiv(8,0);
    }
    catch (MyException&amp; e2){
        cout &lt;&lt; &quot;MyException引用&quot; &lt;&lt; endl;
    }
    //会产生对象的副本
    //catch (MyException e){
    //    cout &lt;&lt; &quot;MyException&quot; &lt;&lt; endl;
    //}
    catch (MyException* e1){
        cout &lt;&lt; &quot;MyException指针&quot; &lt;&lt; endl;        
        delete e1;
    }

    system(&quot;pause&quot;);
}
</code></pre><p><strong>标准异常（类似于Java NullPointerException）</strong></p>
<pre><code>#include &lt;stdexcept&gt;

class NullPointerException : public exception{
public:
    NullPointerException(char* msg) : exception(msg){

    }
};

void mydiv(int a, int b){
    if (b &gt; 10){
        throw out_of_range(&quot;超出范围&quot;);        
    }    
    else if (b == NULL){
        throw NullPointerException(&quot;为空&quot;);
    }
    else if (b == 0){
        throw invalid_argument(&quot;参数不合法&quot;);
    }
}

void main(){
    try{
        mydiv(8,NULL);
    }
    catch (out_of_range e1){
        cout &lt;&lt; e1.what() &lt;&lt; endl;
    }
    catch (NullPointerException&amp; e2){
        cout &lt;&lt; e2.what() &lt;&lt; endl;
    }
    catch (...){

    }

    system(&quot;pause&quot;);
}
</code></pre><p><strong>外部类异常</strong></p>
<pre><code>class Err{
public:
    class MyException{
        public:MyException(){

        }
    };
};

void mydiv(int a, int b){
    if (b &gt; 10){
        throw Err::MyException();
    }

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/30/C++学习系列-三-继承与多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/30/C++学习系列-三-继承与多态/" itemprop="url">
                  C++学习系列(三)继承与多态
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-30T11:12:10+08:00">
                2017-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++是面向对象的编程语言，因此具有继承和多态的基本特征。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承主要是提高代码的重用性。</p>
<p>举例：</p>
<pre><code>//人类
class Human{
public:
    void say(){
        cout &lt;&lt; &quot;说话&quot; &lt;&lt; endl;
    }
protected:
    char* name;
    int age;
};

//男人
class Man : public Human{
public:
    //泡妞
    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;        
    }
private:
    //兄弟
    char* brother;
};

void work(Human&amp; h){
    h.say();
}

void main(){
    Man m1;
    m1.say();

    //1.父类类型的引用或指针
    Human* h_p = &amp;m1;
    h_p-&gt;say();

    Human &amp;h1 = m1;
    h1.say();

    //子类对象初始化父类类型的对象
    Human h2 = m1;

    system(&quot;pause&quot;);
}
</code></pre><p>上面代码我们可以看出，通过:public来继承Human。</p>
<h3 id="向父类构造方法传参"><a href="#向父类构造方法传参" class="headerlink" title="向父类构造方法传参"></a>向父类构造方法传参</h3><pre><code>class Human{
public:
    Human(char* name, int age){
        this-&gt;name = name;
        this-&gt;age = age;
    }
    void say(){
        cout &lt;&lt; &quot;说话&quot; &lt;&lt; endl;
    }
protected:
    char* name;
    int age;
};

//男人
class Man : public Human{
public:
    //给父类构造函数传参，同时给属性对象赋值
    Man(char *brother, char *s_name, int s_age, char *h_name, int h_age) : Human(s_name, s_age), h(h_name,h_age){
        this-&gt;brother = brother;
    }
    //泡妞
    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
private:
    //兄弟
    char* brother;
    Human h;
};

void main(){
    Man m1(&quot;danny&quot;,&quot;jack&quot;,18,&quot;jason&quot;,18);

    system(&quot;pause&quot;);
}
</code></pre><p>通过在自身构造的时候给父类构造函数传参。子类构造的时候，会先构造父类。</p>
<h3 id="子类与父类构造函数与析构函数调用的顺序"><a href="#子类与父类构造函数与析构函数调用的顺序" class="headerlink" title="子类与父类构造函数与析构函数调用的顺序"></a>子类与父类构造函数与析构函数调用的顺序</h3><pre><code>class Human{
public:
    Human(char* name, int age){
        this-&gt;name = name;
        this-&gt;age = age;
        cout &lt;&lt; &quot;Human 构造函数&quot; &lt;&lt; endl;
    }
    ~Human(){
        cout &lt;&lt; &quot;Human 析构函数&quot; &lt;&lt; endl;
    }
    void say(){
        cout &lt;&lt; &quot;说话&quot; &lt;&lt; endl;
    }
protected:
    char* name;
    int age;
};

//男人
class Man : public Human{
public:
    //给父类构造函数传参，同时给属性对象赋值
    Man(char *brother, char *s_name,int s_age) : Human(s_name, s_age){
        this-&gt;brother = brother;
        cout &lt;&lt; &quot;Man 构造函数&quot; &lt;&lt; endl;
    }
    ~Man(){
        cout &lt;&lt; &quot;Man 析构函数&quot; &lt;&lt; endl;
    }
    //泡妞
    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
private:
    //兄弟
    char* brother;    
};

void func(){
    //父类构造函数先调用
    //子类的析构函数先调用
    Man m1(&quot;danny&quot;, &quot;jack&quot;, 18);
}

void main(){
    func();

    system(&quot;pause&quot;);
}
</code></pre><p>构造的时候先调用父类的构造函数，然后调用子类的构造函数。析构的时候相反。总结就是，先构造，先释放。</p>
<h3 id="子类对象调用父类的成员"><a href="#子类对象调用父类的成员" class="headerlink" title="子类对象调用父类的成员"></a>子类对象调用父类的成员</h3><pre><code>class Human{
public:
    Human(char* name, int age){
        this-&gt;name = name;
        this-&gt;age = age;
        cout &lt;&lt; &quot;Human 构造函数&quot; &lt;&lt; endl;
    }
    ~Human(){
        cout &lt;&lt; &quot;Human 析构函数&quot; &lt;&lt; endl;
    }
    void say(){
        cout &lt;&lt; &quot;说话&quot; &lt;&lt; endl;
    }
public:
    char* name;
    int age;
};

//男人
class Man : public Human{
public:
    //给父类构造函数传参，同时给属性对象赋值
    Man(char *brother, char *s_name, int s_age) : Human(s_name, s_age){
        this-&gt;brother = brother;
        cout &lt;&lt; &quot;Man 构造函数&quot; &lt;&lt; endl;
    }
    ~Man(){
        cout &lt;&lt; &quot;Man 析构函数&quot; &lt;&lt; endl;
    }
    //泡妞
    void chasing(){
        cout &lt;&lt; &quot;泡妞&quot; &lt;&lt; endl;
    }
    void say(){
        cout &lt;&lt; &quot;男人喜欢装逼&quot; &lt;&lt; endl;
    }
private:
    //兄弟
    char* brother;
};

void main(){
    //是覆盖，并非动态
    Man m1(&quot;alan&quot;,&quot;john&quot;,18);
    m1.say();
    //调用父类的say方法
    m1.Human::say();

    m1.Human::age = 10;

    system(&quot;pause&quot;);
}
</code></pre><p>注意：Java中就无法使用被覆盖的父类方法，可以通过JNI的方式访问。</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><pre><code>//人
class Person{

};

//公民
class Citizen{

};

//学生，既是人，又是公民
class Student : public Person, public Citizen{

};
</code></pre><h3 id="继承的访问修饰符"><a href="#继承的访问修饰符" class="headerlink" title="继承的访问修饰符"></a>继承的访问修饰符</h3><pre><code>基类中      继承方式             子类中
public     ＆ public继承        =&gt; public
public     ＆ protected继承     =&gt; protected   
public     ＆ private继承       =&gt; private

protected  ＆ public继承        =&gt; protected
protected  ＆ protected继承     =&gt; protected   
protected  ＆ private继承       =&gt; private

private    ＆ public继承        =&gt; 子类无权访问
private    ＆ protected继承     =&gt; 子类无权访问
private    ＆ private继承       =&gt; 子类无权访问
</code></pre><h3 id="继承的二义性"><a href="#继承的二义性" class="headerlink" title="继承的二义性"></a>继承的二义性</h3><pre><code>class A{
public:
    char* name;
};

class A1 : public A{

};

class A2 : public A{

};

class B : public A1, public A2{

};

void main(){
    B b;

    //这句话编译不通过，因为存在二义性
    b.name = &quot;jason&quot;;

    //B中有两个name的副本，我们可以指定使用哪个父类的name
    b.A1::name = &quot;jason&quot;;
    b.A2::name = &quot;jason&quot;;

    system(&quot;pause&quot;);
}
</code></pre><p>如图：</p>
<p><img src="http://oph0qv0je.bkt.clouddn.com/virtual.png" alt=""></p>
<p>解决方法：虚继承，不同路径继承来的同名成员只有一份拷贝，解决不明确的问题</p>
<p>如果某个类B的两个父类（A1、A2）都继承于同一父类（A），那么这两个父类（A1、A2）可以通过在继承的时候加上virtual关键字来解决二义性问题。</p>
<pre><code>class A{
public:
    char* name;
};

class A1 : virtual public A{

};

class A2 : virtual public A{

};

class B : public A1, public A2{

};

void main(){
    B b;    
    b.name = &quot;jason&quot;;
    //指定父类显示调用
    //b.A1::name = &quot;jason&quot;;
    //b.A2::name = &quot;jason&quot;;
    system(&quot;pause&quot;);
}
</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态作用：程序的扩展性</p>
<p>动态多态：程序运行过程中，觉得哪一个函数被调用（重写）。</p>
<p>静态多态：重载。</p>
<p>发生动态多态的条件：</p>
<ol>
<li>继承</li>
<li>父类的引用或者指针指向子类的对象</li>
<li>函数的重写(需要增加virtual关键字，否则的话就是覆盖)</li>
</ol>
<p>举例：</p>
<p>Plane.h</p>
<pre><code>#pragma once

//普通飞机
class Plane{
public:
    virtual void fly();
    virtual void land();
};
</code></pre><p>Plane.cpp</p>
<pre><code>#include &quot;Plane.h&quot;

#include &lt;iostream&gt;
using namespace std;

void Plane::fly(){
    cout &lt;&lt; &quot;起飞&quot; &lt;&lt; endl;
}

void Plane::land(){
    cout &lt;&lt; &quot;着陆&quot; &lt;&lt; endl;
}
</code></pre><p>Jet.h</p>
<pre><code>#pragma once

#include &quot;Plane.h&quot;

//直升飞机
class Jet : public Plane{
    virtual void fly();
    virtual void land();
};
</code></pre><p>Jet.cpp</p>
<pre><code>#include &quot;Jet.h&quot;
#include &lt;iostream&gt;
using namespace std;

void Jet::fly(){
    cout &lt;&lt; &quot;直升飞机在原地起飞...&quot; &lt;&lt; endl;
}

void Jet::land(){
    cout &lt;&lt; &quot;直升飞机降落在女神的屋顶...&quot; &lt;&lt; endl;
}
</code></pre><p>Copter.h</p>
<pre><code>#pragma once

#include &quot;Plane.h&quot;

//普通飞机
class Copter : public Plane{
public:
    virtual void fly();
    virtual void land();
};
</code></pre><p>Copter.cpp</p>
<pre><code>#include &quot;Copter.h&quot;
#include &lt;iostream&gt;
using namespace std;

void Copter::fly(){
    cout &lt;&lt; &quot;喷气式飞机在跑道上起飞...&quot; &lt;&lt; endl;
}

void Copter::land(){
    cout &lt;&lt; &quot;喷气式飞机在跑道上降落...&quot; &lt;&lt; endl;
}
</code></pre><p>01.cpp</p>
<pre><code>#include &quot;Plane.h&quot;
#include &quot;Jet.h&quot;
#include &quot;Copter.h&quot;
//业务函数
void bizPlay(Plane&amp; p){
    p.fly();
    p.land();
}

void main(){
    Plane p1;
    bizPlay(p1);

    //直升飞机
    Jet p2;
    bizPlay(p2);

    Copter p3;
    bizPlay(p3);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="纯虚函数-抽象类"><a href="#纯虚函数-抽象类" class="headerlink" title="纯虚函数(抽象类)"></a>纯虚函数(抽象类)</h2><ol>
<li>当一个类具有一个纯虚函数，这个类就是抽象类</li>
<li>抽象类不能实例化对象</li>
<li>子类继承抽象类，必须要实现纯虚函数，如果没有，子类也是抽象类</li>
</ol>
<p>抽象类的作用：为了继承约束（新增加的类必须实现父类，提高代码重用性，保证系统的条理性、封闭性），根本不知道未来的实现</p>
<p>举例：</p>
<pre><code>class Shape{
public:
    //纯虚函数
    virtual void sayArea() = 0;
    void print(){
        cout &lt;&lt; &quot;hi&quot; &lt;&lt; endl;
    }
};

//圆
class Circle : public Shape{
public:
    Circle(int r){
        this-&gt;r = r;
    }
    void sayArea(){
        cout &lt;&lt; &quot;圆的面积：&quot; &lt;&lt; (3.14 * r * r) &lt;&lt; endl;
    }
private:
    int r;
};

void main(){
    //Shape s;抽象类不可实例化
    Circle c(10);

    system(&quot;pause&quot;);
}
</code></pre><h2 id="接口（只是逻辑上的划分，语法上跟抽象类的写法没有区别）"><a href="#接口（只是逻辑上的划分，语法上跟抽象类的写法没有区别）" class="headerlink" title="接口（只是逻辑上的划分，语法上跟抽象类的写法没有区别）"></a>接口（只是逻辑上的划分，语法上跟抽象类的写法没有区别）</h2><p>下面代码可以当做一个接口</p>
<pre><code>class Drawble{
    virtual void draw();
};
</code></pre><h2 id="模板函数（泛型）"><a href="#模板函数（泛型）" class="headerlink" title="模板函数（泛型）"></a>模板函数（泛型）</h2><pre><code>void myswap(int&amp; a,int&amp; b){
    int tmp = 0;
    tmp = a;
    a = b;
    b = tmp;
}

void myswap(char&amp; a, char&amp; b){
    char tmp = 0;
    tmp = a;
    a = b;
    b = tmp;
}
</code></pre><p>发现上面这两个函数业务逻辑一样，数据类型不一样，因此可以写成模板函数</p>
<pre><code>//模板函数
template &lt;typename T&gt;
void myswap(T&amp; a, T&amp; b){
    T tmp = 0;
    tmp = a;
    a = b;
    b = tmp;
}

void main(){
    //根据实际类型，自动推导
    int a = 10, b = 20;
    myswap&lt;int&gt;(a,b);
    cout &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; endl;

    char x = &apos;v&apos;, y = &apos;w&apos;;
    myswap(x, y);
    cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;

    system(&quot;pause&quot;);
}
</code></pre><h2 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h2><p>自己定义一个模板类：</p>
<pre><code>template&lt;class T&gt;
class A{
public:
    A(T a){
        this-&gt;a = a;
    }
protected:
    T a;
};
</code></pre><p>普通类继承模板类</p>
<pre><code>class B : public A&lt;int&gt;{
public:
    B(int a,int b) : A&lt;int&gt;(a){
        this-&gt;b = b;
    }
private:
    int b;
};
</code></pre><p>模板类继承模板类</p>
<pre><code>template &lt;class T&gt;
class C : public A&lt;T&gt;{
public:
    C(T c, T a) : A&lt;T&gt;(a){
        this-&gt;c = c;
    }
protected:
    T c;
};
</code></pre><p>实例化模板类</p>
<pre><code>void main(){
    //实例化模板类对象
    //List&lt;String&gt; list;
    A&lt;int&gt; a(6);
    system(&quot;pause&quot;);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Feng" />
          <p class="site-author-name" itemprop="name">Feng</p>
           
              <p class="site-description motion-element" itemprop="description">每天一小步，人生一大步</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
